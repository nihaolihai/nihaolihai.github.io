(window.webpackJsonp=window.webpackJsonp||[]).push([[408],{900:function(n,e,s){"use strict";s.r(e);var r=s(6),t=Object(r.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"linux下的socket演示程序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux下的socket演示程序"}},[this._v("#")]),this._v(" Linux下的socket演示程序")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('服务器端代码 server.cpp：\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\nint main(){\n    //创建套接字\n    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    //将套接字和IP、端口绑定\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充\n    serv_addr.sin_family = AF_INET;  //使用IPv4地址\n    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址\n    serv_addr.sin_port = htons(1234);  //端口\n    bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    //进入监听状态，等待用户发起请求\n    listen(serv_sock, 20);\n    //接收客户端请求\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_size = sizeof(clnt_addr);\n    int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);\n    //向客户端发送数据\n    char str[] = "http://c.biancheng.net/socket/";\n    write(clnt_sock, str, sizeof(str));\n   \n    //关闭套接字\n    close(clnt_sock);\n    close(serv_sock);\n    return 0;\n}\n\n客户端代码 client.cpp：\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\nint main(){\n    //创建套接字\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    //向服务器（特定的IP和端口）发起请求\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充\n    serv_addr.sin_family = AF_INET;  //使用IPv4地址\n    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址\n    serv_addr.sin_port = htons(1234);  //端口\n    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n   \n    //读取服务器传回的数据\n    char buffer[40];\n    read(sock, buffer, sizeof(buffer)-1);\n   \n    printf("Message form server: %s\\n", buffer);\n   \n    //关闭套接字\n    close(sock);\n    return 0;\n}\n\n启动一个终端（Shell），先编译 server.cpp 并运行：\n[admin@localhost ~]$ g++ server.cpp -o server\n[admin@localhost ~]$ ./server\n#等待请求的到来\n\n正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。\n\n接下再启动一个终端，编译 client.cpp 并运行：\n[admin@localhost ~]$ g++ client.cpp -o client\n[admin@localhost ~]$ ./client\nMessage form server: http://c.biancheng.net/socket/\n\nclient 接收到从 server发送过来的字符串就运行结束了，同时，server 完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。\n\nclient 运行后，通过 connect() 函数向 server 发起请求，处于监听状态的 server 被激活，执行 accept() 函数，接受客户端的请求，然后执行 write() 函数向 client 传回数据。client 接收到传回的数据后，connect() 就运行结束了，然后使用 read() 将数据读取出来。\nserver 只接受一次 client 请求，当 server 向 client 传回数据后，程序就运行结束了。如果想再次接收到服务器的数据，必须再次运行 server，所以这是一个非常简陋的 socket 程序，不能够一直接受客户端的请求。\n源码解析\n1) 先说一下 server.cpp 中的代码。\n\n第 11 行通过 socket() 函数创建了一个套接字，参数 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向连接的套接字，IPPROTO_TCP 表示使用 TCP 协议。在 Linux 中，socket 也是一种文件，有文件描述符，可以使用 write() / read() 函数进行 I/O 操作，这一点已在《socket是什么》中进行了讲解。\n\n第 19 行通过 bind() 函数将套接字 serv_sock 与特定的 IP 地址和端口绑定，IP 地址和端口都保存在 sockaddr_in 结构体中。\n\nsocket() 函数确定了套接字的各种属性，bind() 函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。\n\n第 22 行让套接字处于被动监听状态。所谓被动监听，是指套接字一直处于“睡眠”中，直到客户端发起请求才会被“唤醒”。\n\n第 27 行的 accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。\n\n第 31 行的 write() 函数用来向套接字文件中写入数据，也就是向客户端发送数据。\n\n和普通文件一样，socket 在使用完毕后也要用 close() 关闭。\n\n2) 再说一下 client.cpp 中的代码。client.cpp 中的代码和 server.cpp 中有一些区别。\n\n第 19 行代码通过 connect() 向服务器发起请求，服务器的IP地址和端口号保存在 sockaddr_in 结构体中。直到服务器传回数据后，connect() 才运行结束。\n\n第 23 行代码通过 read() 从套接字文件中读取数据。\n\n')])])])])}),[],!1,null,null,null);e.default=t.exports}}]);