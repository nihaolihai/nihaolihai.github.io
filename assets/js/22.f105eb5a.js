(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{512:function(a,e,t){"use strict";t.r(e);var N=t(6),o=Object(N.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"hdfs架构和实现机制简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hdfs架构和实现机制简介"}},[a._v("#")]),a._v(" HDFS架构和实现机制简介")]),a._v(" "),t("p",[a._v("HDFS 是一个主从 Master/Slave 架构。一个 HDFS 集群包含一个 NameNode，这是一个 Master Server，用来管理文件系统的命名空间，以及调节客户端对文件的访问。一个 HDFS 集群还包括多个 DataNode，用来存储数据。HDFS 的整体结构如图 1 所示\n"),t("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190508/5-1Z50Q22RV57.gif",alt:"RUNOOB 图标"}}),a._v("\nHDFS 会对外暴露一个文件系统命名空间，并允许用户数据以文件的形式进行存储。在内部，一个文件被分成多个块并且这些块被存储在一组 DataNode 上。")]),a._v(" "),t("p",[a._v("1）NameNode\n文件的元数据采用集中式存储方案存放在 NameNode 当中。NameNode 负责执行文件系统命名空间的操作，如打幵、关闭、重命名文件和目录。NameNode 同时也负责将数据块映射到对应的 DataNode 中。")]),a._v(" "),t("p",[a._v("2） DataNode\nDataNode 是文件系统的工作结点。它们根据需要存储并检索数据块，并且定期向 NameNode 发送他们所存储的块的列表。文件数据块本身存储在不同的 DataNode 当中，DataNode 可以分布在不同机架上。")]),a._v(" "),t("p",[a._v("DataNode 负责服务文件系统客户端发出的读/写请求。DataNode 同时也负责接收 NameNode 的指令来进行数据块的创建、删除和复制。")]),a._v(" "),t("p",[a._v("3）Client\nHDFS 的 Client 会分别访问 NameNode 和 DataNode 以获取文件的元信息及内容。HDFS 集群的 Client 将直接访问 NameNode 和 DataNode，相关数据会直接从 NameNode 或者 DataNode 传送到客户端。")]),a._v(" "),t("p",[a._v("NameNode 和 DataNode 都是被设计为在普通 PC 上运行的软件程序。HDFS 是用 Java 语言实现的，任何支持 Java 语言的机器都可以运行 NameNode 或者 DataNode。Java 语言本身的可移植性意味着 HDFS 可以被广泛地部署在不同的机器上。")]),a._v(" "),t("p",[a._v("一个典型的部署就是，集群中的一台专用机器运行 NameNode，集群中的其他机器每台运行一个 DataNode 实例。该架构并不排除在同一台机器上运行多个 DataNode 实例的可能，但在实际的部署中很少会这么做。")]),a._v(" "),t("p",[a._v("单一 NameNode 的设计极大地简化了集群的系统架构，它使得所有 HDFS 元数据的仲裁和存储都由单一 NameNode 来决定，避免了数据不一致性的问题。\nHDFS 数据复制\nHDFS 可以跨机架、跨机器，可靠地存储海量文件。HDFS 把每个文件存储为一系列的数据块，除了最后一个数据块以外，一个文件的所有数据块都是相同大小的。")]),a._v(" "),t("p",[a._v("为了容错，一个文件的数据块会被复制。对于每个文件来说，文件块大小和复制因子都是可配置的。应用程序可以声明一个文件的副本数。复制因子可以在文件创建时声明，并且可以在以后修改。")])])}),[],!1,null,null,null);e.default=o.exports}}]);