(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{552:function(a,t,s){"use strict";s.r(t);var n=s(6),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"条例14-考虑实现comparable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条例14-考虑实现comparable"}},[a._v("#")]),a._v(" 条例14： 考虑实现Comparable")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("和本章讨论的其他方法不同，compareTo方法不是在Object中声明的，然而它是Comparable接口中的唯一方法。它和本章中的 Object的equals方法类似，除了它不仅允许简单的比较还运行顺序比较，并且它是泛型的。通过实现Comparable，类表明他的 实例拥有自然顺序。排序实现了Comparable接口的对象数组，如下般简单：\n\nArrays.sort(a);\n同样，搜素，计算极值和维护自动排序的Comparable对象的集合也很简单。比如，如下程序，依赖字符串实现Comparable的事实， 打印出排除重复后的按字母顺序的命令行参数列表。\n\n```java\npublic class WordList {\n  public static void main(String[] args) {\n    Set < String > s = new TreeSet < >();\n    Collections.addAll(s, args);\n    System.out.println(s);\n  }\n}\n")])])]),s("p",[a._v("通过实现Comparable，类就可以和许多通用算法和依赖于这个接口的集合实现进行交互。通过小部分努力就获得了极大的能力。 事实上Java类库的所有值类，包括所有枚举类型，都实现了Comparable。如果自己编写一个具有明显自然排序的值类，比如 字母顺序，或者时间顺序，那么应该实现Comparable接口。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),a._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("compareTo方法的通用契约类似于equals方法： 比较此对象和指定对象的顺序。当此对象比指定对象小，相等或大时对应返回负整数，0，或正整数。如果指定类型的对象不能和这个 对象进行比较时，扔出ClassCastException。")]),a._v(" "),s("p",[a._v("在下面的描述中，符号sgn(表达式)表示数学的正负号函数，根据表达式的值是负数，0或正分别定义为返回-1，0，或1。")]),a._v(" "),s("p",[a._v("实现方必须确保对于所有的x和y，sgn(x.compareTo(y)) == -sgn(y.compareTo(x))（这暗示了x.compareTo(y)必须当且仅当y.compareTo(x)扔出异常时 才扔出异常。")]),a._v(" "),s("p",[a._v("实现着必须确保关系的传递性：（x.compareTo(y) > 0 && y.compareTo(z) > 0）意味着x.compareTo(z) > 0。")]),a._v(" "),s("p",[a._v("最后，实现这必须确保x.compareTo(y) == 0 意味着对于所有z，sgn(x.compareTo(z) == sgn(y.compareTo(z)))。")]),a._v(" "),s("p",[a._v("不是必须，但强烈推荐，（x.compareTo(y) == 0） == (x.equals(y))。通常来说，任何实现了Comparable接口的类若违背这个条件则应该 清楚地表明这个事实。推荐的文案是“注意：当前类的自然排序和equals不一致”。")]),a._v(" "),s("p",[a._v("不要被这个契约的数学性质吓倒。像equals契约（条例10）一样，这个契约不像它看上去的那么复杂。和equals方法不同，equals方法将全局等价关系强加 到所有对象上，但compareTo不需要跨不同类型对象比较：当遇到不同类型的对象时，compareTo可以扔出ClassCastException。通常，这正是它的作用。 契约允许类型间比较，通常定义在由比较的对象实现的接口里。")]),a._v(" "),s("p",[a._v("正如违反hashCode契约的类可能破坏其他依赖哈希的类，违反compareTo契约的类也会破坏其他依赖比较的类。依赖比较的类包括排序集合TreeSet和 TreeMap和工具类Collections和Arrays，它们包含了搜索和排序算法。 让我们看看compareTo契约的规定。第一个规定说如果反转两个引用对象之间的比较，预期会发生：如果第一个对象小于第二个，那么第二个必须比第一个大； 如果第一个对象和第二个想等，那么第二个必须和第一个相等。如果第一个比第二大，那么第二个必须必第一个小。第二条规定说，如果一个对象比第二个大， 第二个比第三个大，那么第一个必须必第三个大。最后一个规定说，所有比较相等的对象当和其他任何对象比较时，必须产生相同的结果。")]),a._v(" "),s("p",[a._v("这三个规定的一个结果是compareTo方法施加的相等性检查必须遵守equals契约施加的相同限制：自反，对称和传递性。所以警告同样适用：没有办法在继承可 实例化的类在增加新的值组件的情况下还保持compareTo契约，除非你愿意放弃面向对象抽象的好处（条例10）。相同的变通方法也适用。如果要添加值组件到 实现了Comparable接口的类中，不要继承它；写一个无关类包含第一个类的实例。然后提供一个视图方法以返回包含的实例。之后可以在包含compareTo方法的 类中自由实现任何你想要的，同时还支持客户端在需要时将包含类的实例作为被包含类的实例来查看。")]),a._v(" "),s("p",[a._v("compareTo契约的最后一段，是一个强烈建议而不是硬性要求，简单陈述了compareTo施加的相等性检测通常应该和equals方法返回相同的结果，如果遵守这个规定， compareTo方法施加的顺序被认为和equals保持一致。如果违反了，那么顺序和equals不一致。compareTo方法施加的顺序和equals不一致的类仍将工作，但是 包含类元素的已排序集合可能不遵守合适集合接口（Collection，Set或Mao）的通用契约。这是因为这些接口的通用契约是根据equals方法定义的，但是排序 集合使用compareTo代替equals方法施加相等性检查。如果发生这种事，也不是灾难，但是需要意识到。")]),a._v(" "),s("p",[a._v('比如，BigDecimal类的compareTo方法和equals不一致。如果创建一个空HashSet实例，加入new BigDecimal("1.0")和new BigDecimal("1.00")， 集合将包含两个元素，因为添加的两个BigDecimal实例当使用equals方法比较时不相等。然而，如果你使用TreeSet而不是HashSet来执行相同的过程，那么 TreeSet将只包含一个元素，因为当使用compareTo方法比较时，两个BigDecimal实例是相等的。（查看BigDecimal文档了解更多细节）。')]),a._v(" "),s("p",[a._v("写一个compareTo方法类似于写一个equals方法，但是有一些关键的不同。因为Comparable接口是参数化的，compareTo方法时静态类型的，所以不要类型检查 或转换参数。如果参数类型错误，调用不会编译通过。如果参数是null，调用应该扔出NullPointerException。一旦方法尝试访问它的成员则会立刻出现异常。")]),a._v(" "),s("p",[a._v("在compareTo方法中，字段是按顺序而不是按相等性比较的。要比较对象引用字段，递归调用compareTo方法。如果字段没有实现Comparable或者需要非标准排序， 使用Comparator替代。可以编写自己的comparator或使用已存在的。如条例10中CaseInsensitiveString的compareTo方法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Single-field Comparable with object reference field")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("CaseInsensitiveString")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("CaseInsensitiveString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("CaseInsensitiveString")]),a._v(" cis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("CASE_INSENSITIVE_ORDER"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" cis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 其他省略")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("注意CaseInsensitiveString实现Comparable。这意味着CaseInsensitiveString引用只可以和另一个CaseInsensitiveString引用 想比。这是声明实现Comparable的类时遵循的常规模模式。")]),a._v(" "),s("p",[a._v("这本书早先版本推荐compareTo方法中使用关系运算符<和>来比较原始整型字段，使用静态的Double.compare和Float.compare来比较原始浮点型字段。 在Java 7中，静态compare方法加入到Java所有的装箱原始类中。在compareTo方法中使用关系运算符是冗长和易错的，不再推荐了。")]),a._v(" "),s("p",[a._v("如果类具有多个有效字段，比较他们的顺序是关键的。以最重要的字段开始，然后逐步进行下去。如果比较产生的是任何不是0（代表相等）的结果， 就完成比较，直接返回结果。如果最重要字段是相等的，比较下一个最重要字段，等等。直到返现不等的字段或比较了最后的重要字段。条例11的 PhoneNumber类的compareTo方法演示了这个技术：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 具有原始类型字段的多字段比较")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhoneNumber")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Short")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("areaCode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("areaCode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("result "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    result "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Short")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("prefix"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prefix"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("result "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n    result "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Short")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("lineNum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lineNum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("Java8中，Comparator接口配备了一系列comparator构造方法，提供了comparators的流式构造。这些comparators可以用来实现Comparable接口要求的compareTo方法。 许多程序员喜欢这种方式的简洁性，尽管它的性能成本不高：PhoneNumber实例的排序数组在我的机器上大约慢10%。当使用这种方式，考虑使用Java的静态导入工具 所以你可以通过他们简单名字引用静态comparator构造方法保持清晰和简洁。")]),a._v(" "),s("p",[a._v("下面是PhoneNumber中compareTo方法使用这种方式的样子：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 带有comparator构造函数的Comparable方法")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhoneNumber")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" COMPARATOR "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n     "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("comparingInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhoneNumber")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("areaCode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("thenComparingInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("pn "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prefix"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("thenComparingInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("pn "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lineNum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compareTo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhoneNumber")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" COMPARATOR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),s("p",[a._v("这个实现在类初始化期间构建一个comparator，使用两个comparator构造方法。第一个是comparingInt，它是一个静态方法接收键提取函数，这个函数将对象引用 映射成int类型的键并返回一个comparator，这个comparator根据键来对实例进行排序。在前面的例子中，comparingInt接收lambda()，将区号从PhoneNumber实例 提取出来并返回Comparator，其根据他们的区号对电话号码排序。注意lambda显示制定了输入参数的类型（PhoneNumber pn)。结果是在这种场景下， Java的类型接口不够强大到弄清类型，所以我们必须帮助它已让程序编译。")]),a._v(" "),s("p",[a._v("如果两个电话号码具有相同的区号，我们需要进一步完善比较，这正是第二个comparator构造函数方法做的事，thenComparingInt。它是Comparator上 的一个实例方法，接收int型的键提取函数，并且返回一个comparator，这个comparator首先应用初始的comparator然后使用提取的键来打破联系。你可以 把尽可能多的thenComparingInt的调用任意堆叠起来，形成一个词典顺序。在上面的例子中，我们堆叠了thenComparingInt的两个调用，形成第二键是prefix 第三个键是线号的顺序。注意，我们不必指定传给任何一个thenComparingInt调用的键提取函数的参数类型。Java的类型接口足以聪明自己识别出来。")]),a._v(" "),s("p",[a._v("Comparator类有一个完整的构造方法。他们类似于comparingInt和thenComparingInt，用于原始类型long和double。int版本可以用来更小的整型，如short， 比如在我们的PhoneNumber例子里。double版本也可以用于float。这覆盖了Java所有的数值原始类型。")]),a._v(" "),s("p",[a._v("也有用于对象引用类型的comparator构造方法。静态方法，comparing，有两个重载。其中一个接收键提取且使用键的自然顺序。第二个接收键提起器和用在 提取出的键上的comparator，其实例方法有三个thenComparing重载。一个重载只接收一个comparator且使用它提供第二顺序。第二个重载只接收一个键提取器， 且使用键的自然顺序作为第二顺序，最后一个重载接收键提取器和用在提取出的键的comparator上。")]),a._v(" "),s("p",[a._v("偶尔你会看到compareTo或compare方法依赖这么个事实，如果第一个值小于第二个，两个值的差异为负数，如果两个值相等，差异为0，如果第一个值更大，差异为正。 下面是例子")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 裂开 基于差异的comparator - 违反传递性。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" hashCodeOrder "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("不要使用这种技术。它具有来自于整数溢出和IEEE 754浮点运算产物的危险。[JLS 15.20.1 15.21.1] 甚至，导致的方法不可能显著地比本例中描述的技术快。 使用一个静态的compare方法或comparator构造方法")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 基于静态比较方法的Comparator ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" hashCodeOrder "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//基于Comparator构造方法的Comparator")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" hashCodeOrder "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("comparingInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("o "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("\n总结下，不管何时当实现具有合理顺序的值类，应该让类实现"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparable")]),a._v("接口这样它的实例可以被轻松地排序，查找，且用在基于比较的集合中。在compareTo 方法的实现中当比较字段值时，避免使用"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("和"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("操作符。作为替代在装箱原始类中使用静态compare方法或者在"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Comparator")]),a._v("接口中使用comparator构造方法。\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);