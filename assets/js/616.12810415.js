(window.webpackJsonp=window.webpackJsonp||[]).push([[616],{1108:function(n,t,o){"use strict";o.r(t);var e=o(6),a=Object(e.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring使用aspectj开发aop-基于xml和基于annotation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring使用aspectj开发aop-基于xml和基于annotation"}},[this._v("#")]),this._v(" Spring使用AspectJ开发AOP：基于XML和基于Annotation")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('AspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言。Spring 2.0 以后，新增了对 AspectJ 方式的支持，新版本的 Spring 框架，建议使用 AspectJ 方式开发 AOP。\n\n使用 AspectJ 开发 AOP 通常有两种方式：\n基于 XML 的声明式。\n基于 Annotation 的声明式。\n\n接下来将对这两种 AOP 的开发方式进行讲解。\n基于XML的声明式\n基于 XML 的声明式是指通过 Spring 配置文件的方式定义切面、切入点及声明通知，而所有的切面和通知都必须定义在 <aop:config> 元素中。\n\n下面通过案例演示 Spring 中如何使用基于 XML 的声明式实现 AOP 的开发。\n1. 导入 JAR 包\n使用 AspectJ 除了需要导入 Spring AOP 的 JAR 包以外，还需要导入与 AspectJ 相关的 JAR 包，具体如下。\nspring-aspects-3.2.13.RELEASE.jar：Spring 为 AspectJ 提供的实现，在 Spring 的包中已经提供。\ncom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar：是 AspectJ 提供的规范，可以在官方网址 https://repo.spring.io/webapp/#/search/quick/ 中搜索并下载。\n2. 创建切面类 MyAspect\n在 src 目录下创建一个名为 com.mengma.aspectj.xml 的包，在该包下创建切面类 MyAspect，编辑后如下所示。\npackage com.mengma.aspectj.xml;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\n//切面类\npublic class MyAspect {\n    // 前置通知\n    public void myBefore(JoinPoint joinPoint) {\n        System.out.print("前置通知，目标：");\n        System.out.print(joinPoint.getTarget() + "方法名称:");\n        System.out.println(joinPoint.getSignature().getName());\n    }\n    // 后置通知\n    public void myAfterReturning(JoinPoint joinPoint) {\n        System.out.print("后置通知，方法名称：" + joinPoint.getSignature().getName());\n    }\n    // 环绕通知\n    public Object myAround(ProceedingJoinPoint proceedingJoinPoint)\n            throws Throwable {\n        System.out.println("环绕开始"); // 开始\n        Object obj = proceedingJoinPoint.proceed(); // 执行当前目标方法\n        System.out.println("环绕结束"); // 结束\n        return obj;\n    }\n    // 异常通知\n    public void myAfterThrowing(JoinPoint joinPoint, Throwable e) {\n        System.out.println("异常通知" + "出错了" + e.getMessage());\n    }\n    // 最终通知\n    public void myAfter() {\n        System.out.println("最终通知");\n    }\n}\n上述代码中，分别定义了几种不同的通知类型方法，在这些方法中，通过 JoinPoint 参数可以获得目标对象的类名、目标方法名和目标方法参数等。需要注意的是，环绕通知必须接收一个类型为 ProceedingJoinPoint 的参数，返回值必须是 Object 类型，且必须抛出异常。异常通知中可以传入 Throwable 类型的参数，用于输出异常信息。\n3. 创建 Spring 配置文件\n在 com.mengma.aspectj.xml 包下创建 applicationContext.xml 的配置文件，如下所示。\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"\n    xsi:schemaLocation="  \n            http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  \n            http://www.springframework.org/schema/aop\n            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">\n    \x3c!--目标类 --\x3e\n    <bean id="customerDao" class="com.mengma.dao.CustomerDaoImpl" />\n    \x3c!--切面类 --\x3e\n    <bean id="myAspect" class="com.mengma.aspectj.xml.MyAspect"></bean>\n    \x3c!--AOP 编程 --\x3e\n    <aop:config>\n        <aop:aspect ref="myAspect">\n            \x3c!-- 配置切入点，通知最后增强哪些方法 --\x3e\n            <aop:pointcut expression="execution ( * com.mengma.dao.*.* (..))"\n                id="myPointCut" />\n            \x3c!--前置通知，关联通知 Advice和切入点PointCut --\x3e\n            <aop:before method="myBefore" pointeut-ref="myPointCut" />\n            \x3c!--后置通知，在方法返回之后执行，就可以获得返回值returning 属性 --\x3e\n            <aop:after-returning method="myAfterReturning"\n                pointcut-ref="myPointCut" returning="returnVal" />\n            \x3c!--环绕通知 --\x3e\n            <aop:around method="myAround" pointcut-ref="myPointCut" />\n            \x3c!--抛出通知：用于处理程序发生异常，可以接收当前方法产生的异常 --\x3e\n            \x3c!-- *注意：如果程序没有异常，则不会执行增强 --\x3e\n            \x3c!-- * throwing属性：用于设置通知第二个参数的名称，类型Throwable --\x3e\n            <aop:after-throwing method="myAfterThrowing"\n                pointcut-ref="myPointCut" throwing="e" />\n            \x3c!--最终通知：无论程序发生任何事情，都将执行 --\x3e\n            <aop:after method="myAfter" pointcut-ref="myPointCut" />\n        </aop:aspect>\n    </aop:config>\n</beans>\n上述代码中，首先在第 4、7、8 行代码中分别导入了 AOP 的命名空间。第 12 行代码指定了切面类。\n\n第 17、18 行代码配置了切入点，通知需要增强哪些方法，expression="execution（*com.mengma.dao.*.*（..））的意思是增强 com.mengma.dao 包下所有的方法。\n\n第 20～32 行代码用于关联通知（Advice）和切入点（PointCut）。以第 20 行代码前置通知为例，<aop:before> 标签的 method 属性用于指定通知，pointcut-ref 属性用于指定切入点，也就是要增强的方法，其他几种通知的配置可以参考代码注释。\n4. 创建测试类\n在 com.mengma.aspectj.xml 包下创建测试类 XMLTest，如下所示。\npackage com.mengma.aspectj.xml;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.mengma.dao.CustomerDao;\npublic class XMLTest {\n    @Test\n    public void test() {\n        String xmlPath = "com/mengma/aspectj/xml/applicationContext.xml";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n                xmlPath);\n        // 从spring容器获取实例\n        CustomerDao customerDao = (CustomerDao) applicationContext\n                .getBean("customerDao");\n        // 执行方法\n        customerDao.add();\n    }\n}\n5. 运行项目并查看结果\n使用 JUnit 测试运行 test() 方法，运行成功后，控制台的输出结果如图 1 所示。\n\n运行结果\n图 1  运行结果\n\n为了更好地演示异常通知，接下来在 CustomerDaoImpl 类的 add() 方法中添加一行会抛出异常的代码，如“int i=1/0；”，重新运行 XMLTest 测试类，可以看到异常通知执行了，此时控制台的输出结果如图 2 所示。\n\n运行结果\n图 2  运行结果\n\n从图 1 和图 2 的输出结果中可以看出，基于 XML 声明式的 AOP 开发已经成功实现。\n基于 Annotation 的声明式\n在 Spring 中，尽管使用 XML 配置文件可以实现 AOP 开发，但是如果所有的相关的配置都集中在配置文件中，势必会导致 XML 配置文件过于臃肿，从而给维护和升级带来一定的困难。\n\n为此，AspectJ 框架为 AOP 开发提供了另一种开发方式——基于 Annotation 的声明式。AspectJ 允许使用注解定义切面、切入点和增强处理，而 Spring 框架则可以识别并根据这些注解生成 AOP 代理。\n\n关于 Annotation 注解的介绍如表 1 所示。\n表 1 Annotation 注解介绍\n名称\t说明\n@Aspect\t用于定义一个切面。\n@Before\t用于定义前置通知，相当于 BeforeAdvice。\n@AfterReturning\t用于定义后置通知，相当于 AfterReturningAdvice。\n@Around\t用于定义环绕通知，相当于MethodInterceptor。\n@AfterThrowing\t用于定义抛出通知，相当于ThrowAdvice。\n@After\t用于定义最终final通知，不管是否异常，该通知都会执行。\n@DeclareParents\t用于定义引介通知，相当于IntroductionInterceptor（不要求掌握）。\n下面使用注解的方式重新实现《基于XML的声明式》部分的功能。\n1. 创建切面类 MyAspect\n在 src 目录下创建一个名为 com.mengma.aspectj.annotation 的包，在该包下创建一个切面类 MyAspect，如下所示。\npackage com.mengma.aspectj.annotation;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.AfterThrowing;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n//切面类\n@Aspect\n@Component\npublic class MyAspect {\n    // 用于取代：<aop:pointcut\n    // expression="execution(*com.mengma.dao..*.*(..))" id="myPointCut"/>\n    // 要求：方法必须是private，没有值，名称自定义，没有参数\n    @Pointcut("execution(*com.mengma.dao..*.*(..))")\n    private void myPointCut() {\n    }\n    // 前置通知\n    @Before("myPointCut()")\n    public void myBefore(JoinPoint joinPoint) {\n        System.out.print("前置通知，目标：");\n        System.out.print(joinPoint.getTarget() + "方法名称:");\n        System.out.println(joinPoint.getSignature().getName());\n    }\n    // 后置通知\n    @AfterReturning(value = "myPointCut()")\n    public void myAfterReturning(JoinPoint joinPoint) {\n        System.out.print("后置通知，方法名称：" + joinPoint.getSignature().getName());\n    }\n    // 环绕通知\n    @Around("myPointCut()")\n    public Object myAround(ProceedingJoinPoint proceedingJoinPoint)\n            throws Throwable {\n        System.out.println("环绕开始"); // 开始\n        Object obj = proceedingJoinPoint.proceed(); // 执行当前目标方法\n        System.out.println("环绕结束"); // 结束\n        return obj;\n    }\n    // 异常通知\n    @AfterThrowing(value = "myPointCut()", throwing = "e")\n    public void myAfterThrowing(JoinPoint joinPoint, Throwable e) {\n        System.out.println("异常通知" + "出错了" + e.getMessage());\n    }\n    // 最终通知\n    @After("myPointCut()")\n    public void myAfter() {\n        System.out.println("最终通知");\n    }\n}\n上述代码中，第 13 行 @Aspect 注解用于声明这是一个切面类，该类作为组件使用，所以要添加 @Component 注解才能生效。第 19 行中 @Poincut 注解用于配置切入点，取代 XML 文件中配置切入点的代码。\n\n在每个通知相应的方法上都添加了注解声明，并且将切入点方法名“myPointCut”作为参数传递给要执行的方法，如需其他参数（如异常通知的异常参数），可以根据代码提示传递相应的属性值。\n2. 为目标类添加注解\n在 com.mengma.dao.CustomerDaoImpl 目标类中添加注解 @Repository（"customerDao"）。\n3. 创建Spring配置文件\n在 com.mengma.aspectj.annotation 包下创建 applicationContext.xml 配置文件，如下所示。\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n            http://www.springframework.org/schema/aop\n            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd">\n    \x3c!--扫描含com.mengma包下的所有注解--\x3e\n    <context:component-scan base-package="com.mengma"/>\n    \x3c!-- 使切面开启自动代理 --\x3e\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n</beans>\n上述代码中，首先导入了 AOP 命名空间及其配套的约束，使切面类中的 @AspectJ 注解能够正常工作；第 13 行代码添加了扫描包，使注解生效。需要注意的是，这里还包括目标类 com.mengma.dao.CustomerDaoImpl 的注解，所以 base-package 的值为 com.mengma；第 15 行代码的作用是切面开启自动代理。\n4. 创建测试类\n在 com.mengma.aspectj.annotation 包下创建一个名为 AnnotationTest 的测试类，如下所示。\n纯文本复制\npackage com.mengma.aspectj.annotation;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.mengma.dao.CustomerDao;\npublic class AnnotationTest {\n    @Test\n    public void test() {\n        String xmlPath = "com/mengma/aspectj/xml/applicationContext.xml";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n                xmlPath);\n        // 从spring容器获取实例\n        CustomerDao customerDao = (CustomerDao) applicationContext\n                .getBean("customerDao");\n        // 执行方法\n        customerDao.add();\n    }\n}\n5. 运行项目并查看结果\n使用 JUnit 测试运行 test() 方法，运行成功\n\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);