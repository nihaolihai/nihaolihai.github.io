(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{667:function(n,t,e){"use strict";e.r(t);var r=e(6),a=Object(r.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"java-线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-线程"}},[this._v("#")]),this._v(" java 线程")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v(' - 查看线程是否存活\nJava 实例 Java 实例\n\n以下实例演示了如何通过继承 Thread 类并使用 isAlive() 方法来检测一个线程是否存活：\n\nTwoThreadAlive.java 文件\npublic class TwoThreadAlive extends Thread {\n   public void run() {\n      for (int i = 0; i < 10; i++) {\n         printMsg();\n      }\n   }\n \n   public void printMsg() {\n      Thread t = Thread.currentThread();\n      String name = t.getName();\n      System.out.println("name=" + name);\n   }\n \n   public static void main(String[] args) {\n      TwoThreadAlive tt = new TwoThreadAlive();\n      tt.setName("Thread");\n      System.out.println("before start(), tt.isAlive()=" + tt.isAlive());\n      tt.start();\n      System.out.println("just after start(), tt.isAlive()=" + tt.isAlive());\n      for (int i = 0; i < 10; i++) {\n         tt.printMsg();\n      }\n      System.out.println("The end of main(), tt.isAlive()=" + tt.isAlive());\n   }\n}\n\n- 获取当前线程名称\nJava 实例 Java 实例\n\n以下实例演示了如何通过继承 Thread 类并使用 getName() 方法来获取当前线程名称：\n\nTwoThreadGetName.java 文件\npublic class TwoThreadGetName extends Thread {\n   public void run() {\n      for (int i = 0; i < 10; i++) {\n         printMsg();\n      }\n   }\n   public void printMsg() {\n      Thread t = Thread.currentThread();\n      String name = t.getName();\n      System.out.println("name=" + name);\n   } \n   public static void main(String[] args) {\n      TwoThreadGetName tt = new TwoThreadGetName();\n      tt.start();\n      for (int i = 0; i < 10; i++) {\n         tt.printMsg();\n      }\n   }\n}\n\n- 状态监测\nJava 实例 Java 实例\n\n以下实例演示了如何通过继承 Thread 类并使用 currentThread.getName() 方法来监测线程的状态：\n\nMain.java 文件\nclass MyThread extends Thread{\n   boolean waiting= true;\n   boolean ready= false;\n   MyThread() {\n   }\n   public void run() {\n      String thrdName = Thread.currentThread().getName();\n      System.out.println(thrdName + " starting.");\n      while(waiting) \n      System.out.println("waiting:"+waiting); \n      System.out.println("waiting...");\n      startWait(); \n      try {\n         Thread.sleep(1000);\n      }\n      catch(Exception exc) {\n         System.out.println(thrdName + " interrupted.");\n      }\n      System.out.println(thrdName + " terminating.");\n   }\n   synchronized void startWait() {\n      try {\n         while(!ready) wait();\n      }\n      catch(InterruptedException exc) {\n         System.out.println("wait() interrupted");\n      }\n   }\n   synchronized void notice() {\n      ready = true;\n      notify();\n   }\n}\npublic class Main {\n   public static void main(String args[]) \n   throws Exception{\n      MyThread thrd = new MyThread();\n      thrd.setName("MyThread #1");\n      showThreadStatus(thrd);\n      thrd.start();\n      Thread.sleep(50);\n      showThreadStatus(thrd);\n      thrd.waiting = false;\n      Thread.sleep(50); \n      showThreadStatus(thrd);\n      thrd.notice();\n      Thread.sleep(50);\n      showThreadStatus(thrd);\n      while(thrd.isAlive()) \n      System.out.println("alive");\n      showThreadStatus(thrd);\n   }\n   static void showThreadStatus(Thread thrd) {\n      System.out.println(thrd.getName() + "Alive:=" + thrd.isAlive() + " State:=" + thrd.getState());\n   }\n}\n\n- 线程优先级设置\nJava 实例 Java 实例\n\n以下实例演示了如何通过setPriority() 方法来设置线程的优先级：\n\nSimplePriorities.java 文件\npublic class SimplePriorities extends Thread {\n   private int countDown = 5;\n   private volatile double d = 0; \n   public SimplePriorities(int priority) {\n      setPriority(priority);\n      start();\n   }\n   public String toString() {\n      return super.toString() + ": " + countDown;\n   }\n   public void run() {\n      while(true) {\n         for(int i = 1; i < 100000; i++)\n         d = d + (Math.PI + Math.E) / (double)i;\n         System.out.println(this);\n         if(--countDown == 0) return;\n      }\n   }\n   public static void main(String[] args) {\n      new SimplePriorities(Thread.MAX_PRIORITY);\n      for(int i = 0; i < 5; i++)\n      new SimplePriorities(Thread.MIN_PRIORITY);\n   }\n}\n\n- 死锁及解决方法\nJava 实例 Java 实例\n\n死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\njava 死锁产生的四个必要条件：\n\n1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用\n2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。\n3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。\n4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。\n当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。下面用java代码来模拟一下死锁的产生。\n\n解决死锁问题的方法是：一种是用synchronized，一种是用Lock显式锁实现。\n\n而如果不恰当的使用了锁，且出现同时要锁多个对象时，会出现死锁情况，如下：\n\nLockTest.java 文件\nimport java.util.Date;\n \npublic class LockTest {\n   public static String obj1 = "obj1";\n   public static String obj2 = "obj2";\n   public static void main(String[] args) {\n      LockA la = new LockA();\n      new Thread(la).start();\n      LockB lb = new LockB();\n      new Thread(lb).start();\n   }\n}\nclass LockA implements Runnable{\n   public void run() {\n      try {\n         System.out.println(new Date().toString() + " LockA 开始执行");\n         while(true){\n            synchronized (LockTest.obj1) {\n               System.out.println(new Date().toString() + " LockA 锁住 obj1");\n               Thread.sleep(3000); // 此处等待是给B能锁住机会\n               synchronized (LockTest.obj2) {\n                  System.out.println(new Date().toString() + " LockA 锁住 obj2");\n                  Thread.sleep(60 * 1000); // 为测试，占用了就不放\n               }\n            }\n         }\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n   }\n}\nclass LockB implements Runnable{\n   public void run() {\n      try {\n         System.out.println(new Date().toString() + " LockB 开始执行");\n         while(true){\n            synchronized (LockTest.obj2) {\n               System.out.println(new Date().toString() + " LockB 锁住 obj2");\n               Thread.sleep(3000); // 此处等待是给A能锁住机会\n               synchronized (LockTest.obj1) {\n                  System.out.println(new Date().toString() + " LockB 锁住 obj1");\n                  Thread.sleep(60 * 1000); // 为测试，占用了就不放\n               }\n            }\n         }\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n   }\n}\n\n- 获取线程id\nJava 实例 Java 实例\n\n以下实例演示了如何使用 getThreadId() 方法获取线程id：\n\nMain.java 文件\npublic class Main extends Object implements Runnable {\n  private ThreadID var;\n \n  public Main(ThreadID v) {\n    this.var = v;\n  }\n \n  public void run() {\n    try {\n      print("var getThreadID =" + var.getThreadID());\n      Thread.sleep(2000);\n      print("var getThreadID =" + var.getThreadID());\n    } catch (InterruptedException x) {\n    }\n  }\n \n  private static void print(String msg) {\n    String name = Thread.currentThread().getName();\n    System.out.println(name + ": " + msg);\n  }\n \n  public static void main(String[] args) {\n    ThreadID tid = new ThreadID();\n    Main shared = new Main(tid);\n \n    try {\n      Thread threadA = new Thread(shared, "threadA");\n      threadA.start();\n \n      Thread.sleep(500);\n \n      Thread threadB = new Thread(shared, "threadB");\n      threadB.start();\n \n      Thread.sleep(500);\n \n      Thread threadC = new Thread(shared, "threadC");\n      threadC.start();\n    } catch (InterruptedException x) {\n    }\n  }\n}\n \nclass ThreadID extends ThreadLocal {\n  private int nextID;\n \n  public ThreadID() {\n    nextID = 10001;\n  }\n \n  private synchronized Integer getNewID() {\n    Integer id = new Integer(nextID);\n    nextID++;\n    return id;\n  }\n \n \n  protected Object initialValue() {\n    print("in initialValue()");\n    return getNewID();\n  }\n \n  public int getThreadID() {\n    Integer id = (Integer) get();\n    return id.intValue();\n  }\n \n  private static void print(String msg) {\n    String name = Thread.currentThread().getName();\n    System.out.println(name + ": " + msg);\n  }\n}\n\n- 线程挂起\nJava 实例 Java 实例\n\n以下实例演示了如何将线程挂起：\n\nSleepingThread.java 文件\npublic class SleepingThread extends Thread {\n   private int countDown = 5;\n   private static int threadCount = 0;\n   public SleepingThread() {\n      super("" + ++threadCount);\n      start();\n   }\n   public String toString() { \n      return "#" + getName() + ": " + countDown;\n   }\n   public void run() {\n      while (true) {\n         System.out.println(this);\n         if (--countDown == 0)\n            return;\n         try {\n            sleep(100);\n         }\n         catch (InterruptedException e) {\n            throw new RuntimeException(e);\n         }\n      }\n   }\n   public static void main(String[] args) \n   throws InterruptedException {\n      for (int i = 0; i < 5; i++)\n      new SleepingThread().join();\n      System.out.println("线程已被挂起");\n   }\n}\n\n- 终止线程\nJava 实例 Java 实例\n\nJava中原来在Thread中提供了stop()方法来终止线程，但这个方法是不安全的，所以一般不建议使用。\n\n本文向大家介绍使用interrupt方法中断线程。\n\n使用interrupt方法来终端线程可分为两种情况：\n\n（1）线程处于阻塞状态，如使用了sleep方法。\n（2）使用while（！isInterrupted（））{……}来判断线程是否被中断。\n在第一种情况下使用interrupt方法，sleep方法将抛出一个InterruptedException例外，而在第二种情况下线程将直接退出。下面的代码演示了在第一种情况下使用interrupt方法。\n\nThreadInterrupt.java 文件\npublic class ThreadInterrupt extends Thread \n{ \n    public void run() \n    { \n        try \n        { \n            sleep(50000);  // 延迟50秒 \n        } \n        catch (InterruptedException e) \n        { \n            System.out.println(e.getMessage()); \n        } \n    } \n    public static void main(String[] args) throws Exception \n    { \n        Thread thread = new ThreadInterrupt(); \n        thread.start(); \n        System.out.println("在50秒之内按任意键中断线程!"); \n        System.in.read(); \n        thread.interrupt(); \n        thread.join(); \n        System.out.println("线程已经退出!"); \n    } \n}\n\n- 生产者/消费者问题\nJava 实例 Java 实例\n\n生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，如下图所示，生产者向空间里存放数据，而消费者取用数据，如果不加以协调可能会出现以下情况：\n\n存储空间已满，而生产者占用着它，消费者等着生产者让出空间从而去除产品，生产者等着消费者消费产品，从而向空间中添加产品。互相等待，从而发生死锁。\n\nJava 实例 - 生产者/消费者问题\n\n以下实例演示了如何通过线程解决生产者/消费者问题：\n\n实例\n/*\n author by runoob.com\n ProducerConsumerTest.java\n */\n\npublic class ProducerConsumerTest {\n   public static void main(String[] args) {\n      CubbyHole c = new CubbyHole();\n      Producer p1 = new Producer(c, 1);\n      Consumer c1 = new Consumer(c, 1);\n      p1.start();\n      c1.start();\n   }\n}\nclass CubbyHole {\n   private int contents;\n   private boolean available = false;\n   public synchronized int get() {\n      while (available == false) {\n         try {\n            wait();\n         }\n         catch (InterruptedException e) {\n         }\n      }\n      available = false;\n      notifyAll();\n      return contents;\n   }\n   public synchronized void put(int value) {\n      while (available == true) {\n         try {\n            wait();\n         }\n         catch (InterruptedException e) {\n         }\n      }\n      contents = value;\n      available = true;\n      notifyAll();\n   }\n}\n\nclass Consumer extends Thread {\n   private CubbyHole cubbyhole;\n   private int number;\n   public Consumer(CubbyHole c, int number) {\n      cubbyhole = c;\n      this.number = number;\n   }\n   public void run() {\n      int value = 0;\n         for (int i = 0; i < 10; i++) {\n            value = cubbyhole.get();\n            System.out.println("消费者 #" + this.number+ " got: " + value);\n         }\n    }\n}\n\nclass Producer extends Thread {\n   private CubbyHole cubbyhole;\n   private int number;\n\n   public Producer(CubbyHole c, int number) {\n      cubbyhole = c;\n      this.number = number;\n   }\n\n   public void run() {\n      for (int i = 0; i < 10; i++) {\n         cubbyhole.put(i);\n         System.out.println("生产者 #" + this.number + " put: " + i);\n         try {\n            sleep((int)(Math.random() * 100));\n         } catch (InterruptedException e) { }\n      }\n   }\n}\n\n- 获取线程状态\nJava 实例 Java 实例\n\nJava 线程的生命周期中，在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n\nNew\nRunnable\nBlocked\nWaiting\nTimed Waiting\nTerminated\n\n各个状态说明：\n\n1. 初始状态 - NEW\n声明：\n\npublic static final Thread.State NEW\n实现 Runnable 接口和继承 Thread 可以得到一个线程类，new 一个实例出来，线程就进入了初始状态。\n\n2. RUNNABLE\n声明：\n\npublic static final Thread.State RUNNABLE\n2.1. 就绪状态\n\n就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。\n\n调用线程的 start() 方法，此线程进入就绪状态。\n\n当前线程 sleep() 方法结束，其他线程 join() 结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。\n\n当前线程时间片用完了，调用当前线程的 yield() 方法，当前线程进入就绪状态。\n\n锁池里的线程拿到对象锁后，进入就绪状态。\n\n2.2. 运行中状态\n\n线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。\n\n3. 阻塞状态 - BLOCKED\n声明：\n\npublic static final Thread.State BLOCKED\n阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。\n\n4. 等待 - WAITING\n声明：\n\npublic static final Thread.State WAITING\n处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n\n5. 超时等待 - TIMED_WAITING\n\n声明：\n\npublic static final Thread.State TIMED_WAITING\n处于这种状态的线程不会被分配 CPU 执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n\n6. 终止状态 - TERMINATED\n声明：\n\npublic static final Thread.State TERMINATED\n当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。\n\n在一个终止的线程上调用 start() 方法，会抛出 java.lang.IllegalThreadStateException 异常。\n\n以下实例演示了如何获取线程的状态：\n\nMain.java 文件\n// Java 程序 - 演示线程状态\nclass thread implements Runnable \n{ \n    public void run() \n    { \n        //  thread2  - 超时等待\n        try\n        { \n            Thread.sleep(1500); \n        }  \n        catch (InterruptedException e)  \n        { \n            e.printStackTrace(); \n        } \n          \n        System.out.println("State of thread1 while it called join() method on thread2 -"+ \n            Test.thread1.getState()); \n        try\n        { \n            Thread.sleep(200); \n        }  \n        catch (InterruptedException e)  \n        { \n            e.printStackTrace(); \n        }      \n    } \n} \n  \npublic class Test implements Runnable \n{ \n    public static Thread thread1; \n    public static Test obj; \n      \n    public static void main(String[] args) \n    { \n        obj = new Test(); \n        thread1 = new Thread(obj); \n          \n        // 创建 thread1，现在是初始状态\n        System.out.println("State of thread1 after creating it - " + thread1.getState()); \n        thread1.start(); \n          \n        // thread1 - 就绪状态\n        System.out.println("State of thread1 after calling .start() method on it - " +  \n            thread1.getState()); \n    } \n      \n    public void run() \n    { \n        thread myThread = new thread(); \n        Thread thread2 = new Thread(myThread); \n          \n        // 创建 thread1，现在是初始状态\n        System.out.println("State of thread2 after creating it - "+ thread2.getState()); \n        thread2.start(); \n          \n        // thread2 - 就绪状态\n        System.out.println("State of thread2 after calling .start() method on it - " +  \n            thread2.getState()); \n          \n        // moving thread1 to timed waiting state \n        try\n        { \n            //moving - 超时等待\n            Thread.sleep(200); \n        }  \n        catch (InterruptedException e)  \n        { \n            e.printStackTrace(); \n        } \n        System.out.println("State of thread2 after calling .sleep() method on it - "+  \n            thread2.getState() ); \n          \n          \n        try \n        { \n            // 等待 thread2 终止\n            thread2.join(); \n        }  \n        catch (InterruptedException e)  \n        { \n            e.printStackTrace(); \n        } \n        System.out.println("State of thread2 when it has finished it\'s execution - " +  \n            thread2.getState()); \n    } \n      \n}\n以上代码运行输出结果为：\n\nState of thread1 after creating it - NEW\nState of thread1 after calling .start() method on it - RUNNABLE\nState of thread2 after creating it - NEW\nState of thread2 after calling .start() method on it - RUNNABLE\nState of thread2 after calling .sleep() method on it - TIMED_WAITING\nState of thread1 while it called join() method on thread2 -WAITING\nState of thread2 when it has finished it\'s execution - TERMINATED\n\n- 获取所有线程\nJava 实例 Java 实例\n\n以下实例演示了如何使用 getName() 方法获取所有正在运行的线程：\n\nMain.java 文件\npublic class Main extends Thread {\n   public static void main(String[] args) {\n      Main t1 = new Main();\n      t1.setName("thread1");\n      t1.start();\n      ThreadGroup currentGroup = \n      Thread.currentThread().getThreadGroup();\n      int noThreads = currentGroup.activeCount();\n      Thread[] lstThreads = new Thread[noThreads];\n      currentGroup.enumerate(lstThreads);\n      for (int i = 0; i < noThreads; i++)\n      System.out.println("线程号：" + i + " = " + lstThreads[i].getName());\n   }\n}\n\n- 查看线程优先级\nJava 实例 Java 实例\n\n以下实例演示了如何使用 getThreadId() 方法获取线程id：\n\nMain.java 文件\npublic class Main extends Object {\n   private static Runnable makeRunnable() {\n      Runnable r = new Runnable() {\n         public void run() {\n            for (int i = 0; i < 5; i++) {\n               Thread t = Thread.currentThread();\n               System.out.println("in run() - priority="\n               + t.getPriority()+ ", name=" + t.getName());\n               try {\n                  Thread.sleep(2000);\n               }\n               catch (InterruptedException x) {\n               }\n            }\n         }\n      };\n      return r;\n   }\n   public static void main(String[] args) {\n      System.out.println("in main() - Thread.currentThread().getPriority()=" + Thread.currentThread().getPriority());\n      System.out.println("in main() - Thread.currentThread().getName()="+ Thread.currentThread().getName());\n      Thread threadA = new Thread(makeRunnable(), "threadA");\n      threadA.start();\n      try {\n         Thread.sleep(3000);\n      }\n      catch (InterruptedException x) {\n      }\n      System.out.println("in main() - threadA.getPriority()="+ threadA.getPriority());\n   }\n}\n\n- 中断线程\nJava 实例 Java 实例\n\n以下实例演示了如何使用interrupt()方法来中断线程并使用 isInterrupted() 方法来判断线程是否已中断：\n\nMain.java 文件\npublic class Main extends Object \nimplements Runnable {\n   public void run() {\n      try {\n         System.out.println("in run() - 将运行 work2() 方法");\n         work2();\n         System.out.println("in run() - 从 work2() 方法回来");\n      }\n      catch (InterruptedException x) {\n         System.out.println("in run() - 中断 work2() 方法");\n         return;\n      }\n      System.out.println("in run() - 休眠后执行");\n      System.out.println("in run() - 正常离开");\n   }\n   public void work2() throws InterruptedException {\n      while (true) {\n         if (Thread.currentThread().isInterrupted()) {\n            System.out.println("C isInterrupted()=" + Thread.currentThread().isInterrupted());\n            Thread.sleep(2000);\n            System.out.println("D isInterrupted()=" + Thread.currentThread().isInterrupted());\n         }\n      }\n   }\n   public void work() throws InterruptedException {\n      while (true) {\n         for (int i = 0; i < 100000; i++) {\n            int j = i * 2;\n         }\n         System.out.println("A isInterrupted()=" + Thread.currentThread().isInterrupted());\n         if (Thread.interrupted()) {\n            System.out.println("B isInterrupted()=" + Thread.currentThread().isInterrupted());\n            throw new InterruptedException();\n         }\n      }\n   }\n   public static void main(String[] args) {\n      Main si = new Main();\n      Thread t = new Thread(si);\n      t.start();\n      try {\n         Thread.sleep(2000);\n      }\n      catch (InterruptedException x) {\n      }\n      System.out.println("in main() - 中断其他线程");\n      t.interrupt();\n      System.out.println("in main() - 离开");\n   }\n}\n\n\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);