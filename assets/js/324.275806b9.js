(window.webpackJsonp=window.webpackJsonp||[]).push([[324],{816:function(e,n,t){"use strict";t.r(n);var a=t(6),r=Object(a.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"spring-cloud-ribbon结合resttemplate实现负载均衡"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-ribbon结合resttemplate实现负载均衡"}},[this._v("#")]),this._v(" Spring Cloud Ribbon结合RestTemplate实现负载均衡")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('在《Spring Cloud Ribbon介绍及使用》教程中我们简单地使用 Ribbon 进行了负载的一个调用，这意味着 Ribbon 是可以单独使用的。\n\n在 Spring Cloud 中使用 Ribbon 会更简单，因为 Spring Cloud 在 Ribbon 的基础上进行了一层封装，将很多配置都集成好了。本节将在 Spring Cloud 项目中使用 Ribbon。\n使用 RestTemplate 与整合 Ribbon\nSpring 提供了一种简单便捷的模板类来进行 API 的调用，那就是 RestTemplate。\n1. 使用 RestTemplate\n在前面介绍 Eureka 时，我们已经使用过 RestTemplate 了，本节会更加详细地跟大家讲解 RestTemplate 的具体使用方法。\n\n首先我们来看看 GET 请求的使用方式：创建一个新的项目 spring-rest-template，配置好 RestTemplate：\n@Configuration\npublic class BeanConfiguration {\n    @Bean\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n新建一个 HouseController，并增加两个接口，一个通过 @RequestParam 来传递参数，返回一个对象信息；另一个通过 @PathVariable 来传递参数，返回一个字符串。请尽量通过两个接口组装不同的形式，具体代码如下所示。\n@GetMapping("/house/data")\npublic HouseInfo getData(@RequestParam("name") String name) {\n    return new HouseInfo(1L, "上海" "虹口" "东体小区");\n}\n@GetMapping("/house/data/{name}")\npublic String getData2(@PathVariable("name") String name) {\n    return name;\n}\n新建一个 HouseClientController 用于测试，使用 RestTemplate 来调用我们刚刚定义的两个接口，代码如下所示。\n@GetMapping("/call/data")\npublic HouseInfo getData(@RequestParam("name") String name) {\n    return restTemplate.getForObject( "http://localhost:8081/house/data?name="+ name, HouseInfo.class);\n}\n@GetMapping("/call/data/{name}")\npublic String getData2(@PathVariable("name") String name) {\n    return restTemplate.getForObject( "http://localhost:8081/house/data/{name}", String.class, name);\n}\n获取数据结果可通过 RestTemplate 的 getForObject 方法（如下代码所示）来实现，此方法有三个重载的实现：\nurl：请求的 API 地址，有两种方式，其中一种是字符串，另一种是 URI 形式。\nresponseType：返回值的类型。\nuriVariables：PathVariable 参数，有两种方式，其中一种是可变参数，另一种是 Map 形式。\npublic <T> T getForObject(String url, Class<T> responseType,\n                          Object... uriVariables);\npublic <T> T getForObject(String url, Class<T> responseType,\n                          Map<String, ?> uriVariables);\npublic <T> T getForObject(URI url, Class<T> responseType);\n\n除了 getForObject，我们还可以使用 getForEntity 来获取数据，代码如下所示。\n@GetMapping("/call/dataEntity")\npublic HouseInfo getData(@RequestParam("name") String name) {\n    ResponseEntity<HouseInfo> responseEntity = restTemplate\n            .getForEntity("http://localhost:8081/house/data?name=" + name, HouseInfo.class);\n    if (responseEntity.getStatusCodeValue() == 200) {\n        return responseEntity.getBody();\n    }\n    return null;\n}\ngetForEntity 中可以获取返回的状态码、请求头等信息，通过 getBody 获取响应的内容。其余的和 getForObject 一样，也是有 3 个重载的实现。\n\n接下来看看怎么使用 POST 方式调用接口。在 HouseController 中增加一个 save 方法用来接收 HouseInfo 数据，代码如下所示。\n@PostMapping("/house/save")\npublic Long addData(@RequestBody HouseInfo houseInfo) {\n    System.out.println(houseInfo.getName());\n    return 1001L;\n}\n接着写调用代码，用 postForObject 来调用，代码如下所示。\n@GetMapping("/call/save")\npublic Long add() {\n    HouseInfo houseInfo = new HouseInfo();\n    houseInfo.setCity("上海");\n    houseInfo.setRegion("虹口");\n    houseInfo.setName("×××");\n    Long id = restTemplate.postForObject("http://localhost:8081/house/save", houseInfo, Long.class);\n    return id;\n}\npostForObject 同样有 3 个重载的实现。除了 postForObject 还可以使用 postForEntity 方法，用法都一样，代码如下所示。\npublic <T> T postForObject(String url, Object request,\n                           Class<T> responseType, Object... uriVariables);\n\npublic <T> T postForObject(String url, Object request,\n                           Class<T> responseType, Map<String, ?> uriVariables);\n\npublic <T> T postForObject(URI url, Object request, Class<T> responseType);\n\n除了 get 和 post 对应的方法之外，RestTemplate 还提供了 put、delete 等操作方法，还有一个比较实用的就是 exchange 方法。exchange 可以执行 get、post、put、delete 这 4 种请求方式。更多地使用方式大家可以自行学习。\n2. 整合 Ribbon\n在 Spring Cloud 项目中集成 Ribbon 只需要在 pom.xml 中加入下面的依赖即可，其实也可以不用配置，因为 Eureka 中已经引用了 Ribbon，代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n\nRestTemplate 负载均衡示例\n前面我们调用接口都是通过具体的接口地址来进行调用，RestTemplate 可以结合 Eureka 来动态发现服务并进行负载均衡的调用。\n\n修改 RestTemplate 的配置，增加能够让 RestTemplate 具备负载均衡能力的注解 @LoadBalanced。代码如下所示。\n@Configuration\npublic class BeanConfiguration {\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n修改接口调用的代码，将 IP+PORT 改成服务名称，也就是注册到 Eureka 中的名称，代码如下所示。\n@GetMapping("/call/data")\npublic HouseInfo getData(@RequestParam("name") String name) {\n    return restTemplate.getForObject("http://ribbon-eureka-demo/house/data?name=" + name, HouseInfo.class);\n}\n\n接口调用的时候，框架内部会将服务名称替换成具体的服务 IP 信息，然后进行调用。\n@LoadBalanced 注解原理\n相信大家一定有一个疑问：为什么在 RestTemplate 上加了一个 @LoadBalanced 之后，RestTemplate 就能够跟 Eureka 结合了，不但可以使用服务名称去调用接口，还可以负载均衡？\n\n应该归功于 Spring Cloud 给我们做了大量的底层工作，因为它将这些都封装好了，我们用起来才会那么简单。框架就是为了简化代码，提高效率而产生的。\n\n这里主要的逻辑就是给 RestTemplate 增加拦截器，在请求之前对请求的地址进行替换，或者根据具体的负载策略选择服务地址，然后再去调用，这就是 @LoadBalanced 的原理。\n\n下面我们来实现一个简单的拦截器，看看在调用接口之前会不会进入这个拦截器。我们不做任何操作，就输出一句话，证明能进来就行了。具体代码如下所示。\npublic class MyLoadBalancerInterceptor implements ClientHttpRequestInterceptor {\n    private LoadBalancerClient loadBalancer;\n    private LoadBalancerRequestFactory requestFactory;\n    public MyLoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) {\n        this.loadBalancer = loadBalancer;\n        this.requestFactory = requestFactory;\n    }\n    public MyLoadBalancerInterceptor(LoadBalancerClient loadBalancer) {\n        this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));\n    }\n    @Override\n    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,\n            final ClientHttpRequestExecution execution) throws IOException {\n        final URI originalUri = request.getURI();\n        String serviceName = originalUri.getHost();\n        System.out.println("进入自定义的请求拦截器中" + serviceName);\n        Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);\n        return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));\n    }\n}\n拦截器设置好了之后，我们再定义一个注解，并复制 @LoadBalanced 的代码，改个名称就可以了，代码如下所示。\n@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Qualifier\npublic @interface MyLoadBalanced {\n}\n\n然后定义一个配置类，给 RestTemplate 注入拦截器，代码如下所示。\n@Configuration\npublic class MyLoadBalancerAutoConfiguration {\n    @MyLoadBalanced\n    @Autowired(required = false)\n    private List<RestTemplate> restTemplates = Collections.emptyList();\n    @Bean\n    public MyLoadBalancerInterceptor myLoadBalancerInterceptor() {\n        return new MyLoadBalancerInterceptor();\n    }\n    @Bean\n    public SmartInitializingSingleton myLoadBalancedRestTemplateInitializer() {\n        return new SmartInitializingSingleton() {\n          @Override\n          public void afterSingletonsInstantiated() {\n            for (RestTemplate restTemplate : MyLoadBalancerAutoConfiguration.this.restTemplates){\n                List<ClientHttpRequestInterceptor> list = new ArrayList<>(restTemplate.getInterceptors());\n                list.add(myLoad BalancerInterceptor());\n                restTemplate.setInterceptors(list);\n            }\n          }\n        };\n    }\n}\n维护一个 @MyLoadBalanced 的 RestTemplate 列表，在 SmartInitializingSingleton 中对 RestTemplate 进行拦截器设置。\n\n然后改造我们之前的 RestTemplate 配置，将 @LoadBalanced 改成我们自定义的 @MyLoadBalanced，代码如下所示。\n@Bean\n//@LoadBalanced\n@MyLoadBalanced\npublic RestTemplate getRestTemplate() {\n    return new RestTemplate();\n}\n\n重启服务，访问服务中的接口就可以看到控制台的输出了，这证明在接口调用的时候会进入该拦截器，输出如下：\n进入自定义的请求拦截器中 ribbon-eureka-demo\n\n通过这个小案例我们就能够清楚地知道 @LoadBalanced 的工作原理。接下来我们来看看源码中是怎样的一个逻辑。\n\n首先看配置类，如何为 RestTemplate 设置拦截器，代码在 spring-cloud-commons.jar 中的 org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration 类里面通过查看 LoadBalancerAutoConfiguration 的源码，可以看到这里也是维护了一个 @LoadBalanced 的 RestTemplate 列表，代码如下所示。\n@LoadBalanced\n@Autowired(required = false)\nprivate List<RestTemplate> restTemplates = Collections.emptyList();\n@Bean\npublic SmartInitializingSingleton loadBalancedRestTemplateInitializer(final List<RestTemplateCustomizer> customizers) {\n    return new SmartInitializingSingleton() {\n        @Override\n        public void afterSingletonsInstantiated() {\n            for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) {\n                for (RestTemplateCustomizer customizer : customizers) {\n                    customizer.customize(restTemplate);\n                }\n            }\n        }\n    };\n}\n通过查看拦截器的配置可以知道，拦截器用的是 LoadBalancerInterceptor，RestTemplate Customizer 用来添加拦截器，代码如下所示。\n@Configuration\n@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")\nstatic class LoadBalancerInterceptorConfig {\n    @Bean\n    public LoadBalancerInterceptor ribbonInterceptor(LoadBalancerClient loadBalancerClient,\n            LoadBalancerRequestFactory requestFactory) {\n        return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);\n    }\n    @Bean\n    @ConditionalOnMissingBean\n    public RestTemplateCustomizer restTemplateCustomizer(\n            final LoadBalancerInterceptor loadBalancerInterceptor) {\n        return new RestTemplateCustomizer() {\n            @Override\n            public void customize(RestTemplate restTemplate) {\n                List<ClientHttpRequestInterceptor> list = new ArrayList<>(\n                  restTemplate.getInterceptors());\n                list.add(loadBalancerInterceptor);\n                restTemplate.setInterceptors(list);\n            }\n        };\n    }\n}\n拦截器的代码在 org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor 中，代码如下所示。\npublic class LoadBalancerInterceptor implements ClientHttpRequestInterceptor {\n    private LoadBalancerClient loadBalancer;\n    private LoadBalancerRequestFactory requestFactory;\n    public LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) {\n        this.loadBalancer = loadBalancer;\n        this.requestFactory = requestFactory;\n    }\n    public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) {\n        this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));\n    }\n    @Override\n    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,\n            final ClientHttpRequestExecution execution) throws IOException {\n        final URI originalUri = request.getURI();\n        String serviceName = originalUri.getHost();\n        Assert.state(serviceName != null, "Request URI does not contain a valid hostname:" + originalUri);\n        return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));\n    }\n}\n主要的逻辑在 intercept 中，执行交给了 LoadBalancerClient 来处理，通过 LoadBalancer RequestFactory 来构建一个 LoadBalancerRequest 对象，代码如下所示。\npublic LoadBalancerRequest<ClientHttpResponse> createRequest(final HttpRequest request, final byte[] body,\n        final ClientHttpRequestExecution execution) {\n    return new LoadBalancerRequest<ClientHttpResponse>() {\n        @Override\n        public ClientHttpResponse apply(final ServiceInstance instance) throws Exception {\n            HttpRequest serviceRequest = new ServiceRequestWrapper(request, instance, loadBalancer);\n            if (transformers != null) {\n                for (LoadBalancerRequestTransformer transformer : transformers) {\n                    serviceRequest = transformer.transformRequest(serviceRequest,instance);\n                }\n            }\n            return execution.execute(serviceRequest, body);\n        }\n    };\n}\ncreateRequest 中通过 ServiceRequestWrapper 来执行替换 URI 的逻辑，ServiceRequest Wrapper 中将 URI 的获取交给了 org.springframework.cloud.client.loadbalancer.LoadBalancer Client#reconstructURI 方法。\n\n以上就是整个 RestTemplate 结合 @LoadBalanced 的执行流程，至于具体的实现大家可以自己去研究，这里只介绍原理及整个流程。\nRibbon API 使用\n当你有一些特殊的需求，想通过 Ribbon 获取对应的服务信息时，可以使用 Load-Balancer Client 来获取，比如你想获取一个 ribbon-eureka-demo 服务的服务地址，可以通过 LoadBalancerClient 的 choose 方法来选择一个：\n@Autowired\nprivate LoadBalancerClient loadBalancer;\n@GetMapping("/choose")\npublic Object chooseUrl() {\n    ServiceInstance instance = loadBalancer.choose("ribbon-eureka-demo");\n    return instance;\n}\n访问接口，可以看到返回的信息如下：\n{\n    serviceId: "ribbon-eureka-demo",\n    server: {\n        host: "localhost",\n        port: 8081,\n        id: "localhost:8081",\n        zone: "UNKNOWN",\n        readyToServe: true,\n        alive: true,\n        hostPort: "localhost:8081",\n        metaInfo: {\n            serverGroup: null,\n            serviceIdForDiscovery: null, instanceId: "localhost:8081",\n            appName: null\n        }\n    },\n    secure: false, metadata: { }, host: "localhost", port: 8081,\n    uri: "http://localhost:8081"\n}\nRibbon 饥饿加载\n笔者从网上看到很多博客中都提到过的一种情况：在进行服务调用的时候，如果网络情况不好，第一次调用会超时。有很多大神对此提出了解决方案，比如把超时时间改长一点、禁用超时等。\n\nSpring Cloud 目前正在高速发展中，版本更新很快，我们能发现的问题基本上在版本更新的时候就修复了，或者提供最优的解决方案。\n\n超时的问题也是一样，Ribbon 的客户端是在第一次请求的时候初始化的，如果超时时间比较短的话，初始化 Client 的时间再加上请求接口的时间，就会导致第一次请求超时。\n\n本教程是基于 Finchley.SR2 撰写的，这个版本已经提供了一种针对上述问题的解决方法，那就是 eager-load 方式。通过配置 eager-load 来提前初始化客户端就可以解决这个问题。\nribbon.eager-load.enabled=true\nribbon.eager-load.clients=ribbon-eureka-demo\n\nribbon.eager-load.enabled：开启 Ribbon 的饥饿加载模式。\nribbon.eager-load.clients：指定需要饥饿加载的服务名，也就是你需要调用的服务，若有多个则用逗号隔开。\n\n怎么进行验证呢？网络情况确实不太好模拟，不过通过调试源码的方式即可验证，在 org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration 中找到对应的代码，代码如下所示。\n@Bean\n@ConditionalOnProperty(value = "ribbon.eager-load.enabled")\npublic RibbonApplicationContextInitializer ribbonApplicationContextInitializer() {\n    return new RibbonApplicationContextInitializer(springClientFactory(),ribbonEagerLoadProperties.getClients());\n}\n\n在 return 这行设置一个断点，然后以调试的模式启动服务，如果能进入到这个断点的代码这里，就证明配置生效了\n\n\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);