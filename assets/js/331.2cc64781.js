(window.webpackJsonp=window.webpackJsonp||[]).push([[331],{819:function(n,t,r){"use strict";r.r(t);var e=r(6),i=Object(e.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-cloud-hystrix-熔断器-介绍及使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-hystrix-熔断器-介绍及使用"}},[this._v("#")]),this._v(" Spring Cloud Hystrix（熔断器）介绍及使用")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('Hystrix 是 Netflix 针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。\n\n在分布式环境中，许多服务依赖项中的一些必然会失败。Hystrix 是一个库，通过添加延迟容忍和容错逻辑，帮助你控制这些分布式服务之间的交互。Hystrix 通过隔离服务之间的访问点、停止级联失败和提供回退选项来实现这一点，所有这些都可以提高系统的整体弹性。\n\n在微服务架构下，很多服务都相互依赖，如果不能对依赖的服务进行隔离，那么服务本身也有可能发生故障，Hystrix 通过 HystrixCommand 对调用进行隔离，这样可以阻止故障的连锁效应，能够让接口调用快速失败并迅速恢复正常，或者回退并优雅降级。\nHystrix 的简单使用\n创建一个空的 Maven 项目，在项目中增加 Hystrix 的依赖，代码如下所示。\n<dependency>\n    <groupId>com.netflix.hystrix</groupId>\n    <artifactId>hystrix-core</artifactId>\n    <version>1.5.18</version>\n</dependency>\n\n编写第一个 HystrixCommand，代码如下所示。\npublic class MyHystrixCommand extends HystrixCommand<String> {\n    private final String name;\n    public MyHystrixCommand(String name) {\n        super(HystrixCommandGroupKey.Factory.asKey("MyGroup"));\n        this.name = name;\n    }\n    @Override\n    protected String run() {\n        return this.name + ":" + Thread.currentThread().getName();\n    }\n}\n首先需要继承 HystrixCommand，通过构造函数设置一个 Groupkey。具体的逻辑在 run 方法中，我们返回了一个当前线程名称的值。写一个 main 方法来调用上面编写的 MyHystrixCommand 程序，代码如下所示。\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    String result = new MyHystrixCommand("zhangsan").execute();\n    System.out.println(result);\n}\n输出结果如图 1 所示：\n\n运行结果\n图 1  运行结果\n\n从图 1 中可以看到输出结果是“zhangsan：hystrix-MyGroup-1”。由此可以看出，构造函数中设置的组名变成了线程的名字。\n\n上面是同步调用，如果需要异步调用可以使用如下代码所示的方法。\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    Future<String> future = new MyHystrixCommand("zhangsan").queue();\n    System.out.println(future.get());\n}\n运行结果和图 1 相同。\n回退支持\n下面我们通过增加执行时间模拟调用超时失败的情况。首先改造 MyHystrixCommand，增加 getFallback 方法返回回退内容，代码如下所示。\npublic class MyHystrixCommand extends HystrixCommand<String> {\n    private final String name;\n    public MyHystrixCommand(String name) {\n        super(HystrixCommandGroupKey.Factory.asKey("MyGroup"));\n        this.name = name;\n    }\n    @Override\n    protected String run() {\n        try {\n            Thread.sleep(1000 * 10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return this.name + ":" + Thread.currentThread().getName();\n    }\n    @Override\n    protected String getFallback() {\n        return "失败了 ";\n    }\n}\n重新执行调用代码，运行结果如图 2 所示，可以发现返回的内容是“失败了"\n\n')])])]),t("p",[t("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR2092145941.png",alt:"RUNOOB 图标"}})]),this._v(" "),t("p",[t("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR2093SQ35.png",alt:"RUNOOB 图标"}})])])}),[],!1,null,null,null);t.default=i.exports}}]);