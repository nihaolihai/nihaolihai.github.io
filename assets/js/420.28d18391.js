(window.webpackJsonp=window.webpackJsonp||[]).push([[420],{908:function(e,t,n){"use strict";n.r(t);var r=n(6),s=Object(r.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-mvc拦截器的执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc拦截器的执行流程"}},[this._v("#")]),this._v(" Spring MVC拦截器的执行流程")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('单个拦截器的执行流程\n在配置文件中如果只定义了一个拦截器，程序将首先执行拦截器类中的 preHandle 方法，如果该方法返回 true，程序将继续执行控制器中处理请求的方法，否则中断执行。如果 preHandle 方法返回 true，并且控制器中处理请求的方法执行后、返回视图前将执行 postHandle 方法，返回视图后才执行 afterCompletion 方法。\n\n下面通过一个应用 springMVCDemo06 演示拦截器的执行流程，具体步骤如下：\n1）创建应用\n创建一个名为 springMVCDemo06 的 Web 应用，并将 Spring MVC 相关的 JAR 包复制到 lib 目录中。\n2）创建 web.xml\n在 WEB-INF 目录下创建 web.xml 文件，该文件中的配置信息如下：\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n    xmlns="http://java.sun.com/xml/ns/javaee" \n    xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" \n    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">\n    \x3c!--配置DispatcherServlet--\x3e\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n3）创建控制器类\n在 src 目录下创建一个名为 controller 的包，并在该包中创建控制器类 Interceptor Controller，代码如下：\npackage Controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\npublic class InterceptorController {\n    @RequestMapping("/gotoTest")\n    public String gotoTest() {\n        System.out.println("正在测试拦截器，执行控制器的处理请求方法中");\n        return "test";\n    }\n}\n4）创建拦截器类\n在 src 目录下创建一个名为 interceptor 的包，并在该包中创建拦截器类 TestInterceptor，代码与《拦截器的配置和使用》教程中的示例代码相同。\n5）创建配置文件 springmvc-servlet.xml\n在 WEB-INF 目录下创建配置文件 springmvc-servlet.xml，代码如下：\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n    xmlns:mvc="http://www.springframework.org/schema/mvc"\n    xmlns:p="http://www.springframework.org/schema/p" \n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd">\n    \x3c!-- 使用扫描机制扫描控制器类 --\x3e\n    <context:component-scan base-package="controller" />\n    \x3c!-- 配置视图解析器 --\x3e\n    <bean\n        class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        <property name="prefix" value="/WEB-INF/jsp/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n    \x3c!-- 配置拦截器 --\x3e\n    <mvc:interceptors>\n        \x3c!-- 配置一个全局拦截器，拦截所有请求 --\x3e\n        <bean class="interceptor.TestInterceptor" />\n    </mvc:interceptors>\n</beans>\n6）创建视图 JSP 文件\n在 WEB-INF 目录下创建一个 jsp 文件夹，并在该文件夹中创建一个 JSP 文件 test.jsp，代码如下：\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n<html>\n<head>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n<title>Insert title here</title>\n</head>\n<body>\n    视图\n    <%System.out.println("视图渲染结束。"); %>\n</body>\n</html>\n7）测试拦截器\n首先将 springMVCDemo06 应用发布到 Tomcat 服务器，并启动 Tomcat 服务器，然后通过地址“http://localhost:8080/springMVCDemo06/gotoTest”测试拦截器。程序正确执行后控制台的输出结果如图 1 所示。\n\n单个拦截器的执行过程\n图 1  单个拦截器的执行过程\n多个拦截器的执行流程\n在 Web 应用中通常需要有多个拦截器同时工作，这时它们的 preHandle 方法将按照配置文件中拦截器的配置顺序执行，而它们的 postHandle 方法和 afterCompletion 方法则按照配置顺序的反序执行。\n\n下面通过修改“单个拦截器的执行流程”小节的 springMVCDemo06 应用来演示多个拦截器的执行流程，具体步骤如下：\n1）创建多个拦截器\n在 springMVCDemo06 应用的 interceptor 包中创建两个拦截器类 Interceptor1 和 Interceptor2。\npackage interceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\npublic class Interceptor1 implements HandlerInterceptor {\n    public boolean preHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler) throws Exception {\n        System.out.println("Interceptor preHandle 方法执行");\n        /** 返回true表示继续向下执行，返回false表示中断后续的操作 */\n        return true;\n    }\n    @Override\n    public void postHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.out.println("Interceptor1 postHandle 方法执行");\n    }\n    @Override\n    public void afterCompletion(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.out.println("Interceptor1 afterCompletion 方法执行");\n    }\n}\nInterceptor2 类的代码如下：\npackage interceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\npublic class Interceptor2 implements HandlerInterceptor {\n    public boolean preHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler) throws Exception {\n        System.out.println("Interceptor2 preHandle 方法执行");\n        /** 返回true表示继续向下执行，返回false表示中断后续的操作 */\n        return true;\n    }\n    @Override\n    public void postHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.out.println("Interceptor2 postHandle 方法执行");\n    }\n    @Override\n    public void afterCompletion(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.out.println("Interceptor2 afterCompletion 方法执行");\n    }\n}\n2）配置拦截器\n在配置文件 springmvc-servlet.xml 中的 <mvc：interceptors> 元素内配置两个拦截器 Interceptor1 和 Interceptor2，配置代码如下：\n<mvc:interceptors>\n    \x3c!-- 配置一个全局拦截器，拦截所有请求 --\x3e\n    \x3c!--<bean class="interceptor.TestInterceptor" />--\x3e\n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/**"/>\n        \x3c!--定义在<mvc:interceptor>元素中，表示匹配指定路径的请求才进行拦截--\x3e\n        <bean class="interceptor.Interceptor1"/>\n    </mvc:interceptor>\n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/gotoTest"/>\n        \x3c!--定义在<mvc:interceptor>元素中，表示匹配指定路径的请求才进行拦截--\x3e\n        <bean class="interceptor.Interceptor2"/>\n    </mvc:interceptor>\n</mvc:interceptors>\n3）测试多个拦截器\n首先将 springMVCDemo06 应用发布到 Tomcat 服务器并启动 Tomcat 服务器，然后通过地址“http://localhost：8080/springMVCDemo06/gotoTest”\n\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);