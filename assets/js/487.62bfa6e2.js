(window.webpackJsonp=window.webpackJsonp||[]).push([[487],{976:function(e,n,t){"use strict";t.r(n);var u=t(6),r=Object(u.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"mongodb聚合查询详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mongodb聚合查询详解"}},[this._v("#")]),this._v(" MongoDB聚合查询详解")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('select cust_id as _id, sum(amount) as total from orders where status like "%A%" group by cust_id;\nMongoDB 中的聚合操作语法如下：\ndb.collection.aggregate([\n{\n    $match : {< query >},\n}\n{\n    $group: {< fieldl >: < field2 >}\n}\n])\nQuery 设置统计查询条件，类似于 SQL 的 where，field1 为分类字段，要求使用 _id 名表示分类字段，field2 为包含各种统计操作符的数字型字段，如 $sum、$avg、$min 等。\n\n这个语法看起来比较难以理解，下面给出一个示例进行对照：\ndb.mycol.aggregate([\n{\n    $group : {_id : "$by_user", num_tutorial : {$sum : 1}}\n}\n])\n相当于MySQL中的：\nselect by_user as _id, count(*) as num_tutorial from mycol group by by_user;\n\n再举一个复杂的例子，按照指定条件对文档进行过滤，然后对满足条件的文档进行统计，并将统计结果输出到临时文件中。\n\n首先插入多条文档，代码如下：\ndb.articles.insert([    \n    { "_id" : 10, "author" : "dave", "score" : 80, "views" :100 },\n    { "_id" : 11, "author" : "dave", "score" : 85, "views" : 521 },\n    { "_id" : 12, "author" : "ahn", "score" : 60, "views" : 1000 },\n    { "_id" : 13, "author" : "li", "score" : 55, "views" : 5000 },\n    { "_id" : 14, "author" : "annT", "score" : 60, "views" : 50 },\n    { "_id" : 15, "author" : "1i", "score": 94, "views": 999 },\n    { "_id" : 16, "author" : "ty", "score" : 95, "views": 1000 }\n]);\n再进行聚合分类统计，代码如下:\ndb.articles.aggregate([\n{\n    $match: { $or: [{ score: { $gt: 70, $1t: 90 }}, { views: { $gte: 1000 }}]}}, { $group: { _id: null, count: { $sum: 1 }}\n}\n]);\n最终统计结果为：\n{ "_id" : null, "count" : 5 }\n\n管道阶段的 RAM 限制为 100MB。若要允许处理大型数据集，则可使用 allowDiskUse 选项启用聚合管道阶段，将数据写入临时文件。\nmap-reduce 方法\nMongoDB 还提供了 map-reduce 方法来执行聚合。通常 map-reduce 方法有两个阶段：首先 map 阶段将大批量的工作数据分解执行，然后 reduce 阶段再将结果合并成最终结果。\n\n与其他聚合操作相同，map-reduce 可以指定查询条件以选择输入文档以及排序和限制结果。\n\nmap-reduce 使用自定义 JavaScript 函数来执行映射和减少操作，虽然自定义 JavaScript 与聚合管道相比提供了更大的灵活性，但通常 map-reduce 比聚合管道效率更低、更复杂。\n\nmap-reduce 可以在分片集合上运行，也可以输出到分片集合。map-reduce 的语法如下：\n>db.collection.mapReduce(\n    function() { emit(key,value); },\n    function(key, values) { return reduceFunction }\n    { query: document, out: collection }\n)\n\n参数说明：\nfunction() { emit(key,value); } 为 map 映射函数，负责生成键值对序列，并作为 reduce 函数输入参数。\nfunction(key, values) { return reduceFunction } 为 reduce 统计函数，reduce 函数的任务就是将 key-values 变成 key-value，也就是把 values 数组转换成一个单一的值 value。\nquery 设置筛选条件，只有满足条件的文档才会调用 map 函数。\nout 为统计结果的存放集合，如果不指定则使用临时集合，但会在客户端断开后自动删除。\n\n举例说明使用 map-Teduce 方法进行 MongoDB 文档数据的聚合。首先插入数据，数据为每位顾客 cust_id 的消费情况，代码如下：\ndb.order.insert([\n    { "cust_id" : "l", "status" : "A", "price" : 25, "items" : [{"sku" : "mmm", "qty" : 5, "price" : 2.5 }, \n    { "sku" : "nnn", "qty" : 5, "price" : 2.5 }]},\n    { "cust_id" : "l", "status" : "A", "price" : 25, "items" : [{"sku" : "mmm", "qty" : 5, "price" : 2.5 },\n   { "sku" : "nnn", "qty" : 5, "price" : 2.5 }]},\n   { "cust_id" : "2", "status" : "A", "price" : 25, "items" : [{"sku" : "mmm", "qty" : 5, "price" : 2.5 },\n   { "sku" : "nnn", "qty" : 5, "price" : 2.5 }]},\n    { "cust_id" : "3", "status" : "A", "price" : 25, "items" : [{"sku" : "mmm", "qty" : 5, "price" : 2.5 },\n    { "sku" : "nnn", "qty" : 5, "price" : 2.5 }]},\n    { "cust_id" : "3", "status" : "A", "price" : 25, "items" : [{"sku" : "mmm", "qty" : 6, "price" : 2.5 },\n    { "sku" : "nnn", "qty" : 6, "price" : 2.5 }]},\n])\n编写 map 函数，cust_id 作为 map 的输出 key，price 作为 map 的输出 value，代码如下：\nvar mapFunc = function(){\n    emit(this.cust_id, this.price);\n};\n编写 reduce 函数，将相同的 map 的输出 key(cust_id) 聚合起来，这里对输出的 value 进行 sum 操作，代码如下：\nvar reduceFunc = function(key,values){\n    return Array.sum(values);\n};\n执行 map-reduce 任务，将 reduce 的输出结果保存在集合 map_result_result 中，代码如下：\ndb.order.mapReduce(mapFunc, reduceFunc, { out: { replace: \'map_result_result\' }})\n查看当前数据库下的所有集合，会发现新建了一个 map_result_result，此集合里保存了 map-reduce 聚合后的结果：\n>show collections\n    map_result_result\n    myColl\n    order\n>db.map_result_result.find() \n    { "_id" : "l", "value" : 50.0 } \n    { "_id" : "2", "value" : 25.0 } \n    { "_id" : "3", "value" : 55.0 }\n\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);