(window.webpackJsonp=window.webpackJsonp||[]).push([[349],{843:function(n,e,r){"use strict";r.r(e);var t=r(6),a=Object(t.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud-gateway整合eureka路由转发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-gateway整合eureka路由转发"}},[this._v("#")]),this._v(" Spring Cloud Gateway整合Eureka路由转发")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('创建 Gateway 项目\n创建一个 Spring Boot 的 Maven 项目，增加 Spring Cloud Gateway 的依赖，代码如下所示。\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.6.RELEASE</version>\n    <relativePath />\n</parent>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>Finchley.SR2</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-gateway</artifactId>\n    </dependency>\n</dependencies>\n启动类就按 Spring Boot 的方式即可，无须添加额外的注解。代码如下所示。\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n}\n路由转发示例\n下面来实现一个最简单的转发功能——基于 Path 的匹配转发功能。\n\nGateway 的路由配置对 yml 文件支持比较好，我们在 resources 下建一个 application.yml 的文件，内容如下：\nserver:\n  port: 2001\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: path_route\nuri: http://c.biancheng.net\npredicates:\n  - Path=/spring_cloud\n\n当你访问 http://localhost:2001/spring_cloud 的时候就会转发到 http://c.biancheng.net/spring_cloud。\n\n如果我们要支持多级 Path，配置方式跟 Zuul 中一样，在后面加上两个*号即可，比如：\n- id: path_route2\nuri: http://c.biancheng.net\npredicates:\n  - Path=/spring_cloud/**\n\n这样一来，上面的配置就可以支持多级 Path，比如访问 http://localhost:2001/spring_cloud/view/1 的时候就会转发到 http://c.biancheng.net/spring_cloud/view/1。\n整合 Eureka 路由\n添加 Eureka Client 的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n配置基于 Eureka 的路由：\n- id: user-service\nuri: lb://user-service\npredicates:\n  - Path=/user-service/**\n\nuri 以lb：//开头（lb 代表从注册中心获取服务），后面接的就是你需要转发到的服务名称，这个服务名称必须跟 Eureka 中的对应，否则会找不到服务，错误代码如下：\norg.springframework.cloud.gateway.support.NotFoundException: Unable to find instance for user-service1\n\n整合 Eureka 的默认路由\nZuul 默认会为所有服务都进行转发操作，我们只需要在访问路径上指定要访问的服务即可，通过这种方式就不用为每个服务都去配置转发规则，当新加了服务的时候，不用去配置路由规则和重启网关。\n\n在 Spring Cloud Gateway 中当然也有这样的功能，通过配置即可开启，配置如下：\nspring:\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true\n\n开启之后我们就可以通过地址去访问服务了，格式如下：\nhttp://网关地址/服务名称(大写)/**\nhttp://localhost:2001/USER-SERVICE/user/get?id=1\n\n这个大写的名称还是有很大的影响，如果我们从 Zuul 升级到 Spring Cloud Gateway 的话意味着请求地址有改变，或者重新配置每个服务的路由地址，通过源码笔者发现可以做到兼容处理，再增加一个配置即可：\nspring:\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          lowerCaseServiceId: true\n\n配置完成之后我们就可以通过小写的服务名称进行访问了，如下所示：\nhttp://网关地址/服务名称(小写)/**\nhttp://localhost:2001/user-service/user/get?id=1\n\n注意：开启小写服务名称后大写的服务名称就不能使用，两者只能选其一。\n\n配置源码在 org.springframework.cloud.gateway.discovery.DiscoveryLocatorProperties 类中，代码所示。\n纯文本复制\n@ConfigurationProperties("spring.cloud.gateway.discovery.locator")\npublic class DiscoveryLocatorProperties {\n    /**\n     * 服务名称小写配置, 默认为false\n     *\n     */\n    private boolean lowerCaseServiceId = false;\n}\n\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);