(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{628:function(n,a,e){"use strict";e.r(a);var r=e(6),t=Object(r.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"java-多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-多态"}},[n._v("#")]),n._v(" Java 多态")]),n._v(" "),e("p",[n._v("多态是同一个行为具有多个不同表现形式或形态的能力。")]),n._v(" "),e("p",[n._v("多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2013/12/java-polymorphism-111.png",alt:"RUNOOB 图标"}})]),n._v(" "),e("p",[n._v("多态性是对象多种表现形式的体现。")]),n._v(" "),e("p",[n._v("现实中，比如我们按下 F1 键这个动作：")]),n._v(" "),e("p",[n._v("如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；\n如果当前在 Word 下弹出的就是 Word 帮助；\n在 Windows 下弹出的就是 Windows 帮助和支持。\n同一个事件发生在不同的对象上会产生不同的结果。")]),n._v(" "),e("p",[n._v("多态的优点")]),n._v(" "),e("ol",[e("li",[n._v("消除类型之间的耦合关系")]),n._v(" "),e("li",[n._v("可替换性")]),n._v(" "),e("li",[n._v("可扩充性")]),n._v(" "),e("li",[n._v("接口性")]),n._v(" "),e("li",[n._v("灵活性")]),n._v(" "),e("li",[n._v("简化性\n多态存在的三个必要条件\n继承\n重写\n父类引用指向子类对象：Parent p = new Child();")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2013/12/java-polymorphism-222.png",alt:"RUNOOB 图标"}})]),n._v(" "),e("p",[n._v("class Shape {\nvoid draw() {}\n}")]),n._v(" "),e("p",[n._v('class Circle extends Shape {\nvoid draw() {\nSystem.out.println("Circle.draw()");\n}\n}')]),n._v(" "),e("p",[n._v('class Square extends Shape {\nvoid draw() {\nSystem.out.println("Square.draw()");\n}\n}')]),n._v(" "),e("p",[n._v('class Triangle extends Shape {\nvoid draw() {\nSystem.out.println("Triangle.draw()");\n}\n}\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。')]),n._v(" "),e("p",[n._v("多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。")]),n._v(" "),e("p",[n._v("以下是一个多态实例的演示，详细说明请看注释：")]),n._v(" "),e("p",[n._v("Test.java 文件代码：\npublic class Test {\npublic static void main(String[] args) {\nshow(new Cat());  // 以 Cat 对象调用 show 方法\nshow(new Dog());  // 以 Dog 对象调用 show 方法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("  Animal a = new Cat();  // 向上转型  \n  a.eat();               // 调用的是 Cat 的 eat\n  Cat c = (Cat)a;        // 向下转型  \n  c.work();        // 调用的是 Cat 的 work\n")])])]),e("p",[n._v("}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("public static void show(Animal a)  {\n  a.eat();  \n    // 类型判断\n    if (a instanceof Cat)  {  // 猫做的事情 \n        Cat c = (Cat)a;  \n        c.work();  \n    } else if (a instanceof Dog) { // 狗做的事情 \n        Dog c = (Dog)a;  \n        c.work();  \n    }  \n}  \n")])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("abstract class Animal {"),e("br"),n._v("\nabstract void eat();"),e("br"),n._v("\n}")]),n._v(" "),e("p",[n._v("class Cat extends Animal {"),e("br"),n._v("\npublic void eat() {"),e("br"),n._v('\nSystem.out.println("吃鱼");'),e("br"),n._v("\n}"),e("br"),n._v("\npublic void work() {"),e("br"),n._v('\nSystem.out.println("抓老鼠");'),e("br"),n._v("\n}"),e("br"),n._v("\n}")]),n._v(" "),e("p",[n._v("class Dog extends Animal {"),e("br"),n._v("\npublic void eat() {"),e("br"),n._v('\nSystem.out.println("吃骨头");'),e("br"),n._v("\n}"),e("br"),n._v("\npublic void work() {"),e("br"),n._v('\nSystem.out.println("看家");'),e("br"),n._v("\n}"),e("br"),n._v("\n}\n执行以上程序，输出结果为：")]),n._v(" "),e("p",[n._v("吃鱼\n抓老鼠\n吃骨头\n看家\n吃鱼\n抓老鼠\n虚函数\n虚函数的存在是为了多态。")]),n._v(" "),e("p",[n._v("Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。")]),n._v(" "),e("p",[n._v("重写\n我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。")]),n._v(" "),e("p",[n._v("我们已经讨论了方法的重写，也就是子类能够重写父类的方法。")]),n._v(" "),e("p",[n._v("当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。")]),n._v(" "),e("p",[n._v("要想调用父类中被重写的方法，则必须使用关键字 super。")]),n._v(" "),e("p",[n._v('Employee.java 文件代码：\n/* 文件名 : Employee.java */\npublic class Employee {\nprivate String name;\nprivate String address;\nprivate int number;\npublic Employee(String name, String address, int number) {\nSystem.out.println("Employee 构造函数");\nthis.name = name;\nthis.address = address;\nthis.number = number;\n}\npublic void mailCheck() {\nSystem.out.println("邮寄支票给： " + this.name\n+ " " + this.address);\n}\npublic String toString() {\nreturn name + " " + address + " " + number;\n}\npublic String getName() {\nreturn name;\n}\npublic String getAddress() {\nreturn address;\n}\npublic void setAddress(String newAddress) {\naddress = newAddress;\n}\npublic int getNumber() {\nreturn number;\n}\n}\n假设下面的类继承Employee类：')]),n._v(" "),e("p",[n._v('Salary.java 文件代码：\n/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\nprivate double salary; // 全年工资\npublic Salary(String name, String address, int number, double salary) {\nsuper(name, address, number);\nsetSalary(salary);\n}\npublic void mailCheck() {\nSystem.out.println("Salary 类的 mailCheck 方法 ");\nSystem.out.println("邮寄支票给：" + getName()\n+ " ，工资为：" + salary);\n}\npublic double getSalary() {\nreturn salary;\n}\npublic void setSalary(double newSalary) {\nif(newSalary >= 0.0) {\nsalary = newSalary;\n}\n}\npublic double computePay() {\nSystem.out.println("计算工资，付给：" + getName());\nreturn salary/52;\n}\n}\n现在我们仔细阅读下面的代码，尝试给出它的输出结果：')]),n._v(" "),e("p",[n._v('VirtualDemo.java 文件代码：\n/* 文件名 : VirtualDemo.java */\npublic class VirtualDemo {\npublic static void main(String [] args) {\nSalary s = new Salary("员工 A", "北京", 3, 3600.00);\nEmployee e = new Salary("员工 B", "上海", 2, 2400.00);\nSystem.out.println("使用 Salary 的引用调用 mailCheck -- ");\ns.mailCheck();\nSystem.out.println("\\n使用 Employee 的引用调用 mailCheck--");\ne.mailCheck();\n}\n}\n以上实例编译运行结果如下：')]),n._v(" "),e("p",[n._v("Employee 构造函数\nEmployee 构造函数\n使用 Salary 的引用调用 mailCheck --\nSalary 类的 mailCheck 方法\n邮寄支票给：员工 A ，工资为：3600.0")]),n._v(" "),e("p",[n._v("使用 Employee 的引用调用 mailCheck--\nSalary 类的 mailCheck 方法\n邮寄支票给：员工 B ，工资为：2400.0\n例子解析\n实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。")]),n._v(" "),e("p",[n._v("当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。")]),n._v(" "),e("p",[n._v("e 是 Employee 的引用，但引用 e 最终运行的是 Salary 类的 mailCheck() 方法。")]),n._v(" "),e("p",[n._v("在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。")]),n._v(" "),e("p",[n._v("以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。")]),n._v(" "),e("p",[n._v("Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。")]),n._v(" "),e("p",[n._v("多态的实现方式\n方式一：重写：\n这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。\n方式二：接口")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。")])]),n._v(" "),e("li",[e("p",[n._v("java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。")])])]),n._v(" "),e("p",[n._v("方式三：抽象类和抽象方法\n详情请看 Java抽象类 章节。")])])}),[],!1,null,null,null);a.default=t.exports}}]);