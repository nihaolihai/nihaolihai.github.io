(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{757:function(n,t,a){"use strict";a.r(t);var e=a(6),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"day2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#day2"}},[n._v("#")]),n._v(" day2")]),n._v(" "),a("p",[n._v("数据(Data):\n我们编程是不是都是对数据进行处理.")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("  常量:不变的量\n          整数常量:所有的整数型的数据\n          小数常量:所有的小数型的数据\n          字符常量:一般是用单引号 '  '\n       字符串常量:一般式用双引号  \"  \"\n       布尔常量:true false\n")])])]),a("h2",{attrs:{id:"常量定义-final-int-moth-first-day-0-常量的变量名一般是由大写和-组成-增加可读性注意-常量一旦赋过值-后期将不能再改变例-final-int-row-line-row-line-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常量定义-final-int-moth-first-day-0-常量的变量名一般是由大写和-组成-增加可读性注意-常量一旦赋过值-后期将不能再改变例-final-int-row-line-row-line-2"}},[n._v("#")]),n._v(" 常量定义:\nfinal int MOTH_FIRST_DAY = 0;\n常量的变量名一般是由大写和_组成  增加可读性\n注意:常量一旦赋过值,后期将不能再改变\n例:final int ROW_LINE;\nROW_LINE = 2;")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                                              整数型   byte short int long\n                                              浮点型:float double\n                                              字符型:char\n")])])]),a("p",[n._v("数据类型----1.基本类型(8种)------\x3e       布尔类型:true false")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("               2.引用类型(无数种)            数组\n                                            接口\n                                                       内置的对象类型:Scanner  String Date()  Array  Integer\n                                                        自定义的对象类型:HelloWorld  Computer Book Person Employee Customer Order\n")])])]),a("hr"),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                                                            范围                    默认值\n")])])]),a("h2",{attrs:{id:"byte-字节型-1个字节-8bit-128-127-0short-短整型-2个字节-16bit-2-15-2-15-1-0int-整型-4个字节-32bit-2-31-2-31-1-0long-长整型-8个字节-64bit-2-63-2-63-1-0float-单精度浮点型-4个字节-32bit-1-79810-308-1-79810-308-1-0-0double-双精度浮点型-8个字节-64bit-3-410-38-3-410-38-1-0-0char-字符型-2个字节-16bit-u0000-空格-boolean-布尔类型-1个字节-8bit-false"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte-字节型-1个字节-8bit-128-127-0short-短整型-2个字节-16bit-2-15-2-15-1-0int-整型-4个字节-32bit-2-31-2-31-1-0long-长整型-8个字节-64bit-2-63-2-63-1-0float-单精度浮点型-4个字节-32bit-1-79810-308-1-79810-308-1-0-0double-双精度浮点型-8个字节-64bit-3-410-38-3-410-38-1-0-0char-字符型-2个字节-16bit-u0000-空格-boolean-布尔类型-1个字节-8bit-false"}},[n._v("#")]),n._v(" byte(字节型)               1个字节　8bit                    -128~127                  0\nshort(短整型)              2个字节   16bit                   -2^15~2^15-1            0\nint(整型)                     4个字节    32bit                  -2^31~2^31-1           0\nlong(长整型)               8个字节     64bit                 -2^63~2^63-1             0\nfloat(单精度浮点型)      4个字节     32bit                  -1.798"),a("em",[n._v("10^-308~1.798")]),n._v("10^308-1                  0.0\ndouble(双精度浮点型)   8个字节     64bit                  -3.4"),a("em",[n._v("10^-38~3.4")]),n._v("10^38-1                     0.0"),a("br"),n._v("\nchar(字符型)                 2个字节      16bit                                          '\\u0000'(空格)\nboolean(布尔类型)          1个字节     8bit                                            false")]),n._v(" "),a("p",[n._v("变量:内存中的一块区域,类似于数学里的未知数\n语法:    数据类型  变量名 = 初始值;\nint i = 5;//把5这个值赋给变量i\n或者:int i;//声明变量\ni = 5;//给变量赋值")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("           链式的方式:int x,y,z;//先声明一个变量\n                              x = y = z = 5;//链式的方式进行赋值\n         \n            int a,b=5;//只是给y初始化了,但是a仍然没有初始化\n            System.out.println(a);//error   注意点:要使用一个变量,前提是此变量要提前被初始化\n            System.out.println(b);//OK\n\n赋值方式:\n                1.直接赋值\n                              int a = 10;\n                 2.表达式赋值:\n                               表达式概念:由运算符和变量组成的合法的语句\n\n                               int i = a+b;//前提是a b都要初始化\n                  3.方法赋值:\n                                 int c = add(i,j);\n")])])]),a("p",[n._v("变量名命名: 1.参照类名的规范\n2.与类名规范不同的地方是类名首字母要大写\n变量名是首字母要小写 并且如果是由多个单词组成\n从第二个单词开始,每个单词的首字母要大写\n3.变量的命名最好尽可能有意义\nuserInfo\n1userInfo//error\nuser()Info//error\n_abc;//OK\n$d;//OK")]),n._v(" "),a("h2",{attrs:{id:"变量的生命周期-只存在于-之内"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量的生命周期-只存在于-之内"}},[n._v("#")]),n._v(" 变量的生命周期:\n只存在于{...之内}")]),n._v(" "),a("p",[n._v("char   采用的是UNICODE编码集(统一码或者万能码)")]),n._v(" "),a("p",[n._v("特殊字符:  \\  叫做转义字符\n\\t:    tab键\n\\n:   换行  到下一行的起始位置\n\\r:    换行   到当前行的其实位置\n\"     \"\n'      '\n\\\\       \\")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("      了解:gb2312    gbk\n              big5(台湾繁体)\n              utf-8    utf-16\n\n              char c='2';//ok\n              char c = 2;//OK\n              char c='我';//OK\n              char c='我们';//error  超出范围\n              char c = '\\u0030';//OK\n")])])]),a("p",[n._v("cmd中获取ascii\nnative2ascii")]),n._v(" "),a("p",[n._v("数据类型的转换:\nbyte->short->int->long\nchar->int->long\nboolean->int  //error\n你看到一个整数,默认是int类型\n看到一个小数,默认是double类型\n隐式转换:\n精度小的数据类型会自动转换成精度高的数据类型\nbyte b = 123;//ok    底层先看数据类型 再去检查byte是否能够盛放得下")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                      int a = 3;\n                      int b = 4;\n                      byte c  = a+b;//因为在此处a 跟b已经是一个变量,既然是一个变量,运行的时候无法判断它是否超出byte范围\n                      此处需要强转:\n                          byte c = (byte)(a+b);\n\n                      System.out.println('a');//a\n                      System.out.println('a'+1);//98\n                      \n                      //char c = 'a';\n                      char m = 'a'+1;\n                      System.out.println(m);//b\n\n\n                      char m='a';\n                      char n = m+1;//error\n                     \n                  double d = .123;\n        强制转换:\n                    精度大的数据类型需要强制转换成精度小的数据类型\n                    会造成精度丢失\n")])])]),a("h2",{attrs:{id:"注意点-精度小的数据类型和精度大的数据类型进行运算的时候-偏向精度大的那一方总结一下-只有d-d-l-l-f-f可以简化转换的操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意点-精度小的数据类型和精度大的数据类型进行运算的时候-偏向精度大的那一方总结一下-只有d-d-l-l-f-f可以简化转换的操作"}},[n._v("#")]),n._v(" 注意点:精度小的数据类型和精度大的数据类型进行运算的时候,偏向精度大的那一方\n总结一下:只有D/d  L/l   F/f可以简化转换的操作")]),n._v(" "),a("p",[n._v("在我们计算机当中,是以二进制(0和1组成)来存储数据\n0代表整数  1代表负数\n0代表false   1代表true")]),n._v(" "),a("p",[n._v("二进制:由0和1组成,逢2进1")]),n._v(" "),a("p",[n._v("1000----\x3e\n1010----\x3e\n1111-----\x3e\n二进制与十进制之间的转换\n1111 = 1"),a("em",[n._v("2^3+1")]),n._v("2^2+1"),a("em",[n._v("2^1+1")]),n._v("2^0 = 15")]),n._v(" "),a("p",[n._v("0110 1010----\x3e1"),a("em",[n._v("2^6+1")]),n._v("2^5+0+1"),a("em",[n._v("2^3+0+1")]),n._v("2^1 = 106")]),n._v(" "),a("p",[n._v("8.625--------\x3e转成二进制是多少        1000.101=1"),a("em",[n._v("2^3+1")]),n._v("2^-1+1"),a("em",[n._v("2^-3\n0.625")]),n._v("2=1.25\n0.25"),a("em",[n._v("2 = 0.5\n05")]),n._v("2 = 1\n从上往下取整数位101")]),n._v(" "),a("p",[n._v("十进制转二进制:\n10                       10/2          商是5  余数0\n5/2           商是2  余数1\n2/2                    1..      0\n1/2                  0          1\n将余数倒序    1010")]),n._v(" "),a("p",[n._v("八进制:由0-7组成   逢8进1\n表示方式:032----\x3e对应的十进制   3"),a("em",[n._v("8^1+2")]),n._v("8^0 = 26\n十进制转成八进制               26-----\x3e            26/8 =   商3          余数  2\n3/8 = 0                 余数  3\n032\n二进制如何转成八进制:\n110 1110---------\x3e转成八进制:       001  101  110----\x3e0156\n总结:八进制其实以三个二进制位为一组  1000  111\n八进制用得地方比较少")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("           1111010-----------\x3e对应的八进制    001  111  010----\x3e0172\n")])])]),a("p",[n._v("十六进制:由0-9和A-F表示(10-15)"),a("br"),n._v("\n表示0XAF-----\x3e对应的十进制是     10"),a("em",[n._v("16^1+15")]),n._v("16^0 = 175;\n十进制转成十六进制       除以16")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("          0x3fa1-----\x3e转换成十进制 3*16^3+15*16^2+10*16^1+1*16^0=....\n")])])]),a("p",[n._v("二进制如何转换成十六进制呢?\n101 1110 0010 1100-----------\x3e转成十六进制                        0X 5e2c\n总结:十六进制就是每四个二进制位为一组")]),n._v(" "),a("h2",{attrs:{id:"十六进制如何转换成二进制-将十六进制的每一位表示的数都转成相应的二进制数0xd28a-1101-0010-1000-1010"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十六进制如何转换成二进制-将十六进制的每一位表示的数都转成相应的二进制数0xd28a-1101-0010-1000-1010"}},[n._v("#")]),n._v(" 十六进制如何转换成二进制?\n将十六进制的每一位表示的数都转成相应的二进制数\n0XD28A----------\x3e    1101   0010    1000   1010")]),n._v(" "),a("p",[n._v("运算符:\n赋值运算:\n=\nint i = 3;//将3赋给i\n算术运算符:\n+  相加\n-  减\n/   取整     8/3 = 2--------小数特殊----------9.0/2 = 4.5\n% 取模      8%3=2\n+=    先加然后再赋值     int i = i+3--------等同于-------int i+=3\n面试题:\nshort i = 3;\ni = i+1;\n编译不通过")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                                            short i+=3;//编译通过    +=在内部帮我们作了窄化转换\n                                                    \n                                          +=可以屏蔽掉类型转换\n                -+\n                *=\n                /+\n                %=\n                ++                         \n                                            前++:结论表达式和变量都增加\n                                                      int i = 3;\n                                                      int b=++i;\n                                                      System.out.println(i);//4\n                                                      System.out.prinln(b);//4\n\n                                            后++:结论:变量增加,表达式不变\n                                                            先赋值,再自增\n                                                      int i = 3;\n                                                      int b=i++;\n                                                      System.out.println(i);//4\n                                                      System.out.prinln(b);//3\n                                                 \n                --  减减\n")])])]),a("hr"),n._v(" "),a("h2",{attrs:{id:"比较运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[n._v("#")]),n._v(" 比较运算符:\n>\n<\n>=\n<=\n!=\n==")]),n._v(" "),a("p",[n._v("逻辑运算符:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("      &&  短路与          只有两个同时为true,结果才会true\n\n                    expr1  &&  expr2     当条件expr1能决定整个结果为fasle的时候,后面的expr2将不执行\n                                                   一般我们会将出现false可能性大的一个放在前面\n                                                  \n\n      ||      短路或             只要有一个true 那么结果就是true\n                                   \n\n                                      前面的如果返回的结果如果是true,后面也将不执行\n      !     非  取反\n                                  boolean flag = true;\n                                  !flag-----\x3efalse\n")])])]),a("p",[n._v("位运算:\n&    按位与")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                                                   1 0 1 0\n                                             &    1 1 0 1\n                                             -------------------\n                                                    1 0 0 0      就是值\n                        注意:它不管你前面的表达式返回的是true还是false,它都会去执行第二个表达式\n\n      |      按位或\n                                            \n                                                   1 0 1 0\n                                             &    1 1 0 1\n                                             -------------------\n                                                    1 1 1 1\n      ^      异或\n                        相同为 0 不同为1\n\n                        1 0 1 0  ^  1 1 1 1 = 0101^1111=1010\n                        一个数连续异或同一个数两次还是它本身\n\n                        异或的应用:可以用来加密操作\n")])])]),a("p",[n._v("位移的运算效率比较高\n<<    左移:           110        2<<3   = 0000  0010-------\x3e1 0000=16\n面试题:以最快的方式计算出4的3次方是多少\n4<<4\n结论1:左移1位相当于乘以2")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("      >>    右移   在最高位补符号位\n                     0000  1000   ---\x3e8>>2------\x3e0000 0010    \n                              结论2:右移1位相当于除以2\n                     0000   1010   ---\x3e10>>3------\x3e1\n                     1000    1010   -----\x3e138>>3-----\x3e17\n\n      >>>  不带符号右移 永远在最高位补0\n                  1000  1010    -------\x3e138>>>3-------\x3e0001 0001----\x3e17\n      ~  取反\n")])])]),a("p",[n._v("负数在计算机当中是以补码的方式存在\n补码=原码取反+1")]),n._v(" "),a("p",[n._v("计算-6的二进制"),a("br"),n._v("\n0000   0110\n~           1111   1001\n+                           1\n---------------------------------\n1111 1010\n~            0000 0101--------------\x3e5\n----------------------------\n结论:-6 = ~5      ~x = -(x+1)")]),n._v(" "),a("p",[n._v("条件判断语句\n语法:\nif(..布尔表达式.){\n.....\n}else{\n......\n}")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("                          if(...){\n                                  \n                          }else if(){\n                            \n                          }else{\n                                \n                          }\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);