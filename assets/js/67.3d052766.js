(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{554:function(t,n,a){"use strict";a.r(n);var s=a(6),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"条例4-使用私有构造函数来强制不可实例化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条例4-使用私有构造函数来强制不可实例化"}},[t._v("#")]),t._v(" 条例4：使用私有构造函数来强制不可实例化")]),t._v(" "),a("p",[t._v("有时你想编写一个只包含一组静态方法和静态字段的类。这样的类名声不太好，因为一些人骂它们避免以对象的方式来思考，但是\n他们确实是可以合法使用的。他们可以被用来对原始类型值或数组上的相关方法进行分组，比如像"),a("code",[t._v("java.lang.Math")]),t._v("和"),a("code",[t._v("java.util.Arrays")]),t._v("\n那样类。他们可以用来对静态方法进行分组，包括工厂方法用在那些实现了某些接口的类。比如像"),a("code",[t._v("java.util.Collections")]),t._v("那样。\n（从java8开始可以把这样的方法放到接口中，假你要修改）。最后，这样的类可以被用来对final类中的方法进行分组，因为你不能\n将它们放到子类中。")]),t._v(" "),a("p",[t._v("这样的工具类不是为了实例化而设计的。创建它们的实例将是荒谬的。在没有显式构造函数的时候，然而编译器提供了一个公共的无参\n构造函数。对使用者来说，这个构造函数和其他的并没有区别。已发布的API中意外被实例化的类并不少见。")]),t._v(" "),a("p",[t._v("设置为抽象类来强制类不可实例化并不能奏效。类可以被继承，子类可以被实例化。甚者，它误导使用者认为类设计成抽象是为了用于继承。\n然而有个简单的惯用方法来确保不可实例化。默认的构造函数只有在类不包含显式构造函数的时候才会产生，所以类可以通过包含一个私有的\n构造函数来避免实例化。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//不可实例化的utility类\npublic class UtilityClass {\n    //压制默认构造让其不可实例化\n    private UtilityClass() {\n        throw new AssertionError();\n    }\n    //剩下的\n}\n")])])]),a("p",[t._v("因为显式的构造函数是私有的，在类的外部不能访问。"),a("code",[t._v("AssertionError")]),t._v("不是严格需要的，但是它确保构造函数在类内部被\n意外调用的场景。它确保类在任何情况都不会被实例化。这个惯用技巧有点违反直觉，因为构造函数是显式提供的，但是不能\n被调用。所以包含一个注释是明智的，正如上面做的那样。")]),t._v(" "),a("p",[t._v("这样惯用技巧带来的副作用是这个类不能被继承。所有的构造函数必须调用父类的构造函数，隐式地或显式地。本例中的子类\n将不能调用父类的构造函数。")])])}),[],!1,null,null,null);n.default=e.exports}}]);