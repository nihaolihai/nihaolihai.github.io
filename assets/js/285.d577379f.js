(window.webpackJsonp=window.webpackJsonp||[]).push([[285],{777:function(v,_,e){"use strict";e.r(_);var n=e(6),p=Object(n.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"java面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java面试题"}},[v._v("#")]),v._v(" Java面试题")]),v._v(" "),e("ul",[e("li",[v._v("Collection 和 Collections 有什么区别？")])]),v._v(" "),e("p",[v._v("Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\nCollections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。")]),v._v(" "),e("ul",[e("li",[v._v("如何实现数组和 List 之间的转换？")])]),v._v(" "),e("p",[v._v("数组转 List：使用 Arrays. asList(array) 进行转换。\nList 转数组：使用 List 自带的 toArray() 方法。")]),v._v(" "),e("ul",[e("li",[v._v("说说List,Set,Map三者的区别？")])]),v._v(" "),e("p",[v._v("List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象")]),v._v(" "),e("p",[v._v("Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。")]),v._v(" "),e("p",[v._v("Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。")]),v._v(" "),e("ul",[e("li",[v._v("说说List,Set,Map三者的区别？")])]),v._v(" "),e("p",[v._v("List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象")]),v._v(" "),e("p",[v._v("Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。")]),v._v(" "),e("p",[v._v("Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。")]),v._v(" "),e("ul",[e("li",[v._v("Arraylist 与 LinkedList 区别?")])]),v._v(" "),e("p",[v._v("是否保证线程安全：")]),v._v(" "),e("p",[v._v("ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全;")]),v._v(" "),e("p",[v._v("2.底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。")]),v._v(" "),e("p",[v._v("3.插入和删除是否受元素位置的影响：")]),v._v(" "),e("p",[v._v("① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候，ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。")]),v._v(" "),e("p",[v._v("② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置影响，都是近似 O（1）而数组为近似 O（n）。")]),v._v(" "),e("p",[v._v("4.是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。")]),v._v(" "),e("p",[v._v("5.内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。")]),v._v(" "),e("p",[v._v("补充内容:双向链表和双向循环链表\n双向链表： 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。")]),v._v(" "),e("p",[v._v("双向循环链表： 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。")]),v._v(" "),e("p",[v._v("ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？\nVector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。")]),v._v(" "),e("p",[v._v("Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。")]),v._v(" "),e("ul",[e("li",[v._v("HashMap 和 Hashtable 的区别")])]),v._v(" "),e("p",[v._v("线程是否安全：")]),v._v(" "),e("p",[v._v("HashMap 是非线程安全的，HashTable 是线程安全的；HashTable内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\n效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\n对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap中的tableSizeFor()方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。\n底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。")]),v._v(" "),e("ul",[e("li",[v._v("HashSet如何检查重复")])]),v._v(" "),e("p",[v._v("当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。")]),v._v(" "),e("ul",[e("li",[v._v("hashCode（）与equals（）的相关规定：")])]),v._v(" "),e("p",[v._v("如果两个对象相等，则hashcode一定也是相同的\n两个对象相等,对两个equals方法返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n综上，equals方法被覆盖过，则hashCode方法也必须被覆盖\nhashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。")]),v._v(" "),e("ul",[e("li",[v._v("HashMap的底层实现\nJDK1.8之前\nJDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。")])]),v._v(" "),e("p",[v._v("所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。")]),v._v(" "),e("ul",[e("li",[v._v("Collection")])]),v._v(" "),e("ol",[e("li",[v._v("List")])]),v._v(" "),e("p",[v._v("Arraylist： Object数组")]),v._v(" "),e("p",[v._v("Vector： Object数组")]),v._v(" "),e("p",[v._v("LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)")]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[v._v("Set")])]),v._v(" "),e("p",[v._v("HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素")]),v._v(" "),e("p",[v._v("LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的")]),v._v(" "),e("p",[v._v("LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。")]),v._v(" "),e("p",[v._v("TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)")]),v._v(" "),e("p",[v._v("3.Map")]),v._v(" "),e("p",[v._v("HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间")]),v._v(" "),e("p",[v._v("LinkedHashMap：")]),v._v(" "),e("p",[v._v("LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。")]),v._v(" "),e("p",[v._v("Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的")]),v._v(" "),e("p",[v._v("TreeMap： 红黑树（自平衡的排序二叉树）")]),v._v(" "),e("ul",[e("li",[v._v("tcp 为什么要三次握手，两次不行吗？为什么？")])]),v._v(" "),e("p",[v._v("如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。")]),v._v(" "),e("ul",[e("li",[v._v("get 和 post 请求有哪些区别？")])]),v._v(" "),e("p",[v._v("get 请求会被浏览器主动缓存，而 post 不会。")]),v._v(" "),e("p",[v._v("get 传递参数有大小限制，而 post 没有。")]),v._v(" "),e("p",[v._v("post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。")]),v._v(" "),e("ul",[e("li",[v._v("为什么要使用 spring？")])]),v._v(" "),e("p",[v._v("spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。")]),v._v(" "),e("p",[v._v("spring 提供了事务支持，使得事务操作变的更加方便。")]),v._v(" "),e("p",[v._v("spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。\n更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。")]),v._v(" "),e("ul",[e("li",[v._v("解释一下什么是 aop？")])]),v._v(" "),e("p",[v._v("aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。")]),v._v(" "),e("p",[v._v("简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。")]),v._v(" "),e("ul",[e("li",[v._v("解释一下什么是 ioc？")])]),v._v(" "),e("p",[v._v("ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。")]),v._v(" "),e("p",[v._v("简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。")]),v._v(" "),e("ul",[e("li",[v._v("spring 有哪些主要模块？")])]),v._v(" "),e("p",[v._v("spring core：框架的最基础部分，提供 ioc 和依赖注入特性。")]),v._v(" "),e("p",[v._v("spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。")]),v._v(" "),e("p",[v._v("spring dao：Data Access Object 提供了JDBC的抽象层。")]),v._v(" "),e("p",[v._v("spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。")]),v._v(" "),e("p",[v._v("spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。")]),v._v(" "),e("p",[v._v("spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。")]),v._v(" "),e("ul",[e("li",[v._v("spring 常用的注入方式有哪些？")])]),v._v(" "),e("p",[v._v("setter 属性注入")]),v._v(" "),e("p",[v._v("构造方法注入")]),v._v(" "),e("p",[v._v("注解方式注入")]),v._v(" "),e("ul",[e("li",[v._v("spring 中的 bean 是线程安全的吗？\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。")])]),v._v(" "),e("p",[v._v("实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。")]),v._v(" "),e("p",[v._v("有状态就是有数据存储功能。\n无状态就是不会保存数据。\nspring 支持几种 bean 的作用域？\nspring 支持 5 种作用域，如下：")]),v._v(" "),e("p",[v._v("singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；\nprototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；\nWeb 环境下的作用域：\nrequest：每次 http 请求都会创建一个 bean；\nsession：同一个 http session 共享一个 bean 实例；\nglobal-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。\n注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。")]),v._v(" "),e("ul",[e("li",[v._v("spring 自动装配 bean 有哪些方式？")])]),v._v(" "),e("p",[v._v("no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。")]),v._v(" "),e("p",[v._v("byName：它根据 bean 的名称注入对象依赖项。")]),v._v(" "),e("p",[v._v("byType：它根据类型注入对象依赖项。")]),v._v(" "),e("p",[v._v("构造函数：通过构造函数来注入依赖项，需要设置大量的参数。")]),v._v(" "),e("p",[v._v("autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。")]),v._v(" "),e("ul",[e("li",[v._v("spring 事务实现方式有哪些？\n声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。")])]),v._v(" "),e("p",[v._v("编码方式：提供编码的形式管理和维护事务。")]),v._v(" "),e("ul",[e("li",[v._v("说一下 spring mvc 运行流程？")])]),v._v(" "),e("p",[v._v("spring mvc 先将请求发送给 DispatcherServlet。")]),v._v(" "),e("p",[v._v("DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。")]),v._v(" "),e("p",[v._v("DispatcherServlet 再把请求提交到对应的 Controller。")]),v._v(" "),e("p",[v._v("Controller 进行业务逻辑处理后，会返回一个ModelAndView。")]),v._v(" "),e("p",[v._v("Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。")]),v._v(" "),e("p",[v._v("视图对象负责渲染返回给客户端。")]),v._v(" "),e("ul",[e("li",[v._v("spring mvc 有哪些组件？")])]),v._v(" "),e("p",[v._v("前置控制器 DispatcherServlet。")]),v._v(" "),e("p",[v._v("映射控制器 HandlerMapping。")]),v._v(" "),e("p",[v._v("处理器 Controller。")]),v._v(" "),e("p",[v._v("模型和视图 ModelAndView。")]),v._v(" "),e("p",[v._v("视图解析器 ViewResolver。")]),v._v(" "),e("ul",[e("li",[v._v("Springmvc的优点:")])]),v._v(" "),e("p",[v._v("（1）可以支持各种视图技术,而不仅仅局限于JSP；")]),v._v(" "),e("p",[v._v("（2）与Spring框架集成（如IoC容器、AOP等）；")]),v._v(" "),e("p",[v._v("（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。")]),v._v(" "),e("p",[v._v("（4） 支持各种请求资源的映射策略。")]),v._v(" "),e("ul",[e("li",[v._v("SpringMVC常用的注解有哪些？")])]),v._v(" "),e("p",[v._v("RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。")]),v._v(" "),e("p",[v._v("RequestBody：注解实现接收http请求的json数据，将json转换为java对象。")]),v._v(" "),e("p",[v._v("ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。")]),v._v(" "),e("ul",[e("li",[v._v("MyBatis 中 #{}和 ${}的区别是什么？")])]),v._v(" "),e("p",[v._v("#{}是预编译处理，")]),v._v(" "),e("p",[v._v("${}是字符替换。 在使用")]),v._v(" "),e("p",[v._v("#{}时，MyBatis 会将 SQL 中的")]),v._v(" "),e("p",[v._v("#{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。")]),v._v(" "),e("p",[v._v("MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。")]),v._v(" "),e("ul",[e("li",[v._v("什么是 spring cloud？")])]),v._v(" "),e("p",[v._v("spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。")]),v._v(" "),e("ul",[e("li",[v._v("spring cloud 断路器的作用是什么？")])]),v._v(" "),e("p",[v._v("在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。")]),v._v(" "),e("ul",[e("li",[v._v("spring cloud 的核心组件有哪些？")])]),v._v(" "),e("p",[v._v("Eureka：服务注册于发现。")]),v._v(" "),e("p",[v._v("Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。")]),v._v(" "),e("p",[v._v("Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。")]),v._v(" "),e("p",[v._v("Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。")]),v._v(" "),e("p",[v._v("Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。")]),v._v(" "),e("ul",[e("li",[v._v("SpringCloud和Dubbo")])]),v._v(" "),e("p",[v._v("SpringCloud和Dubbo都是现在主流的微服务架构\nSpringCloud是Apache旗下的Spring体系下的微服务解决方案\nDubbo是阿里系的分布式服务治理框架\n从技术维度上,其实SpringCloud远远的超过Dubbo,Dubbo本身只是实现了服务治理,而SpringCloud现在以及有21个子项目以后还会更多\n所以其实很多人都会说Dubbo和SpringCloud是不公平的\n但是由于RPC以及注册中心元数据等原因,在技术选型的时候我们只能二者选其一,所以我们常常为用他俩来对比\n服务的调用方式Dubbo使用的是RPC远程调用,而SpringCloud使用的是 Rest API,其实更符合微服务官方的定义\n服务的注册中心来看,Dubbo使用了第三方的ZooKeeper作为其底层的注册中心,实现服务的注册和发现,SpringCloud使用Spring Cloud Netflix Eureka实现注册中心,当然SpringCloud也可以使用ZooKeeper实现,但一般我们不会这样做\n服务网关,Dubbo并没有本身的实现,只能通过其他第三方技术的整合,而SpringCloud有Zuul路由网关,作为路由服务器,进行消费者的请求分发,SpringCloud还支持断路器,与git完美集成分布式配置文件支持版本控制,事务总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素")]),v._v(" "),e("p",[v._v("从技术选型上讲~")]),v._v(" "),e("p",[v._v("目前国内的分布式系统选型主要还是Dubbo毕竟国产,而且国内工程师的技术熟练程度高,并且Dubbo在其他维度上的缺陷可以由其他第三方框架进行集成进行弥补\n而SpringCloud目前是国外比较流行,当然我觉得国内的市场也会慢慢的偏向SpringCloud,就连刘军作为Dubbo重启的负责人也发表过观点,Dubbo的发展方向是积极适应SpringCloud生态,并不是起冲突")]),v._v(" "),e("p",[v._v("Rest和RPC对比")]),v._v(" "),e("p",[v._v("其实如果仔细阅读过微服务提出者马丁福勒的论文的话可以发现其定义的服务间通信机制就是Http Rest\nRPC最主要的缺陷就是服务提供方和调用方式之间依赖太强,我们需要为每一个微服务进行接口的定义,并通过持续继承发布,需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突\n而REST是轻量级的接口,服务的提供和调用不存在代码之间的耦合,只是通过一个约定进行规范,但也有可能出现文档和接口不一致而导致的服务集成问题,但可以通过swagger工具整合,是代码和文档一体化解决,所以REST在分布式环境下比RPC更加灵活\n这也是为什么当当网的DubboX在对Dubbo的增强中增加了对REST的支持的原因")]),v._v(" "),e("p",[v._v("文档质量和社区活跃度")]),v._v(" "),e("p",[v._v("SpringCloud社区活跃度远高于Dubbo,毕竟由于梁飞团队的原因导致Dubbo停止更新迭代五年,而中小型公司无法承担技术开发的成本导致Dubbo社区严重低落,而SpringCloud异军突起,迅速占领了微服务的市场,背靠Spring混的风生水起\nDubbo经过多年的积累文档相当成熟,对于微服务的架构体系各个公司也有稳定的现状")]),v._v(" "),e("ul",[e("li",[v._v("SpringBoot和SpringCloud")])]),v._v(" "),e("p",[v._v("SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务\n而SpringCloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等\n技术维度并相同,并且SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发")]),v._v(" "),e("p",[v._v("总结:")]),v._v(" "),e("p",[v._v("SpringBoot专注于快速方便的开发单个个体的微服务")]),v._v(" "),e("p",[v._v("SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务")]),v._v(" "),e("p",[v._v("SpringBoot不依赖于SpringCloud,SpringCloud依赖于SpringBoot,属于依赖关系")]),v._v(" "),e("p",[v._v("SpringBoot专注于快速,方便的开发单个的微服务个体,SpringCloud关注全局的服务治理框架")]),v._v(" "),e("ul",[e("li",[v._v("微服务之间是如何独立通讯的")])]),v._v(" "),e("p",[v._v("1.远程过程调用（Remote Procedure Invocation）：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[v._v("   也就是我们常说的服务的注册与发现\n\n   直接通过远程过程调用来访问别的service。\n\n   优点：\n\n   简单，常见,因为没有中间件代理，系统更简单\n\n   缺点：\n\n   只支持请求/响应的模式，不支持别的，比如通知、请求/异步响应、发布/订阅、发布/异步响应\n\n   降低了可用性，因为客户端和服务端在请求过程中必须都是可用的\n")])])]),e("p",[v._v("2.消息：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[v._v("   使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。\n\n   优点:\n\n   把客户端和服务端解耦，更松耦合\n\n   提高可用性，因为消息中间件缓存了消息，直到消费者可以消费\n\n   支持很多通信机制比如通知、请求/异步响应、发布/订阅、发布/异步响应\n\n   缺点:\n\n   消息中间件有额外的复杂\n")])])]),e("ul",[e("li",[v._v("负载均衡的意义是什么?")])]),v._v(" "),e("p",[v._v("在计算中，负载均衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载均衡旨在优化资源使用，最大吞吐量，最小响应时间并避免任何单一资源的过载。使用多个组件进行负载均衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务进程。")]),v._v(" "),e("ul",[e("li",[v._v("springcloud如何实现服务的注册?")])]),v._v(" "),e("p",[v._v("1.服务发布时，指定对应的服务名,将服务注册到 注册中心(eureka zookeeper)\n2.注册中心加@EnableEurekaServer,服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接的调用发现。")]),v._v(" "),e("ul",[e("li",[v._v("什么是服务熔断?什么是服务降级")])]),v._v(" "),e("p",[v._v("在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩")]),v._v(" "),e("p",[v._v("为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。")]),v._v(" "),e("p",[v._v('所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝"当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。')]),v._v(" "),e("p",[v._v("服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池,当线程达到阈值的时候就启动服务降级,如果其他请求继续访问就直接返回fallback的默认值")]),v._v(" "),e("ul",[e("li",[v._v("微服务的优缺点分别是什么?说下你在项目开发中碰到的坑")])]),v._v(" "),e("p",[v._v("优点")]),v._v(" "),e("p",[v._v("每一个服务足够内聚,代码容易理解")]),v._v(" "),e("p",[v._v("开发效率提高,一个服务只做一件事")]),v._v(" "),e("p",[v._v("微服务能够被小团队单独开发")]),v._v(" "),e("p",[v._v("微服务是松耦合的,是有功能意义的服务")]),v._v(" "),e("p",[v._v("可以用不同的语言开发,面向接口编程")]),v._v(" "),e("p",[v._v("易于与第三方集成")]),v._v(" "),e("p",[v._v("微服务只是业务逻辑的代码,不会和HTML,CSS或者其他界面组合")]),v._v(" "),e("p",[v._v("开发中,两种开发模式\n前后端分离\n全栈工程师")]),v._v(" "),e("p",[v._v("可以灵活搭配,连接公共库/连接独立库")]),v._v(" "),e("p",[v._v("缺点")]),v._v(" "),e("p",[v._v("分布式系统的负责性")]),v._v(" "),e("p",[v._v("多服务运维难度,随着服务的增加,运维的压力也在增大")]),v._v(" "),e("p",[v._v("系统部署依赖")]),v._v(" "),e("p",[v._v("服务间通信成本")]),v._v(" "),e("p",[v._v("数据一致性")]),v._v(" "),e("p",[v._v("系统集成测试")]),v._v(" "),e("p",[v._v("性能监控")]),v._v(" "),e("ul",[e("li",[v._v("你所知道的微服务技术栈？")])]),v._v(" "),e("p",[v._v("维度(springcloud)")]),v._v(" "),e("p",[v._v("服务开发：springboot spring springmvc")]),v._v(" "),e("p",[v._v("服务配置与管理:Netfix公司的Archaiusm ,阿里的Diamond")]),v._v(" "),e("p",[v._v("服务注册与发现:Eureka,Zookeeper")]),v._v(" "),e("p",[v._v("服务调用:Rest RPC gRpc")]),v._v(" "),e("p",[v._v("服务熔断器:Hystrix")]),v._v(" "),e("p",[v._v("服务负载均衡:Ribbon Nginx")]),v._v(" "),e("p",[v._v("服务接口调用:Fegin")]),v._v(" "),e("p",[v._v("消息队列:Kafka Rabbitmq activemq")]),v._v(" "),e("p",[v._v("服务配置中心管理:SpringCloudConfig")]),v._v(" "),e("p",[v._v("服务路由（API网关）Zuul")]),v._v(" "),e("p",[v._v("事件消息总线:SpringCloud Bus")]),v._v(" "),e("ul",[e("li",[v._v("Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别")])]),v._v(" "),e("p",[v._v("1.ZooKeeper保证的是CP,Eureka保证的是AP")]),v._v(" "),e("p",[v._v("ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的")]),v._v(" "),e("p",[v._v("Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的")]),v._v(" "),e("p",[v._v("自我保护机制会导致")]),v._v(" "),e("p",[v._v("Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务")]),v._v(" "),e("p",[v._v("Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)")]),v._v(" "),e("p",[v._v("当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)")]),v._v(" "),e("p",[v._v("Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪")]),v._v(" "),e("p",[v._v("2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等")]),v._v(" "),e("p",[v._v("3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题")]),v._v(" "),e("p",[v._v("4.Eureka本质上是一个工程,而ZooKeeper只是一个进程")]),v._v(" "),e("ul",[e("li",[v._v("eureka自我保护机制是什么?")])]),v._v(" "),e("p",[v._v("当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。")]),v._v(" "),e("ul",[e("li",[v._v("什么是Ribbon？")])]),v._v(" "),e("p",[v._v("ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。")]),v._v(" "),e("ul",[e("li",[v._v("什么是feigin？它的优点是什么？\n1.feign采用的是基于接口的注解\n2.feign整合了ribbon，具有负载均衡的能力\n3.整合了Hystrix，具有熔断的能力")])]),v._v(" "),e("p",[v._v("使用:\n1.添加pom依赖。\n2.启动类添加@EnableFeignClients\n3.定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务")]),v._v(" "),e("ul",[e("li",[v._v("Ribbon和Feign的区别？")])]),v._v(" "),e("p",[v._v("1.Ribbon都是调用其他服务的，但方式不同。\n2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients\n3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。\n4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。")]),v._v(" "),e("ul",[e("li",[v._v("什么是Spring Cloud Bus?")])]),v._v(" "),e("p",[v._v("spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。\n如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。\n使用:\n1.添加依赖\n2.配置rabbimq")]),v._v(" "),e("ul",[e("li",[v._v("什么是Hystrix?")])]),v._v(" "),e("p",[v._v("防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）\n服务降级:\n双十一 提示 哎哟喂，被挤爆了。 app秒杀 网络开小差了，请稍后再试。\n优先核心服务，非核心服务不可用或弱可用。通过HystrixCommand注解指定。\nfallbackMethod(回退函数)中具体实现降级逻辑。")]),v._v(" "),e("ul",[e("li",[v._v("springcloud断路器作用?")])]),v._v(" "),e("p",[v._v("当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）\n断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务\n半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭\n关闭：当服务一直处于正常状态 能正常调用")]),v._v(" "),e("ul",[e("li",[v._v("什么是SpringCloudConfig?")])]),v._v(" "),e("p",[v._v("在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。")]),v._v(" "),e("p",[v._v("使用：\n1、添加pom依赖\n2、配置文件添加相关配置\n3、启动类添加注解@EnableConfigServer")]),v._v(" "),e("ul",[e("li",[v._v("架构？")])]),v._v(" "),e("p",[v._v("在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统")]),v._v(" "),e("p",[v._v("在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。")])])}),[],!1,null,null,null);_.default=p.exports}}]);