(window.webpackJsonp=window.webpackJsonp||[]).push([[238],{736:function(e,t,n){"use strict";n.r(t);var a=n(6),r=Object(a.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"mybatis系统定义的typehandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mybatis系统定义的typehandler"}},[this._v("#")]),this._v(" MyBatis系统定义的TypeHandler")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('MyBatis 内部定义了许多有用的 typeHandler，如表 1 所示。\n\n表 1 系统定义的typeHandler\n类型处理器\tJava类型\tJDBC类型\nBooleanTypeHandler\tjava.lang.Boolean，boolean\t数据库兼容的 BOOLEAN\nByteTypeHandler\tjava.lang.Byte，byte\t数据库兼容的 NUMERIC 或 BYTE\nShortTypeHandler\tjava.lang.Short，short\t数据库兼容的 NUMERIC 或 SHORT INTEGER\nIntegerTypeHandler\tjava.lang.Integer，int\t数据库兼容的 NUMERIC 或 INTEGER\nLongTypeHandler\tjava.lang.Long，long\t数据库兼容的 NUMERIC 或 LONG INTEGER\nFloatTypeHandler\tjava.lang.Float，float\t数据库兼容的 NUMERIC 或 FLOAT\nDoubleTypeHandler\tjava.lang.Double，double\t数据库兼容的 NUMERIC 或 DOUBLE\nBigDecimalTypeHandler\tjava.math.BigDecimal\t数据库兼容的 NUMERIC 或 DECIMAL\nStringTypeHandler\tjava.lang.String\tCHAR、VARCHAR\nClobReaderTypeHandler\tjava.io.Reader\t——\nClobTypeHandler\tjava.lang.String\tCLOB、LONGVARCHAR\nNStringTypeHandler\tjava.lang.String\tNVARCHAR、NCHAR\nNClobTypcHandler\tjava.lang.String\tNCLOB\nBlobInputStreamTypeHandler\tjava.io.InputStream\t——\nByteArrayTypeHandler\tbyte[]\t数据库兼容的字节流类型\nBlobTypeHandler\tbyte[]\tBLOB、LONGVARBINARY\nDateTypeHandler\tjava.util.Date\tTIMESTAMP\nDateOnlyTypeHandler\tjava.util.Date\tDATE\nTimeOnlyTypeHandler\tjava.util.Date\tTIME\nSqlTimestampTypeHandler\tjava.sql.Timestamp\tTIMESTAMP\nSqlDateTypeHandler \tjava.sql.Date \tDATE\nSqlTimeTypeHandler\tjava.sql.Time\tTIME\nObjectTypeHandler\tAny\tOTHER或未指定类型\nEnumTypeHandler\tEnumeration Type\tVARCHAR 任何兼容的字符串类型，存储枚举的名称（而不是索引）\nEnumOrdinalTypeHandler\tEnumeration Type\t任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）\n这些就是 MyBatis 系统已经创建好的 typeHandler。在大部分的情况下无须显式地声明 jdbcType 和 javaType，或者用 typeHandler 去指定对应的 typeHandler 来实现数据类型转换，因为 MyBatis 系统会自己探测。有时候需要修改一些转换规则，比如枚举类往往需要自己去编写规则。\n\n在 MyBatis 中 typeHandler 都要实现接口 org.apache.ibatis.type.TypeHandler，首先让我们先看看这个接口的定义，如下所示。\npublic interface TypeHandler<T>\n    void setParameter(PreparedStatement ps, int i, T parameter, jdbcType jdbcType)\n    throws SQLException;\n    T getResult(ResultSet rs, String columnName) throws SQLException;\n    T getResult(ResultSet rs, int columnIndex) throws SQLException;\n    T getResult(CallableStatement cs, int columnIndex) throws SQLException;\n}\n\n这里我们稍微说明一下它的定义。\n\n其中 T 是泛型，专指 javaType，比如我们需要 String 的时候，那么实现类可以写为 implements TypeHandler<String>。\n\nsetParameter 方法，是使用 typeHandler 通过 PreparedStatement 对象进行设置 SQL 参数的时候使用的具体方法，其中 i 是参数在 SQL 的下标，parameter 是参数，jdbcType 是数据库类型。\n\n其中有 3 个 getResult 的方法，它的作用是从 JDBC 结果集中获取数据进行转换，要么使用列名（columnName）要么使用下标（columnIndex）获取数据库的数据，其中最后一个 getResult 方法是存储过程专用的。\n\n在编写 typeHandler 前，先来研究一下 MyBatis 系统的 typeHandler 是如何实现的，所以有必要先研究一下 MyBatis 系统的 typeHandler。如果读者打开源码，就可以发现它们都继承了 org.apache.ibatis.type.BaseTypeHandler，如下所示。\npublic abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {\n    protected Configuration configuration;\n    public void setConfiguration(Configuration c) {\n        this.configuration = c;\n    }\n    @Override\n    public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {\n        if (parameter == null) {\n            if (jdbcType == null) {\n                throw new TypeException("JDBC requires that the JdbcType must be specified for all nullable parameters.");\n            }\n            try {\n                ps.setNull(i, jdbcType.TYPE_CODE);\n            } catch (SQLException e) {\n                throw new TypeException("Error setting null for parameter #" + i + " with JdbcType " + jdbcType + " . " + "Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. " + "Cause: " + e, e);\n            }\n        } else {\n            try {\n                setNonNullParameter(ps, i, parameter, jdbcType);\n            } catch (Exception e) {\n                throw new TypeException("Error setting non null for parameter #" + i + " with JdbcType " + jdbcType + " . " + "Try setting a different JdbcType for this parameter or a different configuration property. " + "Cause: " + e, e);\n            }\n        }\n    }\n    @Override\n    public T getResult(ResultSet rs, String columnName) throws SQLException {\n        T result;\n        try {\n            result = getNullableResult(rs, columnName);\n        } catch (Exception e) {\n            throw new ResultMapException("Error attempting to get column \'" + columnName + "\' from result set.Cause: " + e, e);\n        }\n        if (rs.wasNull()) {\n            return null;\n        } else {\n            return result;\n        }\n    }\n    @Override\n    public T getResult(ResultSet rs, int columnIndex) throws SQLException {\n        T result;\n        try {\n            result = getNullableResult(rs, columnIndex);\n        } catch (Exception e) {\n            throw new ResultMapException("Error attempting to get column #" + columnIndex+ " from result set.Cause: " + e, e);\n        }\n        if (rs.wasNull()) {\n            return null;\n        } else {\n            return result;\n        }\n    }\n    @Override\n    public T getResult(CallableStatement cs, int columnIndex) throws SQLException {\n        T result;\n        try {\n            result = getNullableResult(cs, columnIndex);\n        } catch (Exception e) {\n            throw new ResultMapException("Error attempting to get column #" + columnIndex+ " from callable statement.Cause: " + e, e);\n        }\n        if (cs.wasNull()) {\n            return null;\n        } else {\n            return result;\n        }\n    }\n    public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;\n    public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;\n    public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;\n    public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException;\n}\n简单分析一下 BaseTypeHandler 的源码。\nBaseTypeHandler 是个抽象类，需要子类去实现其定义的 4 个抽象方法，而它本身实现了 typeHandler 接口的 4 个方法。\ngetResult 方法，非空结果集是通过 getNullableResult 方法获取的。如果判断为空，则返回 null。\nsetParameter 方法，当参数 parameter 和 jdbcType 同时为空时，MyBatis 将抛出异常。如果能明确 jdbcType，则会进行空设置；如果参数不为空，那么它将采用 setNonNullParameter 方法设置参数。\ngetNullableResult 方法用于存储过程。\n\nMyBatis 使用最多的 typeHanlder 之一 —— StringTypeHandler。它用于字符串转换，其源码如下所示。\n@Override\npublic void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)\n      throws SQLException {\n    ps.setString(i, parameter);\n}\n@Override\npublic String getNullableResult(ResultSet rs, String columnName)\n      throws SQLException {\n    return rs.getString(columnName);\n}\n@Override\npublic String getNullableResult(ResultSet rs, int columnIndex)\n      throws SQLException {\n    return rs.getString(columnIndex);\n}\n@Override\npublic String getNullableResult(CallableStatement cs, int columnIndex)\n      throws SQLException {\n    return cs.getString(columnIndex);\n}\n显然它实现了 BaseTypeHandler 的 4 个抽象方法，代码也非常简单。\n\n在这里，MyBatis 把 javaType 和 jdbcType 相互转换，那么它们是如何注册的呢？在 MyBatis 中采用 org.apache.ibatis.type.TypeHandlerRegistry 类对象的 register 方法进行注册，如下所示。 \npublic TypeHandlerRegistry()  {\n    register(Boolean.class, new BooleanTypeHandler());\n    register(boolean.class, new BooleanTypeHandler());\n    ....\n    register(byte[].class, jdbcType.BLOB, new BlobTypeHandler());\n    register(byte[].class, jdbcType.LONGVARBINARY, new BlobTypeHandler());\n    ....\n}\n这样就实现了用代码的形式注册 typeHandler。注意，自定义的 typeHandler 一般不会使用代码注册，而是通过配置或扫描，下一节我们开始学习MyBatis自定义TypeHandler。\n\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);