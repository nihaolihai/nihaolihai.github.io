(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{546:function(e,n,v){"use strict";v.r(n);var _=v(6),a=Object(_.a)({},(function(){var e=this,n=e.$createElement,v=e._self._c||n;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"条例1-优先考虑静态工厂方法而不是构造函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#条例1-优先考虑静态工厂方法而不是构造函数"}},[e._v("#")]),e._v(" 条例1： 优先考虑静态工厂方法而不是构造函数")]),e._v(" "),v("p",[e._v("要让类的使用者能获取类的实例，通常类会提供一个公共的构造函数。有另一项技术应该纳入到每个程序员的工具集中。\n类可以提供一个公共的静态工厂方法，静态工厂方法简单来说就是返回类的一个实例的静态方法。下面是Boolean类（布尔类型的装箱原始类）的简单\n示例。这个方法将布尔类型原始值转换为一个Boolean对象的引用。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("public static Boolean valueOf(boolean b) {\n  return b ? Boolean.TRUE: Boolean.FALSE;\n}\n")])])]),v("p",[e._v("注意静态工厂方法和设计模式中的工厂方法模式不是一回事。本条例中描述的静态工厂方法和设计模式中的工厂方法模式没有直接的等价关系。\n类可以直接向客户端提供静态工厂方法以替代公有构造函数，或者同时提供两者。使用静态工厂方法替代公共构造函数优缺点并存。")]),e._v(" "),v("p",[e._v("静态工厂方法相比构造函数的一个优点是，他们有命名。如果构造函数的参数本身不能描述返回的对象。命名得当的静态工厂方法更具有\n可读性，使用方的代码也更具可读性。比如，构造函数"),v("code",[e._v("BigInteger(int, int, Random)")]),e._v("返回一个可能是素数的"),v("code",[e._v("BigInteger")]),e._v("，使用\n命名为"),v("code",[e._v("BigInteger.probablePrime")]),e._v("的静态工厂方法具有更好的表达性。")]),e._v(" "),v("p",[e._v("一个类只能有一个相同签名的构造函数。程序员们都知道编写两个函数以绕过这个限制，而这两个构造函数的差别仅在参数列表中的参数类型顺序不同。\n这真是个糟糕的主意。这样的API的使用者将不会记得需要使用哪个构造函数来创建所需的实例，可能最终调用了错误的构造函数。阅读\n使用了这些构造函数的代码的人如果不查看类文档也不会知道这些构造函数的作用。")]),e._v(" "),v("p",[e._v("因为静态工厂方法具有命名，因为它们不会遇到像构造函数那样的限制。在类看起来需要多个相同签名的构造函数的情况下，使用静态工厂方法\n来替换构造函数，并为静态工厂选取合适的命名以强调它们的区别。")]),e._v(" "),v("p",[e._v("静态工厂方法的第二个优点是，与构造函数不同，每次调用的时候并不要求创建一个新对象。这样，不可变类就可以使用预先构造的实例，\n或者在实例构造后将它们缓存起来，后续重复分配他们以避免创建不必要的重复对象。"),v("code",[e._v("Boolean.valueOf(boolean)")]),e._v("方法就演示了这种技术：\n它从不创建对象。这项技术和享元模式类似。如果同样的对象经常被请求，尤其在这些对象的创建代价高昂时，静态工厂方法可以极大地提升性能。")]),e._v(" "),v("p",[e._v("静态工厂对重复调用返回相同的对象的能力使得类可以对任意时刻哪些实例的存在拥有严格的控制。这样的类是实例控制类。有几种原因\n编写实例控制的类。实例控制使得类可以保证它是单实例的或者不可实例化的。同时，它确保拥有不可变值的类不会有两个相等的实例：\n当且仅当"),v("code",[e._v("a == b")]),e._v("时才"),v("code",[e._v("a.equals(b)")]),e._v("。这是享元模式的基础。枚举类型提供了这个保证。")]),e._v(" "),v("p",[e._v("静态工厂方法的第三个优点是，与构造函数不同的是，它们可以返回的对象可以是返回类型子类的对象。这在选择返回对象的类型时拥有极大的弹性。")]),e._v(" "),v("p",[e._v("这种弹性的一个应用是API可以返回那些无需将类公开的对象。以这种方式隐藏实现类促成了一个非常紧凑的API。这项技术适合于基于接口的框架，\n接口提供静态工厂方法的自然返回类型。")]),e._v(" "),v("p",[e._v("在Java8之前，接口中不能有静态方法。通常，接口Type的静态工厂方法会被放在不可实例化的伙伴类Types中。比如，Java集合框架有45个工具类\n实现了接口，提供不可修改的集合，同步集合等的。几乎所有的这些实现类都是通过一个不可实例化的类(java.util.Collections)中的静态工厂方法\n导出的。这些静态方法返回的对象都是非公共的。")]),e._v(" "),v("p",[e._v("集合框架API要比导出45个单独的便捷实现的公共类要小得多，不仅仅是API数量上的减少，同时概念上也更为轻量：程序员使用API所需站不过我的概念的\n数量和难度降低了。程序员知道返回对象具有接口指定的API，因此没有必要阅读关于实现类的额外的类文档。甚者，使用这样的静态工厂方法需要\n使用者使用接口而不是实现类来引用返回的对象，这是相当不错的实践。")]),e._v(" "),v("p",[e._v("从Java8开始，接口不能包含静态方法的限制被取消了，通常几乎没理由再为接口提供不可实例化的伙伴类。许多本来放在伙伴类中的\n公共静态成员现在应该放在接口本身中。但是请注意，仍有必要将这些大量实现代码放在单独的包私有类的这些静态方法后面。这是因为\nJava 8 要求接口的所有静态成员必须是公共的。Java 9允许私有静态方法，但是静态字段和静态成员类仍然需要是公共的。")]),e._v(" "),v("p",[e._v("静态工厂方法的第四个优点是返回对象的类型可以根据每次调用输入参数的不同而不同。声明的返回类型的任何子类型都是允许的。\n返回对象的类也可能因版本而异。")]),e._v(" "),v("p",[v("code",[e._v("EnumSet")]),e._v("类没有公共构造函数，只有静态工厂。在OpenJDK的实现中，这些静态工厂方法返回EnumSet两个子类其中的一个，具体返回\n哪个取决于底层enum类型的大小：如果enum有64个或较少的元素，大多数enum类型都是这样，静态工厂返回一个"),v("code",[e._v("RegularEnumSet")]),e._v("实例，\n基于单一long。如果enum类型有65个或者更多元素，那么工厂方法返回一个"),v("code",[e._v("JumboEnumSet")]),e._v("实例，基于long数组。")]),e._v(" "),v("p",[e._v("这两个实现类的存在对使用者是不可见的。如果RegularEnumSet不再为小型枚举类型提供性能优势。那么可以在未来的版本中将其消除，\n而不会产生副作用。类似的，未来版本可能添加EnumSet的第三个或第四个实现。如果能证明它们性能优势。使用者既不知道也不关系\n它们从工厂中获得的对象的类。它们只关心EnumSet的某个子类。")]),e._v(" "),v("p",[e._v("静态工厂的第五个优点是，返回对象的类在编写包含静态工厂方法的类时没必要存在。如此弹性的静态工厂方法形成了服务提供者框架的\n基础，比如Java数据库连接API(JDBC)。服务提供者框架是一个系统，在这个系统中，提供者实现服务，系统让实现对于使用者可用，\n将使用者和实现解耦。")]),e._v(" "),v("p",[e._v("在服务提供框架中有三个重要的组件：服务接口，代表了实现；提供者注册API，提供者用来注册实现；服务访问API，使用者用其来获取\n服务实例。服务访问API允许使用者指定选择实现的条件。如果没指定条件，API会返回默认实现的实例，或者允许使用者遍历所有的可用\n实现。服务访问API是形成服务提供者框架基础的弹性静态工厂。")]),e._v(" "),v("p",[e._v("服务提供者框架的第四个组件是可选的：服务提供者接口，它描述了生产服务接口实例的工厂对象。如果服务提供者接口不存在，那么\n实现必须通过反射来实例化。在JDBC的例子中，Connection是服务接口的一部分，"),v("code",[e._v("DriverManager.registerDriver")]),e._v("是提供者注册API，\n"),v("code",[e._v("DriverManager.getConnection")]),e._v("是服务访问API，Driver是服务提供者接口。")]),e._v(" "),v("p",[e._v("服务提供者框架模式有许多变体。比如，服务访问API可以比提供者提供更丰富的服务接口给使用者。这是桥接模式。依赖注入框架可以被视为\n强大的服务提供者。从Java 6起，平台包括了通用目的的服务提供者框架，"),v("code",[e._v("java.util.ServiceLoader")]),e._v("，所以你不需要，通常也不应该自己\n编写。JDBC不使用ServiceLoader，因为JDBC早于ServiceLoader前出现。")]),e._v(" "),v("p",[e._v("仅仅提供静态工厂方法的主要限制是没有公共或受保护的构造函数的类不能被继承。比如，在集合框架中，不可能继承任何便捷实现类。\n塞翁失马，焉知非福，它鼓励程序员用组合取代继承。且对于不可变类型来说也是必须的。")]),e._v(" "),v("p",[e._v("静态工厂的第二个缺点是。")])])}),[],!1,null,null,null);n.default=a.exports}}]);