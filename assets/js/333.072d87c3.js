(window.webpackJsonp=window.webpackJsonp||[]).push([[333],{821:function(t,n,e){"use strict";e.r(n);var r=e(6),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud-hystrix缓存与合并请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-hystrix缓存与合并请求"}},[t._v("#")]),t._v(" Spring Cloud Hystrix缓存与合并请求")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('结果缓存\n在 Hystrix 中也为我们提供了方法级别的缓存。通过重写 getCacheKey 来判断是否返回缓存的数据，getCacheKey 可以根据参数来生成。这样，同样的参数就可以都用到缓存了。\n\n改造之前的 MyHystrixCommand，在其中增加 getCacheKey 的重写实现，代码如下所示。\n@Override\nprotected String getCacheKey() {\n    return String.valueOf(this.name);\n}\n在上面的代码中，我们把创建对象时传进来的 name 参数作为缓存的 key。\n\n为了证明能够用到缓存，在 run 方法中加一行输出，在调用多次的情况下，如果控制台只输出了一次，那么可以知道后面的都是走的缓存逻辑，代码如下所示。\n@Override\nprotected String run() {\n    System.err.println("get data");\n    return this.name + ":" + Thread.currentThread().getName();\n}\n执行 main 方法，发现程序报错了，如图 1 所示：\n\n运行结果\n图 1  运行结果\n完整错误信息如下：\nCaused by: java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?\n\n根据错误提示可以知道，缓存的处理取决于请求的上下文，我们必须初始化 Hystrix-RequestContext。\n\n改造 main 方法中的调用代码，初始化 HystrixRequestContext，代码如下所示。\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    HystrixRequestContext context = HystrixRequestContext.initializeContext();\n    String result = new MyHystrixCommand("zhangsan").execute();\n    System.out.println(result);\n    Future<String> future = new MyHystrixCommand("zhangsan").queue();\n    System.out.println(future.get());\n    context.shutdown();\n}\n改造完之后重写执行 main 方法，就可以做正常运行了，输出结果如图 2 所示：\n\n运行结果\n图 2  运行结果\n\n我们可以看到只输出了一次 get data，缓存生效。\n缓存清除\n刚刚我们学习了如何使用 Hystrix 来实现数据缓存功能。有缓存必然就有清除缓存的动作。\n\n当数据发生变动时，必须将缓存中的数据也更新掉，不然就会出现脏数据的问题。同样地，Hystrix 也有清除缓存的功能。\n\n增加一个支持缓存清除的类，代码如下所示。\npublic class ClearCacheHystrixCommand extends HystrixCommand<String> {\n    private final String name;\n    private static final HystrixCommandKey GETTER_KEY = HystrixCommandKey.Factory.asKey("MyKey");\n    public ClearCacheHystrixCommand(String name) {\n        super(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("MyGroup"))\n                .andCommandKey(GETTER_KEY));\n        this.name = name;\n    }\n    public static void flushCache(String name) {\n        HystrixRequestCache.getInstance(GETTER_KEY,HystrixConcurrencyStrategyDefault.getInstance()).clear(name);\n    }\n    @Override\n    protected String getCacheKey() {\n        return String.valueOf(this.name);\n    }\n    @Override\n    protected String run() {\n        System.err.println("get data");\n        return this.name + ":" + Thread.currentThread().getName();\n    }\n    @Override\n    protected String getFallback() {\n        return "失败了 ";\n    }\n}\nflushCache 方法就是清除缓存的方法，通过 HystrixRequestCache 来执行清除操作，根据 getCacheKey 返回的 key 来清除。\n\n修改调用代码来验证清除是否有效果，代码如下所示。\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    HystrixRequestContext context = HystrixRequestContext.initializeContext();\n    String result = new ClearCacheHystrixCommand("zhangsan").execute();\n    System.out.println(result);\n    ClearCacheHystrixCommand.flushCache("zhangsan");\n    Future<String> future = new ClearCacheHystrixCommand("zhangsan").queue();\n    System.out.println(future.get());\n}\n执行两次相同的 key，在第二次执行之前调用缓存清除的方法，也就是说第二次用不到缓存，输出结果如图 3 所示：\n\n运行结果\n图 3  运行结果\n\n由此可以看出，输出两次 get data，这证明缓存确实被清除了。可以把 ClearCache-HystrixCommand.flushCache 这行代码注释掉再执行一次，就会发现只输出了一次 get data，缓存是有效的，输入结果如图 2 所示。\n合并请求\nHystrix 支持将多个请求自动合并为一个请求（代码如下所示），利用这个功能可以节省网络开销，比如每个请求都要通过网络访问远程资源。如果把多个请求合并为一个一起执行，将多次网络交互变成一次，则会极大地节省开销。\npublic class MyHystrixCollapser extends HystrixCollapser<List<String>, String, String> {\n    private final String name;\n    public MyHystrixCollapser(String name) {\n        this.name = name;\n    }\n    @Override\n    public String getRequestArgument() {\n        return name;\n    }\n    @Override\n    protected HystrixCommand<List<String>> createCommand(final Collection<CollapsedRequest<String, String>> requests) {\n        return new BatchCommand(requests);\n    }\n    @Override\n    protected void mapResponseToRequests(List<String> batchResponse,\n            Collection<CollapsedRequest<String, String>> requests) {\n        int count = 0;\n        for (CollapsedRequest<String, String> request : requests) {\n            request.setResponse(batchResponse.get(count++));\n        }\n    }\n    private static final class BatchCommand extends HystrixCommand<List<String>> {\n        private final Collection<CollapsedRequest<String, String>> requests;\n        private BatchCommand(Collection<CollapsedRequest<String, String>> requests) {\n            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"))\n                    .andCommandKey(HystrixCommandKey.Factory.asKey("GetValueForKey")));\n            this.requests = requests;\n        }\n        @Override\n        protected List<String> run() {\n            System.out.println(" 真正执行请求......");\n            ArrayList<String> response = new ArrayList<String>();\n            for (CollapsedRequest<String, String> request : requests) {\n                response.add(" 返回结果 : " + request.getArgument());\n            }\n            return response;\n        }\n    }\n}\n接下来编写测试代码，代码如下所示。\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    HystrixRequestContext context = HystrixRequestContext.initializeContext();\n    Future<String> f1 = new MyHystrixCollapser("zhangsan").queue();\n    Future<String> f2 = new MyHystrixCollapser("zhangsan333").queue();\n    System.out.println(f1.get() + "=" + f2.get());\n    context.shutdown();\n}\n通过 MyHystrixCollapser 创建两个执行任务，按照正常的逻辑肯定是分别执行这两个任务，通过 HystrixCollapser 可以将多个任务合并到一起执行。从输出结果就可以看出，任务的执行是在 run 方法中去做的，输出结果如图 4 所示：\n\n\n')])])]),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR2095423Y5.png",alt:"RUNOOB 图标"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR210000c60.png",alt:"RUNOOB 图标"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR2100S3493.png",alt:"RUNOOB 图标"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190822/5-1ZR210222GD.png",alt:"RUNOOB 图标"}})])])}),[],!1,null,null,null);n.default=a.exports}}]);