(window.webpackJsonp=window.webpackJsonp||[]).push([[253],{745:function(r,n,t){"use strict";t.r(n);var o=t(6),e=Object(o.a)({},(function(){var r=this.$createElement,n=this._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"mybatis多对多关联查询-级联查询"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mybatis多对多关联查询-级联查询"}},[this._v("#")]),this._v(" MyBatis多对多关联查询（级联查询）")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("其实，MyBatis 没有实现多对多级联，这是因为多对多级联可以通过两个一对多级联进行替换。\n\n例如，一个订单可以有多种商品，一种商品可以对应多个订单，订单与商品就是多对多的级联关系，使用一个中间表（订单记录表）就可以将多对多级联转换成两个一对多的关系。\n\n下面以订单和商品（实现“查询所有订单以及每个订单对应的商品信息”的功能）为例讲解多对多级联查询。\n1）创建数据表\n订单表在前面已创建，这里需要创建商品表 product 和订单记录表 orders_detail，创建代码如下：\nCREATE TABLE 'product'(\n    'id' tinyint(2) NOT NULL,\n    'name' varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL,\n    'price' double DEFAULT NULL,\n    PRIMARY KEY ('id')\n)；\nCREATE TABLE 'orders_detail'(\n    'id' tinyint(2) NOT NULL AUTO_INCREMENT,\n    'orders_id' tinyint(2) DEFAULT NULL,\n    'product_id' tinyint(2) DEFAULT NULL,\n    PRIMARY KEY ('id'),\n    KEY 'orders_id' ('orders_id'),\n    KEY 'product_id' ('product_id'),\n    CONSTRAINT 'orders_id' FOREIGN KEY ('orders_id') REFERENCES 'orders' ('id'),\n    CONSTRAINT 'product_id' FOREIGN KEY ('product_id') REFERENCES 'product' ('id')\n);\n2）创建持久化类\n在 myBatisDemo02 应用的 com.po 包中创建数据表 product 对应的持久化类 Product，而中间表 orders_detail 不需要持久化类，但需要在订单表 orders 对应的持久化类 Orders 中添加关联属性。\n\nProduct 的代码如下：\npackage com.po;\nimport java.util.List;\npublic class Product {\n    private Integer id;\n    private String name;\n    private Double price;\n    // 多对多中的一个一对多\n    private List<Orders> orders;\n    // 省略setter和getter方法\n    @Override\n    public String toString() { // 为了方便查看结果，重写了toString方法\n        return \"Product[id=\" + id + \",name=\" + name + \",price=\" + price + \"]\";\n    }\n}\nOrders 的代码如下：\npackage com.po;\nimport java.util.List;\npublic class Orders {\n    private Integer id;\n    private String ordersn;\n    // 多对多中的另一个一对多\n    private List<Product> products;\n    // 省略setter和getter方法\n    @Override\n    public String toString() {\n        return \"Orders[id=\" + id + \",ordersn=\" + ordersn + \",products=\"\n                + products + \"]\";\n    }\n}\n3）创建映射文件\n本实例只需在 com.mybatis 的 OrdersMapper.xml 文件中追加以下配置即可实现多对多级联查询。\n4）创建 POJO 类\n该实例不需要创建 POJO 类。\n5）添加数据操作接口方法\n在 Orders 接口中添加以下接口方法：\npublic List<Orders> selectallOrdersAndProducts();\n\n6）调用接口方法及测试\n在 myBatisDemo02 应用的 com.controller 包中创建 MoreToMoreController 类，在该类中调用第 5 步的接口方法，同时创建测试类 TestMoreToMore。\n\nMoreToMoreController 的代码如下：\npackage com.controller;\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport com.dao.OrdersDao;\nimport com.po.Orders;\n@Controller(\"moreToMoreController\")\npublic class MoreToMoreController {\n    @Autowired\n    private OrdersDao ordersDao;\n    public void test() {\n        List<Orders> os = ordersDao.selectallOrdersAndProducts();\n        for (Orders orders : os) {\n            System.out.println(orders);\n        }\n    }\n}\nTestMoreToMore 的代码如下：\n纯文本复制\npackage com.controller;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class TestMoreToMore {\n    public static void main(String[] args) {\n        ApplicationContext appcon = new ClassPathXmlApplicationContext(\n                \"applicationContext.xml\");\n        MoreToMoreController otm = (MoreToMoreController) appcon\n                .getBean(\"moreToMoreController\");\n        otm.test();\n    }\n}\n\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);