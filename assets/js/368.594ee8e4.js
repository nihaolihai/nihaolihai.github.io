(window.webpackJsonp=window.webpackJsonp||[]).push([[368],{861:function(n,e,t){"use strict";t.r(e);var i=t(6),s=Object(i.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud基于jwt创建统一的认证服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud基于jwt创建统一的认证服务"}},[this._v("#")]),this._v(" Spring Cloud基于JWT创建统一的认证服务")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('相关的代码如下所示。\ncreate table auth_user(\n  id int(4) not null,\n  accessKey varchar(100) not null,\n  secretKey varchar(100) not null,\n  Primary key (id)\n);\nAlter table auth_user comment \'认证用户信息表\';\n这里只有简单的几个字段，若大家有别的需求可以自行去扩展。代码中的 accessKey 和 secretKey 是用户身份的标识。\nJWT 工具类封装\nJWT 的 GitHub 地址是：https://github.com/jwtk/jjwt，依赖配置代码如下所示。\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.7.0</version>\n</dependency>\n\n用工具类进行认证主要有以下几个方法：\n生成 Token。\n检查 Token 是否合法。\n刷新 RSA 公钥以及私钥。\n\n生成 Token 是在进行用户身份认证之后，通过用户的 ID 来生成一个 Token，这个 Token 采用 RSA 加密的方式进行加密，Token 的内容包括用户的 ID 和过期时间。\n\n检查 Token 则是根据调用方带来的 Token 检查是否为合法用户，就是对 Token 进行解密操作，能解密并且在有效期内表示合法，合法则返回用户 ID。\n\n刷新 RSA 公钥及私钥的作用是防止公钥、私钥泄露，公钥、私钥一般是写死的，不过我们可以做成配置的。集成配置管理中心后，可以对公钥、私钥进行动态修改，修改之后需要重新初始化公钥、私钥的对象信息。\n\n获取 Token 代码如下所示。\n/**\n* 获取 Token\n*\n* @param uid 用户 ID\n* @param exp 失效时间, 单位分钟\n* @return\n*/\npublic static String getToken(String uid, int exp) {\n    Long endTime = System.currentTimeMillis() + 1000 * 60 * exp;\n    return Jwts.builder().setSubject(uid).setExpiration(new Date(endTime))\n            .signWith(SignatureAlgorithm.RS512, priKey).compact();\n}\n检查 Token 是否合法代码如下所示。\n/**\n* 检查 Token 是否合法\n*\n* @param token\n* @return JWTResult\n*/\npublic JWTResult checkToken(String token) {\n    try {\n        Claims claims = Jwts.parser().setSigningKey(pubKey).parseClaimsJws(token).getBody();\n        String sub = claims.get("sub", String.class);\n        return new JWTResult(true, sub, "合法请求", ResponseCode.SUCCESS_CODE.getCode());\n    } catch (ExpiredJwtException e) {\n        // 在解析 JWT 字符串时, 如果\'过期时间字段\'已经早于当前时间,\n        // 将会抛出 ExpiredJwtException 异常, 说明本次请求已经失效\n        return new JWTResult(false, null, "token已过期 ", ResponseCode.TOKEN_TIMEOUT_CODE.getCode());\n    } catch (SignatureException e) {\n        // 在解析 JWT 字符串时, 如果密钥不正确, 将会解析失败, 抛出\n        // SignatureException 异常, 说明该 JWT 字符串是伪造的\n        return new JWTResult(false, null, "非法请求", ResponseCode.NO_AUTH_CODE.getCode());\n    } catch (Exception e) {\n        return new JWTResult(false, null, "非法请求", ResponseCode.NO_AUTH_CODE.getCode());\n    }\n}\n完整代码如下所示。\n/**\n* API调用认证工具类，采用RSA加密\n*/\npublic class JWTUtils {\n    private static RSAPrivateKey priKey;\n    private static RSAPublicKey pubKey;\n    private static class SingletonHolder {\n        private static final JWTUtils INSTANCE = new JWTUtils();\n    }\n    public synchronized static JWTUtils getInstance(String modulus, String privateExponent, String publicExponent) {\n        if (priKey == null && pubKey == null) {\n            priKey = RSAUtils.getPrivateKey(modulus, privateExponent);\n            pubKey = RSAUtils.getPublicKey(modulus, publicExponent);\n        }\n        return SingletonHolder.INSTANCE;\n    }\n    public synchronized static void reload(String modulus, String privateExponent, String publicExponent) {\n        priKey = RSAUtils.getPrivateKey(modulus, privateExponent);\n        pubKey = RSAUtils.getPublicKey(modulus, publicExponent);\n    }\n    public synchronized static JWTUtils getInstance() {\n        if (priKey == null && pubKey == null) {\n            priKey = RSAUtils.getPrivateKey(RSAUtils.modulus, RSAUtils.private_exponent);\n            pubKey = RSAUtils.getPublicKey(RSAUtils.modulus, RSAUtils.public_exponent);\n        }\n        return SingletonHolder.INSTANCE;\n    }\n    /**\n     * 获取Token\n     *\n     * @param uid 用户ID\n     * @param exp 失效时间，单位分钟\n     * @return\n     */\n    public static String getToken(String uid, int exp) {\n        long endTime = System.currentTimeMillis() + 1000 * 60 * exp;\n        return Jwts.builder().setSubject(uid).setExpiration(new Date(endTime))\n                .signWith(SignatureAlgorithm.RS512, priKey).compact();\n    }\n    /**\n     * 获取Token\n     *\n     * @param uid 用户ID\n     * @return\n     */\n    public String getToken(String uid) {\n        long endTime = System.currentTimeMillis() + 1000 * 60 * 1440;\n        return Jwts.builder().setSubject(uid).setExpiration(new Date(endTime))\n                .signWith(SignatureAlgorithm.RS512, priKey).compact();\n    }\n    /**\n     * 检查Token是否合法\n     *\n     * @param token\n     * @return JWTResult\n     */\n    public JWTResult checkToken(String token) {\n        try {\n            Claims claims = Jwts.parser().setSigningKey(pubKey).parseClaimsJws(token).getBody();\n            String sub = claims.get("sub", String.class);\n            return new JWTResult(true, sub, "合法请求", ResponseCode.SUCCESS_CODE.getCode());\n        } catch (ExpiredJwtException e) {\n            // 在解析JWT字符串时，如果‘过期时间字段’已经早于当前时间，将会抛出ExpiredJwtException异常，说明本次请求已经失效\n            return new JWTResult(false, null, "token已过期", ResponseCode.TOKEN_TIMEOUT_CODE.getCode());\n        } catch (SignatureException e) {\n            // 在解析JWT字符串时，如果密钥不正确，将会解析失败，抛出SignatureException异常，说明该JWT字符串是伪造的\n            return new JWTResult(false, null, "非法请求", ResponseCode.NO_AUTH_CODE.getCode());\n        } catch (Exception e) {\n            return new JWTResult(false, null, "非法请求", ResponseCode.NO_AUTH_CODE.getCode());\n        }\n    }\n    public static class JWTResult {\n        private boolean status;\n        private String uid;\n        private String msg;\n        private int code;\n        public JWTResult() {\n            super();\n        }\n        public JWTResult(boolean status, String uid, String msg, int code) {\n            super();\n            this.status = status;\n            this.uid = uid;\n            this.msg = msg;\n            this.code = code;\n        }\n        public int getCode() {\n            return code;\n        }\n        public void setCode(int code) {\n            this.code = code;\n        }\n        public String getMsg() {\n            return msg;\n        }\n        public void setMsg(String msg) {\n            this.msg = msg;\n        }\n        public boolean isStatus() {\n            return status;\n        }\n        public void setStatus(boolean status) {\n            this.status = status;\n        }\n        public String getUid() {\n            return uid;\n        }\n        public void setUid(String uid) {\n            this.uid = uid;\n        }\n    }\n}\n认证接口\n认证接口用于调用方进行认证时，认证通过则返回一个加密的 Token 给对方，对方就可以用这个 Token 去请求别的服务了，认证获取 Token 代码如下所示。\n@PostMapping("/token")\npublic ResponseData auth(@RequestBody AuthQuery query) throws Exception {\n    if (StringUtils.isBlank(query.getAccessKey()) || StringUtils.isBlank(query.getSecretKey())) {\n        return ResponseData.failByParam("accessKey and secretKey not null");\n    }\n    User user = authService.auth(query);\n    if (user == null) {\n        return ResponseData.failByParam(" 认证失败 ");\n    }\n    JWTUtils jwt = JWTUtils.getInstance();\n    return ResponseData.ok(jwt.getToken(user.getId().toString()));\n}\n认证参数代码如下所示。\n/**\n* API 用户认证参数类\n*/\npublic class AuthQuery {\n    private String accessKey;\n    private String secretKey;\n    // get set ...\n}\nAuthService 中的 auth 方法就是根据 accessKey 和 secretKey 判断是否有这个用户。\n\n由于篇幅有限，请大家继续阅读以下教程：\n服务提供方进行调用认证\n服务消费方申请Token\nFeign调用前统一申请Token传递到调用的服务中\nRestTemplate调用前统一申请Token传递到调用的服务中\nZuul中传递Token到路由的服务中\n\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);