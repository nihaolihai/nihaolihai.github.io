(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{617:function(n,t,r){"use strict";r.r(t);var i=r(6),e=Object(i.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"java-stringbuffer-和-stringbuilder-类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-stringbuffer-和-stringbuilder-类"}},[n._v("#")]),n._v(" Java StringBuffer 和 StringBuilder 类")]),n._v(" "),r("p",[n._v("当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。")]),n._v(" "),r("p",[n._v("和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。")]),n._v(" "),r("p",[n._v("在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。")]),n._v(" "),r("p",[n._v("StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。")]),n._v(" "),r("p",[n._v("由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。")]),n._v(" "),r("p",[n._v('实例\npublic class RunoobTest{\npublic static void main(String args[]){\nStringBuilder sb = new StringBuilder(10);\nsb.append("Runoob..");\nSystem.out.println(sb);'),r("br"),n._v('\nsb.append("!");\nSystem.out.println(sb);\nsb.insert(8, "Java");\nSystem.out.println(sb);\nsb.delete(5,8);\nSystem.out.println(sb);'),r("br"),n._v("\n}\n}")]),n._v(" "),r("p",[n._v("以上实例编译运行结果如下：")]),n._v(" "),r("p",[n._v("Runoob..\nRunoob..!\nRunoob..Java!\nRunooJava!\n然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。")]),n._v(" "),r("p",[n._v('Test.java 文件代码：\npublic class Test{\npublic static void main(String args[]){\nStringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");\nsBuffer.append("www");\nsBuffer.append(".runoob");\nsBuffer.append(".com");\nSystem.out.println(sBuffer);'),r("br"),n._v("\n}\n}\n以上实例编译运行结果如下：")]),n._v(" "),r("p",[n._v("菜鸟教程官网：www.runoob.com\nStringBuffer 方法\n以下是 StringBuffer 类支持的主要方法：")]),n._v(" "),r("p",[n._v("序号\t方法描述\n1\tpublic StringBuffer append(String s)\n将指定的字符串追加到此字符序列。\n2\tpublic StringBuffer reverse()\n将此字符序列用其反转形式取代。\n3\tpublic delete(int start, int end)\n移除此序列的子字符串中的字符。\n4\tpublic insert(int offset, int i)\n将 int 参数的字符串表示形式插入此序列中。\n5\treplace(int start, int end, String str)\n使用给定 String 中的字符替换此序列的子字符串中的字符。\n下面的列表里的方法和 String 类的方法类似：")]),n._v(" "),r("p",[n._v("序号\t方法描述\n1\tint capacity()\n返回当前容量。\n2\tchar charAt(int index)\n返回此序列中指定索引处的 char 值。\n3\tvoid ensureCapacity(int minimumCapacity)\n确保容量至少等于指定的最小值。\n4\tvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\n将字符从此序列复制到目标字符数组 dst。\n5\tint indexOf(String str)\n返回第一次出现的指定子字符串在该字符串中的索引。\n6\tint indexOf(String str, int fromIndex)\n从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。\n7\tint lastIndexOf(String str)\n返回最右边出现的指定子字符串在此字符串中的索引。\n8\tint lastIndexOf(String str, int fromIndex)\n返回 String 对象中子字符串最后出现的位置。\n9\tint length()\n返回长度（字符数）。\n10\tvoid setCharAt(int index, char ch)\n将给定索引处的字符设置为 ch。\n11\tvoid setLength(int newLength)\n设置字符序列的长度。\n12\tCharSequence subSequence(int start, int end)\n返回一个新的字符序列，该字符序列是此序列的子序列。\n13\tString substring(int start)\n返回一个新的 String，它包含此字符序列当前所包含的字符子序列。\n14\tString substring(int start, int end)\n返回一个新的 String，它包含此序列当前所包含的字符子序列。\n15\tString toString()\n返回此序列中数据的字符串表示形式。")])])}),[],!1,null,null,null);t.default=e.exports}}]);