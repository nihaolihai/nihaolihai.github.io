(window.webpackJsonp=window.webpackJsonp||[]).push([[568],{1057:function(e,t,r){"use strict";r.r(t);var n=r(6),i=Object(n.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"servlet-过滤器链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#servlet-过滤器链"}},[this._v("#")]),this._v(" servlet 过滤器链")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('1）创建过滤器\n在 filterDemo01 项目的 com.mengma.filter 包中新建两个过滤器 MyFilter01 和 MyFilter02，如 MyFilter01 和 MyFilter02 所示。\n① MyFilter01\npackage com.mengma.filter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\npublic class MyFilter01 implements Filter {\n    public void init(FilterConfig fConfig) throws ServletException {\n        // 过滤器对象在初始化时调用，可以配置一些初始化参数\n    }\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain) throws IOException, ServletException {\n        // 用于拦截用户的请求，如果和当前过滤器的拦截路径匹配，则该方法会被调用\n        PrintWriter out = response.getWriter();\n        out.write("MyFilter01<br/>");\n        chain.doFilter(request, response);\n    }\n    public void destroy() {\n        // 过滤器对象在销毁时自动调用，释放资源\n    }\n}\n② MyFilter02\npackage com.mengma.filter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\npublic class MyFilter02 implements Filter {\n    public void init(FilterConfig fConfig) throws ServletException {\n        // 过滤器对象在初始化时调用，可以配置一些初始化参数\n    }\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain) throws IOException, ServletException {\n        // 用于拦截用户的请求，如果和当前过滤器的拦截路径匹配，则该方法会被调用\n        PrintWriter out = response.getWriter();\n        out.write("MyFilter02 Before<br/>");\n        chain.doFilter(request, response);\n        out.write("<br/>MyFilter02 After<br/>");\n    }\n    public void destroy() {\n        // 过滤器对象在销毁时自动调用，释放资源\n    }\n}\n2）修改 web.xml\n为了防止其他过滤器影响此次 Filter 链的演示效果，需要先将 web.xml 文件中的其他过滤器的配置信息注释掉，然后将 MyFilter01 和 MyFilter02 过滤器的映射信息配置在 MyServlet 配置信息前面，具体如下所示。\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"\n    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"\n    version="3.0">\n    <filter>\n        <filter-name>MyFilter01</filter-name>\n        <filter-class>com.mengma.filter.MyFilter01</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>MyFilter01</filter-name>\n        <url-pattern>/MyServlet</url-pattern>\n    </filter-mapping>\n    <filter>\n        <filter-name>MyFilter02</filter-name>\n        <filter-class>com.mengma.filter.MyFilter02</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>MyFilter02</filter-name>\n        <url-pattern>/MyServlet</url-pattern>\n    </filter-mapping>\n    <servlet>\n        <servlet-name>MyServlet</servlet-name>\n        <servlet-class>com.mengma.filter.MyServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>MyServlet</servlet-name>\n        <url-pattern>/MyServlet</url-pattern>\n    </servlet-mapping>\n</web-app>\n3）运行项目并查看结果\n启动 Tomcat 服务器，在浏览器的地址栏中输入 http://localhost:8080/filterDemo01/MyServlet\n\n')])])])])}),[],!1,null,null,null);t.default=i.exports}}]);