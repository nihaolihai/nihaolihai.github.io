(window.webpackJsonp=window.webpackJsonp||[]).push([[378],{867:function(n,t,e){"use strict";e.r(t);var i=e(6),s=Object(i.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-boot-admin监控告警服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-admin监控告警服务"}},[this._v("#")]),this._v(" Spring Boot Admin监控告警服务")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('在微服务架构下，服务的数量少则几十，多则上百，所以对服务的监控必不可少。如果是以前的单体项目，启动了多少个项目是固定的，可以通过第三方监控工具对其进行监控，然后实时告警。\n\n在微服务下，由于服务数量太多，并且可以随时扩展，这个时候第三方的监控功能就不适用了，不过我们可以通过 Spring Boot Admin 连接注册中心来查看服务状态，这个只能在页面查看。\n\n很多时候我们更希望能够自动监控，通过邮件告警，比如发出“某某服务下线了”这样的功能。在 Spring Boot Admin 中其实已经有这样的功能了，我们只需要配置一些邮件的信息就可以使用。\n邮件警报\n引入邮件所需要的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n\n然后在配置文件中增加邮件服务器的信息：\nspring.mail.host=smtp.qq.com\nspring.mail.username=xxx@qq.com\nspring.mail.password=qq 邮箱的授权码\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.properties.mail.smtp.starttls.enable=true\nspring.mail.properties.mail.smtp.starttls.required=true\n# 发送给谁\nspring.boot.admin.notify.mail.to=xxx@126.com\n# 是谁发送出去的\nspring.boot.admin.notify.mail.from=xxx@qq.com\n\n配置好之后就可以收到监控邮件了。\n自定义钉钉警报\n目前很多公司都是用钉钉来办公，通过钉钉可以发送监控消息，非常方便。Spring Boot Admin 中默认是没有钉钉警报这个功能的，我们可以自己去扩展使用钉钉来发送监控信息。\n\n首先我们编写一个发送钉钉消息的工具类，代码如下所示。\npublic class DingDingMessageUtil {\n    public static String access_token = "填写你自己申请的token";\n    public static void sendTextMessage(String msg) {\n        try {\n            Message message = new Message();\n            message.setMsgtype("text");\n            message.setText(new MessageInfo(msg));\n            URL url = new URL("https://oapi.dingtalk.com/robot/send?access_token=" + access_token);\n            // 建立 http 连接\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod("POST");\n            conn.setRequestProperty("Charset", "UTF-8");\n            conn.setRequestProperty("Content-Type", "application/Json; charset=UTF-8");\n            conn.connect();\n            OutputStream out = conn.getOutputStream();\n            String textMessage = JsonUtils.toJson(message);\n            byte[] data = textMessage.getBytes();\n            out.write(data);\n            out.flush();\n            out.close();\n            InputStream in = conn.getInputStream();\n            byte[] data1 = new byte[in.available()];\n            in.read(data1);\n            System.out.println(new String(data1));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nclass Message {\n    private String msgtype;\n    private MessageInfo text;\n    public String getMsgtype() {\n        return msgtype;\n    }\n    public void setMsgtype(String msgtype) {\n        this.msgtype = msgtype;\n    }\n    public MessageInfo getText() {\n        return text;\n    }\n    public void setText(MessageInfo text) {\n        this.text = text;\n    }\n}\nclass MessageInfo {\n    private String content;\n    public MessageInfo(String content) {\n        this.content = content;\n    }\n    public String getContent() {\n        return content;\n    }\n    public void setContent(String content) {\n        this.content = content;\n    }\n}\n通过继承 AbstractStatusChangeNotifier 实现钉钉发送机制，代码如下所示。\npublic class DingDingNotifier extends AbstractStatusChangeNotifier {\n    public DingDingNotifier(InstanceRepository repository) {\n        super(repository);\n    }\n    @Override\n    protected Mono<Void> doNotify(InstanceEvent event, Instance instance) {\n        String serviceName = instance.getRegistration().getName();\n        String serviceUrl = instance.getRegistration().getServiceUrl();\n        String status = instance.getStatusInfo().getStatus();\n        Map<String, Object> details = instance.getStatusInfo().getDetails();\n        StringBuilder str = new StringBuilder();\n        str.append("【" + serviceName + "】");\n        str.append("【服务地址】" + serviceUrl);\n        str.append("【状态】" + status);\n        str.append("【详情】" + JsonUtils.toJson(details));\n        return Mono.fromRunnable(() -> {\n            DingDingMessageUtil.sendTextMessage(str.toString());\n        });\n    }\n}\n最后启用 DingDingNotifier 就可以了，代码如下所示。\n@Bean\npublic DingDingNotifier dingDingNotifier() {\n    return new DingDingNotifier();\n}\n\n目前我们已经配置好了警报功能，当服务上下线的时候就会发送警报，当网络发生波动的时候也有可能会触发警报。当前的警报只会发送一次，也就是说你的服务挂掉之后你会收到一条警报。如果是网络引起的警报也会收到一条警报，这个时候你就无法判断服务是不是真正出问题了。\n\n我们的需求也很简单，当服务真正挂掉的时候，警报可以发送多条，比如每 10 秒发送一条，这样连续性的警报就很容易让维护人员关注和辨别。\n\n可以通过配置 RemindingNotifier 来实现上面的需求：\n@Primary\n@Bean(initMethod = "start", destroyMethod = "stop")\npublic RemindingNotifier remindingNotifier(InstanceRepository repository) {\n    RemindingNotifier notifier = new RemindingNotifier(dingDingNotifier(repo - sitory), repository);\n    notifier.setReminderPeriod(Duration.ofSeconds(10));\n    notifier.setCheckReminderInverval(Duration.ofSeconds(10));\n    return notifier;\n}\n这里设置的时间间隔是 10 秒一次，当服务出问题的时候就会每隔 10 秒发送一次警报，直到服务正常才会停止。\n\n这个功能还会引发一个别的问题，如果你的服务是运行在 Docker 中，采用动态端口的话，当你每次重新发布服务的时候，端口发生变化，Spring Boot Admin 就会认为你的服务一直处于不可用的状态，这点不是特别好解决，笔者能想到的方法是在正常项目发布成功之后把 Spring Boot Admin 重启下，获取最新的服务信息。\n\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);