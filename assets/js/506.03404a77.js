(window.webpackJsonp=window.webpackJsonp||[]).push([[506],{995:function(n,e,_){"use strict";_.r(e);var E=_(6),t=Object(E.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"oracle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oracle"}},[this._v("#")]),this._v(" oracle")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("分类\n数据定义语言 DDL ： create，drop，alter，rename，truncate ————不能回滚\n数据操作语言 DML : insert，update，delete ————可以回滚；要commit才更新到数据库\n数据控制语言 DCL ： grant，revoke\n查询语言 ： select\n事务控制语言 TC ： commit，rollback，savepoint\nrollback：\n没有commit的数据删除后无法rollback\ncommit了的数据删除后可以使用rollback恢复\n删除数据后commit则无法使用rollback恢复。\ndrop：\n放到回收站里面\n\nOracle\n一般不会轻易在一个服务器上创建多个数据库，在一个数据库中，不同的项目由不同的用户访问，每一个用户拥有自身创建的数据库对象（表）。（即一个数据库，不同的用户管理不同的表。）\n\n数据库服务要启动；\nOracleService+服务名，该服务是数据库启动的基础，只有该服务启动了，Oracle数据库才能正常启动。这是必须启动的服务。\nOracleOraDb10g_home1TNSListener，该服务是服务器端为客户端提供的监听服务，只有该服务在服务器上正常启动，客户端才能连接到服务器。该监听服务接收客户端发出的请求，然后将请求传递给数据库服务器。一旦建立了连接，客户端和数据库服务器就能直接通信了。\nOracleOraDb10g_home1iSQLPlus，该服务提供了用浏览器对数据库中数据操作的方式。该服务启动后，就可以使用浏览器进行远程登录并进行数据库操作了。\nOracleDBConsole+服务名，Oracle10g中的一个新服务。在Oracle9i之前，Oracle官方提供了一个基于图形界面的企业管理器（EM），从Oracle10g开始，Oracle提供了一个基于B/S的企业管理器，在操作系统的命令行中输入命令：emctl start dbconsole，就可以启动OracleDbConsole服务。\n常用操作\nlist，显示缓存的语句\n\nl\n1\n直接运行缓存的语句\n\n/\n1\n相当于 l + / ，先显示缓存语句，再执行\n\nr\n1\n标志语句结束\n\n;\n\nn是行数，定位并查看缓存中第n行的语句\n\nn\n\nappend，先定位到第n行，然后在这行语句后面追加代码\n\na\n\nchange，修改语句\n\nc /被修改内容/新内容 ：\n\n删除缓存中第n行的语句\n\ndel n\n\n若报错，可能是用户没有session权限\n\n1、用户：\nSQL*PLUS：与oracle数据库进行交互的客户端工具。\n\n（1）创建用户\n有创建用户权限的用户（如系统管理员）才能创建用户。\n\ncreate user 用户名 identified by 密码;\n\n//修改用户的密码\nalter user 用户名 identified by 新密码\n\n（2）角色/权限\n//授予角色（权限的集合）\ngrant connect,resource to 用户名;\n    - CONNECT角色，主要应用在临时用户，特别是那些不需要建表的用户，通常只赋予他们CONNECT role。CONNECT是使用Oracle的简单权限，拥有CONNECT角色的用户，可以与服务器建立连接会话（session，客户端对服务器连接，称为会话）。\n    - RESOURCE角色，更可靠和正式的数据库用户可以授予RESOURCE role。RESOURCE提供给用户另外的权限以创建他们自己的表、序列、过程（procedure）、触发器（trigger）、索引（index）等。\n    - DBA角色，DBA role拥有所有的系统权限----包括无限制的空间限额和给其他用户授予各种权限的能力。用户SYSTEM拥有DBA角色。\n    一般情况下，一个普通的用户（如SCOTT），拥有CONNECT和RESOURCE两个角色即可进行常规的数据库开发工作。\n\n//授予某一项权限\ngrant create view to 用户名;\n\n//撤销角色/权限\nrevoke 角色|权限 from 用户名;\n\n//查看自身有哪些角色\nselect * from user_role_privs;\n\n//查看自身的角色和权限\nselect * from role_sys_privs;\n\n//修改用户处于锁定（非锁定）状态，锁定状态是不能登录的\nalter user 用户名 account lock|unlock;\n\n（3）查询用户\nselect * from all_users;\n1\n（4）用户登录\nsqlplus 用户名/密码 [@host_string] [用户身份];\n\n//普通用户\nsqlplus 用户名/密码；\n\n//系统管理员登录，必须指定身份，as sysdba或者as sysoper，可以不输入密码也能正常登陆\nsqlplus sys/ as sysdba;\n\n同义词\n\n CREATE SYNONYM TEST FOR DM.TM_WGG_ATM_GTW_MON;\n\n\n -----------------------------同义词删除（代码块处理：先判断存在，后删除）\n \nDECLARE\n  v_num number;\nBEGIN\n  ----多次删除时，每次都将V_NUM设置成为0\n  v_num := 0;\n  ----判断触发器  synonym_name 是否存在（区分大小写）\n  select count(0) into v_num from user_synonyms where upper(synonym_name) = upper('xdr_qxba_jy_bapz');\n  ----如果存在立即删除\n  IF v_num > 0 THEN\n    execute immediate 'drop synonym xdr_qxba_jy_bapz';\n  END IF;\n\n  IF v_num = 0 THEN\n  execute immediate 'CREATE SYNONYM xdr_qxba_jy_bapz FOR DM.TM_WGG_ATM_GTW_MON';\n  END IF;\n\n  v_num := 0;\n  select count(0) into v_num from user_synonyms where upper(synonym_name) = upper('xdr_qxba_jy_info');\n  IF v_num > 0 THEN\n    execute immediate 'drop synonym xdr_qxba_jy_info';\n  END IF;\nEND;\n\n\n模糊查询\n\n    <if test=\"emsListNo != null and emsListNo != ''\">\n            and b.EMS_LIST_NO like '%'|| #{emsListNo} || '%'\n    </if>\n\n非空判断\n\n    <if test=\"flag != null and flag != '' and flag != '-1' and _databaseId == 'oracle'\">\n            and nvl(c.FLAG, '0') = #{flag}\n    </if>\n\n    NOTE IS NULL;\n\n    SYSDATE\n\n日期查询范围\n\n    <choose>\n        <when test=\"_databaseId == 'postgresql'\">\n            <if test=\"declareDateFrom != null and declareDateFrom != ''\">\n                <![CDATA[ and b.DECLARE_DATE >= to_date(#{declareDateFrom}, 'yyyy-MM-dd')]]>\n            </if>\n            <if test=\"declareDateTo != null and declareDateTo != ''\">\n                <![CDATA[ and b.DECLARE_DATE < (to_date(#{declareDateTo}, 'yyyy-MM-dd') + interval '1 day')]]>\n            </if>\n        </when>\n        <otherwise>\n            <if test=\"declareDateFrom != null and declareDateFrom != ''\">\n                <![CDATA[ and b.DECLARE_DATE >= to_date(#{declareDateFrom}, 'yyyy-MM-dd')]]>\n            </if>\n            <if test=\"declareDateTo != null and declareDateTo != ''\">\n                <![CDATA[ and b.DECLARE_DATE < to_date(#{declareDateTo}, 'yyyy-MM-dd') + 1]]>\n            </if>\n        </otherwise>\n    </choose>\n \n复制表结构数据\n\n目标表存在：INSERT INTO 目标表 SELECT * FROM 原表;\n\n目标表不存在：CREATE TABLE 目标表 AS SELECT * FROM 原表;\n \n-----------------------------触发器删除（代码块处理：先判断存在，后删除）\n\nDECLARE\n  v_num number;\nBEGIN\n  ----多次删除时，每次都将V_NUM设置成为0\n  v_num := 0;\n  ----判断触发器  TABLE_NAME 是否存在（区分大小写）\n  select count(0) into v_num from user_triggers where upper(trigger_name) = upper('rpsy_zs_fgqych_tri');\n  ----如果存在立即删除\n  IF v_num > 0 THEN\n    execute immediate 'drop trigger rpsy_zs_fgqych_tri';\n  END IF;\n \n  v_num := 0;\n  select count(0) into v_num from user_triggers where upper(trigger_name) = upper('rpsy_zs_fgqyjh_tri');\n  IF v_num > 0 THEN\n    execute immediate 'drop trigger rpsy_zs_fgqyjh_tri';\n  END IF;\nEND;\n \n-----------------------------视图删除（代码块处理：先判断存在，后删除）\n\nDECLARE\n  v_num number;\nBEGIN\n  ----多次删除时，每次都将V_NUM设置成为0\n  v_num := 0;\n  ----判断触发器  TABLE_NAME 是否存在（区分大小写）\n  select count(0) into v_num from user_views where upper(view_name) = upper('v_qymh_qyda_zsxx');\n  ----如果存在立即删除\n  IF v_num > 0 THEN\n    execute immediate 'drop view v_qymh_qyda_zsxx';\n  END IF;\n \n  v_num := 0;\n  select count(0) into v_num from user_views where upper(view_name) = upper('xdr_qyda_sp_wljy_ba');\n  IF v_num > 0 THEN\n    execute immediate 'drop view xdr_qyda_sp_wljy_ba';\n  END IF;\nEND;\n\n类型转换\n\nto_char(insert_time,'yyyymmddd') \n\ncast(11 as INTEGER)\n\n数值格式化0.22与'0.22'都可以运行\n\nselect rtrim(rtrim(to_char(0.22, 'fm99999999999990.9000000000000'),'0'),'.') FROM dual;\n\n\n判断表是否存在\n\nfunction detect_table(str_in_tablename varchar2) return integer is\n        i_l_number integer;\n    begin\n        select count(*)\n          into i_l_number\n          from user_tables\n         where table_name = upper(str_in_tablename);\n\n        return i_l_number;\n    end;\n\n复制表结构\n\ncreate table table_name_new as select * from TEST_A where 1=2;\n\n判读字段是否存在\n\nfunction detect_column(str_in_tablename  varchar2, str_in_columnname varchar2) return integer is\n        i_l_number integer;\n    begin\n        select count(*)\n          into i_l_number\n          from user_tab_columns\n         where table_name = upper(str_in_tablename)\n           and column_name = upper(str_in_columnname);\n\n        return i_l_number;\n    end;\n\ndeclare\n  num1 int;\nbegin\n  select count(1) into num1 from user_tab_cols where table_name = upper('T_DC_DEC_TASK') and column_name = upper('SEND_COUNTER');\n  if num1 < 1 then\n    execute immediate 'alter table T_DC_DEC_TASK add SEND_COUNTER NUMBER(5) default 0 not null';\n  end if;\nend;\n\ncomment on column T_DC_DEC_TASK.send_counter is '发送次数';\n\n查找存储过程\n\nselect * from  user_procedures where object_name = 'P_CHECK_CUS_CONSUME';\n\nP_RET_CODE   IN OUT VARCHAR2,\nP_RET_STR    IN OUT VARCHAR2\n手动异常\nraise_application_error(-20000, '当前异常返回');\n最后异常\nEXCEPTION\n  WHEN OTHERS THEN\n    P_RET_CODE := SQLCODE;\n    P_RET_STR  := SUBSTR(SQLERRM, 1, 200);\n    ROLLBACK;\n\nCREATE OR REPLACE PROCEDURE werwer(P_TEMP_OWNER IN VARCHAR2, --批次（guid）\n                                               P_FLAG       IN VARCHAR2, --标识（0：校验 1：导入）\n                                               P_RET_CODE   IN OUT VARCHAR2,\n                                               P_RET_STR    IN OUT VARCHAR2) IS\n  P_TRADE_CODE   VARCHAR2(10); --海关10位编码\n  P_COP_G_NO VARCHAR2(50); --料号\n  P_EMS_NO      VARCHAR2(50);\n  \nBEGIN\n  SELECT TRADE_CODE\n    INTO P_TRADE_CODE\n    FROM T_EMS_CUS_EXG_LOCK_TMP\n   WHERE TEMP_OWNER = P_TEMP_OWNER\n     AND ROWNUM = 1;\n  SELECT COP_G_NO\n    INTO P_COP_G_NO\n    FROM T_EMS_CUS_EXG_LOCK_TMP\n   WHERE TEMP_OWNER = P_TEMP_OWNER\n     AND ROWNUM = 1;\n  SELECT EMS_NO\n    INTO P_EMS_NO\n    FROM T_EMS_CUS_EXG_LOCK_TMP\n   WHERE TEMP_OWNER = P_TEMP_OWNER\n     AND ROWNUM = 1;\n\n  IF P_FLAG = '0' or P_FLAG = '2' or P_FLAG = '3' THEN\n    --校验\n    --料号不存在\n    --\n    UPDATE T_EMS_CUS_EXG_LOCK_TMP TMP\n       SET TMP.TEMP_FLAG   = 1,\n           TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|成品不存在'\n     WHERE NOT EXISTS (SELECT 1\n              FROM T_EMS_CUS_EXG_LOCK\n             WHERE EMS_NO = TMP.EMS_NO\n               AND COP_G_NO = TMP.COP_G_NO\n               --成品的 TRADE_CODE字段是需要声明的变量，还是临时表中的数据？\n               --AND TRADE_CODE = P_TRADE_CODE\n               )\n       AND TEMP_OWNER = P_TEMP_OWNER; \n  \n  \n  -- 检查成品号是否重复\n    UPDATE T_EMS_CUS_EXG_LOCK_TMP TMP\n       SET TMP.TEMP_FLAG   = 1,\n           TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|成品号重复!'\n     WHERE EXISTS (SELECT 1\n              FROM T_EMS_CUS_EXG_LOCK_TMP TMP1\n             WHERE TMP1.TEMP_OWNER = P_TEMP_OWNER\n               AND TMP1.COP_G_NO = TMP.COP_G_NO\n             GROUP BY COP_G_NO\n            HAVING COUNT(COP_G_NO) > 1)\n       AND TEMP_OWNER = P_TEMP_OWNER;\n       \n       \n    --判断锁定解锁标志是否正确\n    UPDATE T_EMS_CUS_EXG_LOCK_TMP TMP\n       SET TMP.TEMP_FLAG   = 1,\n           TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|锁定解锁标志不正确'\n     WHERE (TMP.TYPE <> '0' AND TMP.TYPE <> '1')  \n       AND TMP.TEMP_OWNER = P_TEMP_OWNER;\n  \n  END IF;\n  COMMIT;\n\n  IF P_FLAG = '1' or P_FLAG = '2' THEN\n    --修改导入\n    MERGE INTO T_EMS_CUS_EXG_LOCK E\n    USING (SELECT \n             TMP.TYPE,\n             TMP.COP_G_NO,\n             TMP.EMS_NO,\n             TMP.TRADE_CODE,\n             TMP.UPDATE_USER\n             FROM T_EMS_CUS_EXG_LOCK_TMP TMP\n            WHERE TMP.TEMP_FLAG IN (0, 2)\n              AND TMP.TEMP_OWNER = P_TEMP_OWNER) T\n    ON (T.COP_G_NO = E.COP_G_NO AND T.EMS_NO = E.EMS_NO)\n    WHEN MATCHED THEN\n      UPDATE\n         SET E.TYPE = T.TYPE,\n             E.UPDATE_TIME = sysdate,\n             E.UPDATE_USER = T.UPDATE_USER;\n    WHEN NOT MATCHED THEN\n      INSERT\n      (E.sid,E.tads)  \n      VALUES\n      (T.sid,T.tads);\n  \n    --删除临时表里本次导入的数据\n    IF P_FLAG ='1' THEN\n       DELETE T_EMS_CUS_EXG_LOCK_TMP TMP WHERE TEMP_OWNER = P_TEMP_OWNER;\n    ELSIF P_FLAG='2' THEN\n       DELETE T_EMS_CUS_EXG_LOCK_TMP TMP WHERE TEMP_OWNER = P_TEMP_OWNER AND TEMP_FLAG='0';\n    END IF;\n    \n  END IF;\n  COMMIT;\nEXCEPTION\n  WHEN OTHERS THEN\n    P_RET_CODE := SQLCODE;\n    P_RET_STR  := SUBSTR(SQLERRM, 1, 200);\n    ROLLBACK;\nEND;\n\n建表语句\ncreate table T_EMS_ACTION_LOG\n(\n  SID                 VARCHAR2(40) default sys_guid(),\n  TRADE_CODE          VARCHAR2(10),\n  EMS_NO              VARCHAR2(12),\n  DCR_TIMES           NUMBER(18,9),\n  COP_EMS_NO          VARCHAR2(20),\n  ACTION              VARCHAR2(32) not null,\n  BUSINESS_TYPE       VARCHAR2(100) not null,\n  NOTE                VARCHAR2(4000),\n  INSERT_TIME         DATE default SYSDATE,\n  INSERT_USER         VARCHAR2(50)\n);\n-- Add comments to the columns\ncomment on column T_EMS_ACTION_LOG.SID\n  is 'SID';\ncomment on column T_EMS_ACTION_LOG.TRADE_CODE\n  is '位编码';\ncomment on column T_EMS_ACTION_LOG.EMS_NO\n  is '账册号';\ncomment on column T_EMS_ACTION_LOG.DCR_TIMES\n  is '次数';\ncomment on column T_EMS_ACTION_LOG.COP_EMS_NO\n  is '编号';\ncomment on column T_EMS_ACTION_LOG.ACTION\n  is '操作{WIPE_ALL:清空数据；DEL：删除数据; CANCEL_AUTO_DEC: } ';\ncomment on column T_EMS_ACTION_LOG.BUSINESS_TYPE\n  is '业务类型{TR:资质  EMS:账册  DCR:报核 }';\ncomment on column T_EMS_ACTION_LOG.NOTE\n  is '日志{DEL类型是记录本次删除数据的SID,多条是以'',''隔开}';\ncomment on column T_EMS_ACTION_LOG.INSERT_TIME\n  is '插入时间';\ncomment on column T_EMS_ACTION_LOG.INSERT_USER\n  is '插入人';\n\n修改属性  \n  \nALTER TABLE T_DC_BILL_TEMPLATE MODIFY INPUT_CREDIT_CODE VARCHAR2(18) NULL;\n\n字段类型修改\n\nsELECT COUNT(1) FROM ALL_TAB_COLS WHERE TABLE_NAME = UPPER('tesy') AND COLUMN_NAME = 'EXG_VERSION' AND DATA_TYPE='VARCHAR2';\n\nALTER TABLE tesy ADD EXG_VERSION_TMP VARCHAR2(50);\n\nUPDATE tesy SET EXG_VERSION_TMP = EXG_VERSION;\n\nALTER TABLE tesy DROP COLUMN EXG_VERSION;\n\nALTER TABLE tesy RENAME COLUMN EXG_VERSION_TMP TO EXG_VERSION;\n\nCOMMENT ON COLUMN tesy.EXG_VERSION IS '版本号';\n\n查找表结构\n\nselect * from user_tab_columns where table_name='T_HX_STK_BOM'\n\n查找索引是否存在\n\nSELECT count(1) FROM ALL_INDEXES WHERE TABLE_NAME ='tesy' AND INDEX_NAME = 'IDX_BILL_HEAD_A24'\n\ncreate index IDX_BILL_HEAD_A24 on tesy (BILL_LIST_NO);\n\n判断主键是否存在\n\nfunction detect_constraint(str_in_tablename varchar2, str_in_constraint varchar2) return integer is\n        i_l_number integer;\n    begin\n        select count(*)\n          into i_l_number\n          from user_constraints\n         where table_name = upper(str_in_tablename)\n           and constraint_name = upper(str_in_constraint);\n\n        return i_l_number;\n    end; \n\n判断索引是否存在\n\nfunction detect_index(str_in_tablename varchar2, str_in_indexname varchar2) return integer is\n        i_l_number integer;\n    begin\n        select count(*)\n          into i_l_number\n          from user_indexes\n         where table_name = upper(str_in_tablename)\n           and index_name = upper(str_in_indexname);\n\n        return i_l_number;\n    end;\n\n \n\n判断序列是否存在\n\nfunction detect_sequence(str_in_sequencename varchar2) return integer is\n        i_l_number integer;\n    begin\n        select count(*)\n          into i_l_number\n          from user_sequences\n         where sequence_name = upper(str_in_sequencename);\n\n        return i_l_number;\n    end;\n\n存储过程\n\ncreate or replace procedure CURRENTBRANCHSTATISTIC_INSERT(M_BRANCH_ID in NVARCHAR2,\n   M_INNUM in NUMBER) is\n   recordnum NUMBER:=0;\n  begin\n    select count(BRANCH_ID) into recordnum  from CURRENTBRANCHSTATISTIC Where BRANCH_ID=M_BRANCH_ID;\n  if(recordnum=0) then\n    insert into CURRENTBRANCHSTATISTIC(BRANCH_ID,INNUM) values (M_BRANCH_ID,M_INNUM);\n  Else\n    update CURRENTBRANCHSTATISTIC set INNUM=M_INNUM where BRANCH_ID=M_BRANCH_ID;\n End if;\n end CURRENTBRANCHSTATISTIC_INSERT;\n\nbegin\n  CURRENTBRANCHSTATISTIC_INSERT('111',198);\nend;\n\n用户登录失败原因：\n\n被锁定\n没有登录权限\n忘记密码\n用户不存在\n（5）切换用户\nconnect 用户名/密码;\n1\n2、常用数据类型\n\n\nchar型数据，后面自动用空格补齐\n3、表操作\n（1）查询表\ndesc 表名\n1\n（2）创建表\n可以为自己创建表，也可以为其他用户创建表。\n\n//方式一：\ncreate table [用户名.]表名(\n    列名 数据类型 [default 默认值][, ...]\n)\n\ncreate table 表名(\n    列名1 char(10), --注释\n    列名2 varchar2(20),\n    列名3 date,\n    列名3 integer,\n    列名3 number（6,2） --整数最多4位，小数最多2位\n)；\n\n//方式二：利用子查询创建表，相当于复制操作\ncreate table 表名[列名1，列名2...] as 子查询;\n\ncreate table B as select * from A;\n\n（3）截断表\n删除表数据，保留表结构，数据无法恢复。\n\ntruncate table 表名\n1\n（4）删除表\n//1、闪回删除————10g新特性\ndrop table 表名\n\n//查看回收站\nshow recyclebin;\n\n//从回收站恢复表\nflashback table 表名 to before drop;\n\n//清空回收站\npurge recyclebin;\n\n//2、彻底删除(级联删除 + 不放回收站)\ndrop table 表名 [cascade contraints] [purge]\n\n（5）修改表\n1.插入新列 add\n\nalter table 表名 \nadd 列名1 数据类型 [default 默认值] [，列名n...]\n\nalter table A\nadd age number(2) default 23; \n\n2.删除列 drop\n\nalter table 表名 \ndrop column 列名;\n\n判断序号是否连续\nselect * from (SELECT temp_index, ROW_NUMBER() OVER(order by temp_index) as ROWNO from(\nselect * from t_dc_bill_list_tmp where \ntemp_owner = '59a81987-a97a-5696-b755-cb9dce29ba76-Z80000000000000432-3223940025' \norder by temp_index) as tt ) as t1\nwhere t1.temp_index!=ROWNO\n\n3.修改列 modify\n\nalter table 表名 \nmodify 列名1 数据类型 [default 默认值] [，列名n...]\n\nalter table A\nmodify age integer(2) default 23; \n\nALTER TABLE T_DC_BILL_CFG MODIFY VALUE VARCHAR2(256);\n\n//若改变类型后长度小于已有数据的长度，会报错，可以先清空值\nupdate 表名 set 列名1='';\n\n4、数据操作\n（1）插入数据\ninsert into 表名 values(值1,值2...);\ninsert into 表名 (列名1,列名2...) values(值1,值2...);\n\n插入date型:\n\ninsert into 表名 (列名1) values(to_date('1999-09-09','yyyy-MM-dd'))：\n1\n（2）更新数据\n一般更新、基于一个表来更新、利用多列子查询来更新。\n\nupdate 表名 set 列名=数值[,列名=数值] [where 条件];\n\nupdate A set age=13,name='Tom' where rownum=1;\n\nrownum是行号，rowid是数据记录的地址。\n\n（3）删除数据\n语句用于删除表中的行。\n\ndelete from 表名 [where 条件]\n\n//删除所有行\ndelete from 表名  \ndelete * from 表名\n\n（4）虚表\n用于查询一个不存在于任何表中的数据。\n\nselect sysdate from dual;\nselect length('abc') from dual;\n\n5、约束CONSTRAINT\n\n\n外键的值允许为空，如果插入值，则必须能在父表中找到。先建父表再建子表。\n\n当前时间减去2天\nSELECT sysdate - 2 FROM dual;\n\n创建表时添加约束：\n\ncreate table student\n(\nid number(5) primary key,\nteam_id varchar2(5) foreign key references team(id),\naddress varchar2(20) not null，\ncountry varchar2(10) unique,\ngender varchar2(2) check(gender='man' or gender='woman'),\n);\n\n//或\ncreate table student\n(\nid number(5),\nteam_id varchar2(5),\ncountry varchar2(10),\ngender varchar2(2),\nconstraint pk_student_id primary key(id),\nconstraint fk_student_tid foreign key(team_id) references team(id),\nconstraint uk_student_co unique(country),\nconstraint student_sex_ck check(gender='man' or gender='woman'),\n);\n\n创建表后添加约束：\n\nalter table A add primary key(id);\nalter table A add foreign key(team_id) references team(id);\nalter table A modify address not null;\nalter table A add unique (country);\nalter table A add check(gender='man' or gender='woman');\n\n//或\nalter table A add constraint pk_student_id PRIMARY KEY (id);\nalter table A add constraint fk_student_tid foreign key(team_id) references team(id);\nalter table A add constraint uk_student_co unique (country);\nalter table A add constraint student_sex_ck check(gender='man' or gender='woman');\n\n删除约束：\n\nalter table A drop constraint 约束名;\n1\n查看约束：\n\ndesc user_constraints;     \n\nselect owner,constraints_name,constraints_type,table_name from user_constraints;\n\ndesc user_cons_columns; \n\nselect owner,constraints_name,table_name,column_name from user_cons_columns;\n\n通过外键两表联查：\n\nselect * from student,team where team_id=team.id;\n\n6、SQL查询语句\n\n\n（1）使用算术表达式 +-*/\nselect 列名+20 from 表名;\n1\n（2）取别名 as\n//为列取别名\nselect 列名 as 别名 from 表名;\nselect 列名 别名 from 表名;\nselect 列名 \"别名\" from 表名;  \n\n//为表取别名\nselect * from 表名 别名;\n\n（3）连接运算符 ||\nselect 列名 || 'abcdefg' from 表名;\n1\n（4）去重 distinct\nselect distinct 列名 from 表名;\n1\n（5）过滤 where\nselect * from 表名 where 列名 比较操作符 数值|表达式|列名;\n\nWHERE Customer='Bush' OR Customer='Adams'\nWHERE Address IS NULL\nWHERE Address IS NOT NULL\nWHERE Year>1965\nWHERE OrderPrice>(SELECT AVG(OrderPrice) FROM Orders)\nWHERE City LIKE '%lon%'\nWHERE City NOT LIKE '%lon%'\n\n（6）通配符 % _\n% ：0个或多个字符；\n_ ：1个字符\n[charlist]： 字符列中的任何单一字符\n[^charlist]或者[!charlist] ：不在字符列中的任何单一字符；\n\nselect * from 表名 where 列名 like 's_a%y';\nselect * from 表名 where 列名 not like 's_a%y'; \n\n\n//以 \"A\" 或 \"L\" 或 \"N\" 开头的人：\nSELECT * FROM Persons WHERE City LIKE '[ALN]%'\n\nSELECT * FROM Persons WHERE City LIKE '[!ALN]%'\n\n//转义escape,可以将一个字符当成是转义字符\nselect * from 表名 where 列名 like 's\\_a\\%y' escape '\\';\nselect * from 表名 where 列名 like 's$_a$%y' escape '$';\n\n（7）排序 order by\nselect * from 表名 order by 列名 ASC|DESC;\nselect 列名 别名 from 表名 order by 别名;\nselect * from 表名 order by 列名1 ASC, 列名2 DESC,列名3 DESC;\nselect 列名1 列名2 from 表名 order by 2;              //根据列名2进行排序\n\n（8）分组 group by\n将行分组为具有相同列值的多个部分，大多数与聚合函数一起出现。如果查询中包含一个聚合函数，而同时有查询的列并不在聚合函数中，那么这个列必须在group by子句中。\n\nselect gender,count(gender) from A group by gender\nselect job,avg(sal) from A group by job \n\n//语法错误\nselect gender,count(gender) from A \n\n（9）聚合比较 having\n聚合函数作比较要放在having中，而不能放在where中。分组->计算聚合->聚合比较。\n\nselect job,avg(sal) from A where gender='man' group by job having avg(sal)>1500\n1\n7、SQL函数\n需要select或者having才能返回结果，在where中是不返回结果的。\n定义函数\nCREATE OR REPLACE FUNCTION TEST_CURRENT_DATE RETURN DATE AS\nBEGIN\n  RETURN TRUNC(SYSDATE);\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_CURRENT_TIMESTAMP RETURN DATE AS\nBEGIN\nRETURN SYSDATE;\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_DATE_ADDORSUB(p_date     date,\n                                               p_interval number,\n                                               p_unit     varchar)\n  RETURN date AS\nBEGIN\n  if p_unit = 'y' or p_unit = 'Y' then\n    return p_date + p_interval * INTERVAL '1' YEAR;\n  elsif p_unit = 'm' or p_unit = 'M' then\n    return p_date + p_interval * INTERVAL '1' MONTH;\n  elsif p_unit = 'd' or p_unit = 'D' then\n    return p_date + p_interval * INTERVAL '1' DAY;\n  elsif p_unit = 'h' or p_unit = 'H' then\n    return p_date + p_interval * INTERVAL '1' HOUR;\n  elsif upper(p_unit) = 'MI' then\n    return p_date + p_interval * INTERVAL '1' MINUTE;\n  elsif p_unit = 's' or p_unit = 'S' then\n    return p_date + p_interval * INTERVAL '1' SECOND;\n  end if;\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_DATE_DIFF(p_date1 date, p_date2 date)\n  RETURN number AS\nBEGIN\n  RETURN p_date1 - p_date2;\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_DATE_TRUNC(p_date DATE) RETURN DATE AS\nBEGIN\n  RETURN TRUNC(p_date);\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_NVL(expr1 NVARCHAR2, expr2 NVARCHAR2)\n  RETURN NVARCHAR2 AS\nBEGIN\n  RETURN NVL(expr1, expr2);\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_NVL2(expr1 NVARCHAR2,\n                                      expr2 NVARCHAR2,\n                                      expr3 NVARCHAR2) RETURN NVARCHAR2 IS\nre NVARCHAR2(32767);\nBEGIN\n  SELECT NVL2(expr1, expr2, expr3) INTO re from dual;\n  RETURN re;\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_TO_DATE_ONLY(p_date   VARCHAR2,\n                                              p_format VARCHAR2)\n  RETURN DATE AS\nBEGIN\n  RETURN TO_DATE(p_date, p_format);\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_TO_NUMBER(p_text varchar2) RETURN number AS\nBEGIN\n  RETURN to_number(p_text);\nEND;\n\nCREATE OR REPLACE FUNCTION TEST_DECODE(expr NVARCHAR2,\n                                        s1   NVARCHAR2,\n                                        rs1  NVARCHAR2,\n                                        s2   NVARCHAR2,\n                                        rs2  NVARCHAR2,\n                                        d    NVARCHAR2) RETURN NVARCHAR2 IS\n  res NVARCHAR2(32767);\nBEGIN\n  SELECT DECODE(expr, s1, rs1, s2, rs2, d) INTO RES FROM DUAL;\n  RETURN res;\nEND;\n\n（1）单行函数\n1. 字符函数\n\n//将第一个字母转成大写\n\ninitcap(n)\n\n//从m位置开始在x中查找字符串y出现的位置，n是出现次数\n\ninstr(x,y,m,n)\n\n//求字符串长度\n\nlength(n)\n\n//将字符串各字符转换成小写\n\nlower(x)\n\n//大写......\n\nupper(x)\n\n//在字符串x左边补齐字符y（缺省则补空格），得到总长为n的字符串\n\nlpad(x,n,y)\n\n//在字符串x右边......\n\nrpad(x,n,y)\n\n//去掉左边\\右边\\两边去掉指定字符\n\nselect trim(leading '*' from '**sbash**') from dual;\n\n//x左边去掉指定字符y，默认去空格\n\nltrim(x,y)\n\n//x右边......\n\nrtrim(x,y)\n\n//如果x不是null，则返回x，否则返回y\n\nnul(x,y)\n\n//如果x不是null，则返回y，否则返回z\n\nnul2(x,y,z)\n\n//如果x是数字，则返回x，否则返回y\n\nnanvl(x,y)\n\n//x中替换y为z\n\nreplace(x,y,z)\n\n//从字符串x中的m开始取长度为n的子串，n缺省时取到结尾\n\nsubstr(x,m,n)\n\n//连接字符串\n\nconcat(m,n)\n\n存储过程是否存在\n\nselect count(*) count from user_objects where object_type = 'PROCEDURE'\nand object_name='P_CHECK_CUS_EXG'；\n\n修改默认值\n\nALTER TABLE tes MODIFY DCR_CYCLE DEFAULT null;\n\n创建主键\n\nalter table table_name add constraint constraint_name primary key(column_name1,column_name2);\n\n创建唯一约束\n\nalter table table_name add constraint constraint_name unique(column_name1,column_name2);\n\nalter table t1 drop constraint uk_t1_id keep index;\n\n删除约束\n\nalter table T_INVITEE_RECORD_TEST drop constraint SYS_C00133333 cascade drop index;\n\n\n删除约束及关联索引\n\nalter table T_INVITEE_RECORD_TEST drop constraint SYS_C00133333 cascade drop index;\n\n删除主键及关联索引\n\nalter table T_INVITEE_RECORD_TEST drop primary key cascade drop index;\n\n查看约束信息\n\nselect a.*\nfrom user_cons_columns a, user_constraints b\nwhere a.constraint_name = b.constraint_name\nand b.constraint_type = 'U'\nand a.table_name = 'T_HX_DCR_CONSUME';\n\n查看orcal编码\n\nselect userenv('language') from dual;\n\n安装plsql\n\n(1) 在plsql 中打开工具-首选项配置\n\n点击链接\n\nF:\\PLSQL7.1.5\\instantclient_12_1\\oci.dll\n\n(2)配置完成重新打开查询发现中文字段乱码\n\n在环境变量中配置语言\n\nNLS_LANG\n\nSIMPLIFIED CHINESE_CHINA.ZHS16GBK\n\n\nupdate t_sd_temp t\n        set temp_flag = 1,\n            temp_remark = nvl(t.temp_remark, '') || '|料号不能存在!'\n        where not exists (\n            select 1 from sdcds c\n            where t.ems_no = c.ems_no\n            and t.cop_img_no = c.cop_g_no\n            and t.cav_mark = #{cavMark}\n            and t.batch_no = #{batchId}\n            and c.ems_no = #{emsNo}\n            and c.trade_code = #{tradeCode}\n            )\n            and t.cav_mark = #{cavMark}\n            and t.batch_no = #{batchId}\n\n性能优化\n\nMERGE INTO ewrwe t\n            USING(SELECT COP_IMG_NO,COP_EXG_NO,EXG_VERSION FROM wewe \n            WHERE TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65'\n            GROUP BY COP_IMG_NO,COP_EXG_NO,EXG_VERSION HAVING COUNT(1)>1) e\n            ON (t.COP_EXG_NO = e.COP_EXG_NO \n            AND t.COP_IMG_NO = e.COP_IMG_NO \n            AND t.EXG_VERSION = e.EXG_VERSION\n            AND t.TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65')\n            WHEN MATCHED THEN\n              UPDATE\n                 SET t.TEMP_FLAG   = 1,\n                     t.TEMP_REMARK = t.TEMP_REMARK ||\n                                     '|存在都相同的多行数据'  \n    \nUPDATE tesy TMP\n         SET TMP.TEMP_FLAG   = 1,\n             TMP.TEMP_REMARK = TMP.TEMP_REMARK ||\n                               '|系统中都相同的数据'\n       WHERE EXISTS (SELECT 1\n                FROM trere PRE\n               WHERE PRE.TRADE_CODE = P_TRADE_CODE\n                 AND PRE.COP_EMS_NO = P_COP_EMS_NO\n                 AND PRE.COP_IMG_NO = TMP.COP_IMG_NO\n                 AND PRE.COP_EXG_NO = TMP.COP_EXG_NO\n                 AND PRE.EXG_VERSION = TMP.EXG_VERSION)\n         AND TEMP_OWNER = P_TEMP_OWNER;\n\n\nmerge into T_EMS_CUS_CONSUME_PRE_TMP t\n      using T_EMS_CUS_EXG_PRE e\n      on (t.COP_EXG_NO = e.COP_G_NO and t.TRADE_CODE = e.TRADE_CODE and t.COP_EMS_NO = e.COP_EMS_NO and t.TEMP_OWNER = P_TEMP_OWNER)\n      when matched then\n        update\n           set t.EXG_G_NO     = e.G_NO,\n               t.EXG_G_NAME   = e.G_NAME,\n               t.EXG_UNIT     = e.UNIT,\n               t.EXG_CODE_T_S = e.CODE_T_S;\n     WHEN NOT MATCHED THEN\n        INSERT into;\n\n执行\n<update id=\"createMessageId\" statementType=\"CALLABLE\">\n    {CALL P_BILL_GEN_MESSAGE_ID}\n    </update>\n    <update id=\"createMessageId\" statementType=\"CALLABLE\" databaseId=\"postgresql\">\n    CALL P_BILL_GEN_MESSAGE_ID()\n    </update>\n\n存储过程是否存在\n\nselect count(1) from user_procedures where object_name = 'P_EMS_GENERATE_NO';\n\ndrop procedure P_EMS_GENERATE_NO;\n\n创建存储过程\n\nCREATE OR REPLACE PROCEDURE TEST_GEN_MESSAGE_ID AS\n  P_G_NO       NUMBER;\n  P_MESSAGE_ID VARCHAR(64);\n  --定义游标\n  CURSOR BILL_TASK IS\n    SELECT *\n      FROM T_DC_DEC_TASK T\n     WHERE T.STATUS = '0'\n          --AND T.BUSINESS_TYPE = 'CUS'\n       AND T.MESSAGE_ID IS NULL\n       FOR UPDATE;\n  --定义一个游标变量\n  BILL_ROW BILL_TASK%ROWTYPE;\nBEGIN\n  FOR BILL_ROW IN BILL_TASK LOOP\n    SELECT NVL(MAX(G_NO) + 1, 1)\n      INTO P_G_NO\n      FROM T_DC_DEC_TASK T\n     WHERE T.TRADE_CODE = BILL_ROW.TRADE_CODE\n       AND T.BUSINESS_TYPE = BILL_ROW.BUSINESS_TYPE\n       AND T.SEND_RECV_TYPE = 'S'\n       AND TRUNC(T.INSERT_TIME) >= TRUNC(BILL_ROW.INSERT_TIME)\n       AND TRUNC(T.INSERT_TIME) < TRUNC(BILL_ROW.INSERT_TIME) + 1;\n\n    IF BILL_ROW.BUSINESS_TYPE = 'ENTRY' THEN\n\n      UPDATE T_DC_DEC_TASK\n         SET G_NO       = P_G_NO,\n             MESSAGE_ID = 'DECLENTER' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                          TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                          LPAD(P_G_NO, 4, '0')\n       WHERE CURRENT OF BILL_TASK;\n\n    ELSIF BILL_ROW.BUSINESS_TYPE = 'BILL' THEN\n\n      IF SUBSTR(BILL_ROW.EMS_NO, 0, 1) = 'E' then\n\n        UPDATE T_DC_DEC_TASK\n           SET G_NO       = P_G_NO,\n               MESSAGE_ID = 'NEMSINVT' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                            TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                            LPAD(P_G_NO, 4, '0')\n         WHERE CURRENT OF BILL_TASK;\n      elsif SUBSTR(BILL_ROW.EMS_NO, 0, 1) <> 'E' then\n        UPDATE T_DC_DEC_TASK\n           SET G_NO       = P_G_NO,\n               MESSAGE_ID = 'NPTSINVT' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                            TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                            LPAD(P_G_NO, 4, '0')\n         WHERE CURRENT OF BILL_TASK;\n\n      END IF;\n\n    END IF;\n\n  END LOOP;\n  COMMIT;\nEND;\n\nCREATE OR REPLACE PROCEDURE TEST_CUS_RET_LOG(P_COP_EMS_NO IN VARCHAR2, --D\n    P_SID          IN VARCHAR2, --回执表的SID\n    P_STATUS       IN VARCHAR2, --状态\n    P_TRADE_CODE   IN VARCHAR2, --企业10位编码\n    P_RET_CODE     IN OUT VARCHAR2, --错误状态码\n    P_RET_STR      IN OUT VARCHAR2 --错误信息\n    ) IS\n    P_HEAD_ID VARCHAR2(40);\n    P_DECLARE_TYPE VARCHAR2(1);\n    P_COUNT INT;\n    P_FLAG VARCHAR2(1);\n    BEGIN\n    SELECT HEAD_ID INTO P_HEAD_ID FROM T_EMS_DEC_RESPONSES_CUS WHERE SID=P_SID;\n    SELECT DECLARE_TYPE INTO P_DECLARE_TYPE FROM T_EMS_CUS_HEAD_PRE WHERE COP_EMS_NO=P_COP_EMS_NO AND TRADE_CODE=P_TRADE_CODE;\n    SELECT COUNT(1) INTO P_COUNT FROM T_EMS_DEC_LOG_DETAIL WHERE HEAD_ID=P_HEAD_ID;\n    IF P_COUNT>0 THEN\n    P_FLAG:='1';\n    ELSE\n    P_FLAG:='0';\n    END IF;\n    INSERT INTO T_EMS_DEC_LOG\n    (SID,\n    TRADE_CODE,\n    COP_EMS_NO,\n    BUSINESS_TYPE,\n    DECLARE_TYPE,\n    STATUS,\n    NOTE,\n    INSERT_USER,\n    APPR_DATE,\n    HEAD_ID,\n    MESSAGE_ID,\n    FLAG)\n    SELECT SYS_GUID,\n    P_TRADE_CODE,\n    P_COP_EMS_NO,\n    'CUS',\n    P_DECLARE_TYPE,\n    P_STATUS,\n    FAIL_INFO,\n    INSERT_USER,\n    APPR_DATE,\n    P_HEAD_ID,\n    MESSAGE_ID,\n    P_FLAG\n    FROM T_EMS_DEC_RESPONSES_CUS\n    WHERE SID = P_SID;\n    COMMIT;\n    EXCEPTION\n    WHEN OTHERS THEN\n    P_RET_CODE := SQLCODE;\n    P_RET_STR  := SUBSTR(SQLERRM, 1, 200);\n    ROLLBACK;\n    END;\n\nCREATE OR REPLACE PROCEDURE sdfs AS\n  P_G_NO       NUMBER;\n  P_MESSAGE_ID VARCHAR(64);\n  --定义游标\n  CURSOR BILL_TASK IS\n    SELECT *\n      FROM T_DC_DEC_TASK T\n     WHERE T.STATUS = '0'\n          --AND T.BUSINESS_TYPE = 'CUS'\n       AND T.MESSAGE_ID IS NULL\n       FOR UPDATE;\n  --定义一个游标变量\n  BILL_ROW BILL_TASK%ROWTYPE;\nBEGIN\n  FOR BILL_ROW IN BILL_TASK LOOP\n    SELECT NVL(MAX(G_NO) + 1, 1)\n      INTO P_G_NO\n      FROM T_DC_DEC_TASK T\n     WHERE T.TRADE_CODE = BILL_ROW.TRADE_CODE\n       AND T.BUSINESS_TYPE = BILL_ROW.BUSINESS_TYPE\n       AND T.SEND_RECV_TYPE = 'S'\n       AND TRUNC(T.INSERT_TIME) >= TRUNC(BILL_ROW.INSERT_TIME)\n       AND TRUNC(T.INSERT_TIME) < TRUNC(BILL_ROW.INSERT_TIME) + 1;\n\n    IF BILL_ROW.BUSINESS_TYPE = 'ENTRY' THEN\n\n      UPDATE T_DC_DEC_TASK\n         SET G_NO       = P_G_NO,\n             MESSAGE_ID = 'DECLENTER' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                          TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                          LPAD(P_G_NO, 4, '0')\n       WHERE CURRENT OF BILL_TASK;\n\n    ELSIF BILL_ROW.BUSINESS_TYPE = 'BILL' THEN\n\n      IF SUBSTR(BILL_ROW.EMS_NO, 0, 1) = 'E' then\n\n        UPDATE T_DC_DEC_TASK\n           SET G_NO       = P_G_NO,\n               MESSAGE_ID = 'NEMSINVT' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                            TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                            LPAD(P_G_NO, 4, '0')\n         WHERE CURRENT OF BILL_TASK;\n      elsif SUBSTR(BILL_ROW.EMS_NO, 0, 1) <> 'E' then\n        UPDATE T_DC_DEC_TASK\n           SET G_NO       = P_G_NO,\n               MESSAGE_ID = 'NPTSINVT' || '-' || BILL_ROW.TRADE_CODE || '-' ||\n                            TO_CHAR(BILL_ROW.INSERT_TIME, 'YYYYMMDD') || '-' ||\n                            LPAD(P_G_NO, 4, '0')\n         WHERE CURRENT OF BILL_TASK;\n\n      END IF;\n\n    END IF;\n\n  END LOOP;\n  COMMIT;\nEND;\n\nCREATE OR REPLACE PROCEDURE sds(P_TEMP_OWNER IN VARCHAR2, --批次（guid）\n    P_FLAG       IN VARCHAR2, --标识（0：校验 1：导入）\n    P_RET_CODE   IN OUT VARCHAR2,\n    P_RET_STR    IN OUT VARCHAR2) IS\n\n    P_TRADE_CODE   VARCHAR2(10); --海关10位编码\n    P_COP_G_NO VARCHAR2(50); --料号\n    P_EMS_NO      VARCHAR2(50);\n\n\n    BEGIN\n    SELECT TRADE_CODE\n    INTO P_TRADE_CODE\n    FROM T_EMS_CUS_IMG_LOCK_TMP\n    WHERE TEMP_OWNER = P_TEMP_OWNER\n    AND ROWNUM = 1;\n    SELECT COP_G_NO\n    INTO P_COP_G_NO\n    FROM T_EMS_CUS_IMG_LOCK_TMP\n    WHERE TEMP_OWNER = P_TEMP_OWNER\n    AND ROWNUM = 1;\n    SELECT EMS_NO\n    INTO P_EMS_NO\n    FROM T_EMS_CUS_IMG_LOCK_TMP\n    WHERE TEMP_OWNER = P_TEMP_OWNER\n    AND ROWNUM = 1;\n\n    IF P_FLAG = '0' or P_FLAG = '2' or P_FLAG = '3' THEN\n    --校验\n    UPDATE T_EMS_CUS_IMG_LOCK_TMP TMP\n    SET TMP.TEMP_FLAG   = 1,\n    TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|不存在'\n    WHERE NOT EXISTS (SELECT 1\n    FROM T_EMS_CUS_IMG_LOCK\n    WHERE EMS_NO = TMP.EMS_NO\n    AND COP_G_NO = TMP.COP_G_NO\n    )\n    AND TEMP_OWNER = P_TEMP_OWNER;\n\n\n    -- 检查成品号是否重复\n    UPDATE T_EMS_CUS_IMG_LOCK_TMP TMP\n    SET TMP.TEMP_FLAG   = 1,\n    TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|导入文件中重复，不予导入!'\n    WHERE EXISTS (SELECT 1\n    FROM T_EMS_CUS_IMG_LOCK_TMP TMP1\n    WHERE TMP1.TEMP_OWNER = P_TEMP_OWNER\n    AND TMP1.COP_G_NO = TMP.COP_G_NO\n    GROUP BY COP_G_NO\n    HAVING COUNT(COP_G_NO) &gt; 1)\n    AND TEMP_OWNER = P_TEMP_OWNER;\n\n\n    --判断锁定解锁标志是否正确\n    UPDATE T_EMS_CUS_IMG_LOCK_TMP TMP\n    SET TMP.TEMP_FLAG   = 1,\n    TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|锁定解锁标志不正确'\n    WHERE (TMP.TYPE &lt;&gt; '0' AND TMP.TYPE &lt;&gt; '1')\n    AND TMP.TEMP_OWNER = P_TEMP_OWNER;\n\n    END IF;\n    COMMIT;\n\n    IF P_FLAG = '1' or P_FLAG = '2' THEN\n    --修改导入\n    MERGE INTO T_EMS_CUS_IMG_LOCK E\n    USING (SELECT\n    TMP.TYPE,\n    TMP.NOTE,\n    TMP.COP_G_NO,\n    TMP.EMS_NO,\n    TMP.TRADE_CODE,\n    TMP.UPDATE_USER\n    FROM T_EMS_CUS_IMG_LOCK_TMP TMP\n    WHERE TMP.TEMP_FLAG IN (0, 2)\n    AND TMP.TEMP_OWNER = P_TEMP_OWNER) T\n    ON (T.COP_G_NO = E.COP_G_NO AND T.EMS_NO = E.EMS_NO)\n    WHEN MATCHED THEN\n    UPDATE\n    SET E.TYPE = T.TYPE,\n    E.NOTE = T.NOTE,\n    E.UPDATE_TIME = sysdate,\n    E.UPDATE_USER = T.UPDATE_USER;\n\n    --删除临时表里本次导入的数据\n    IF P_FLAG ='1' THEN\n    DELETE T_EMS_CUS_IMG_LOCK_TMP TMP WHERE TEMP_OWNER = P_TEMP_OWNER;\n    ELSIF P_FLAG='2' THEN\n    DELETE T_EMS_CUS_IMG_LOCK_TMP TMP WHERE TEMP_OWNER = P_TEMP_OWNER AND TEMP_FLAG='0';\n    END IF;\n\n    END IF;\n    COMMIT;\n    EXCEPTION\n    WHEN OTHERS THEN\n    P_RET_CODE := SQLCODE;\n    P_RET_STR  := SUBSTR(SQLERRM, 1, 200);\n    ROLLBACK;\n    END;\n\n    \n建表语句\ncreate table T_EMS_ACTION_LOG\n(\n  SID                 VARCHAR2(40) default sys_guid(),\n  TRADE_CODE          VARCHAR2(10),\n  EMS_NO              VARCHAR2(12),\n  DCR_TIMES           NUMBER,\n  COP_EMS_NO          VARCHAR2(20),\n  ACTION              VARCHAR2(32) not null,\n  BUSINESS_TYPE       VARCHAR2(100) not null,\n  NOTE                VARCHAR2(4000),\n  INSERT_TIME         DATE default SYSDATE,\n  INSERT_USER         VARCHAR2(50)\n);\n-- Add comments to the columns\ncomment on column T_EMS_ACTION_LOG.SID\n  is 'SID';\ncomment on column T_EMS_ACTION_LOG.TRADE_CODE\n  is '编码';\ncomment on column T_EMS_ACTION_LOG.EMS_NO\n  is '账册号';\ncomment on column T_EMS_ACTION_LOG.DCR_TIMES\n  is '次数';\ncomment on column T_EMS_ACTION_LOG.COP_EMS_NO\n  is '编号';\ncomment on column T_EMS_ACTION_LOG.ACTION\n  is '操作{WIPE_ALL:清空数据；DEL：删除数据; CANCEL_AUTO_DEC: } ';\ncomment on column T_EMS_ACTION_LOG.BUSINESS_TYPE\n  is '业务类型{TR:资质  EMS:账册  DCR:报核 }';\ncomment on column T_EMS_ACTION_LOG.NOTE\n  is '日志{DEL类型是记录本次删除数据的SID,多条是以'',''隔开}';\ncomment on column T_EMS_ACTION_LOG.INSERT_TIME\n  is '插入时间';\ncomment on column T_EMS_ACTION_LOG.INSERT_USER\n  is '插入人';\n\n判断视图是否存在\n\nselect * from user_views;\n\n--删除索引\n\ndeclare\n    CURSOR HEAD_PART_LIST IS\n        select INDEX_NAME,TABLE_NAME\n        from user_indexes where table_name='T_DC_BILL_LIST';\n    HEAD_ROW  HEAD_PART_LIST%ROWTYPE;\n    MAIN_PART INTEGER;\nbegin\n    for HEAD_ROW IN HEAD_PART_LIST\n        LOOP\n            MAIN_PART := 0;\n            SELECT COUNT(1)\n            INTO MAIN_PART\n            from user_indexes where table_name=HEAD_ROW.TABLE_NAME and INDEX_NAME=HEAD_ROW.INDEX_NAME;\n            if MAIN_PART > 0 then\n                EXECUTE immediate 'DROP index ' || HEAD_ROW.INDEX_NAME;\n            end if;\n        end loop;\nend;\n/\nDECLARE\n    isExist INTEGER;\nBEGIN\n    select count(1) into isExist from user_tables where table_name = 'T_DC_BILL_LIST_PART';\n    if isExist > 0 then\n        execute immediate 'DROP TABLE T_DC_BILL_LIST_PART';\n    end if;\nEND;\n/\n\n--建表语句\ncreate table wewe\n(\n  SID VARCHAR2(40) DEFAULT sys_guid() NOT NULL,\n\tTRADE_CODE VARCHAR2(10) NOT NULL,\n\tEMS_NO VARCHAR2(12) NOT NULL,\n\tBILL_LIST_NO VARCHAR2(18) NOT NULL,\n\tACTL_PASS_QTY NUMBER(18,5),\n\tCLASSIFY_MARK VARCHAR2(4),\n\tCODE_T_S VARCHAR2(10) NOT NULL,\n\tCOP_G_NO VARCHAR2(32) NOT NULL,\n\tCURR VARCHAR2(3) NOT NULL,\n\tDATA_MARK VARCHAR2(128),\n\tDEC_PRICE NUMBER(19,5) NOT NULL,\n\tDEC_TOTAL NUMBER(20,5) NOT NULL,\n\tDESTINATION_COUNTRY VARCHAR2(3) NOT NULL,\n\tDISTRICT_CODE VARCHAR2(5),\n\tDISTRICT_POST_CODE VARCHAR2(6),\n\tDUTY_MODE VARCHAR2(1) NOT NULL,\n\tENTRY_G_NO NUMBER(9,0),\n\tEXG_VERSION VARCHAR2(8),\n\tFACTOR_1 NUMBER(18,5),\n\tFACTOR_2 NUMBER(18,5),\n\tFACTOR_WT NUMBER(18,5),\n\tG_MODEL VARCHAR2(255) NOT NULL,\n\tG_NAME VARCHAR2(255) NOT NULL,\n\tG_NO NUMBER(9,0) NOT NULL,\n\tGROSS_WT NUMBER(18,5),\n\tHEAD_ID VARCHAR2(40),\n\tINDB_TIME DATE,\n\tINSERT_TIME DATE DEFAULT SYSDATE NOT NULL,\n\tINSERT_USER VARCHAR2(50) NOT NULL,\n\tMODIFY_MARK VARCHAR2(1) DEFAULT 3,\n\tNET_WT NUMBER(18,5),\n\tNOTE VARCHAR2(256),\n\tORIGIN_COUNTRY VARCHAR2(3) NOT NULL,\n\tPASSPORT_USED_QTY NUMBER(18,5),\n\tPRE_SEQ_NO VARCHAR2(18),\n\tQTY NUMBER(18,5) NOT NULL,\n\tQTY_1 NUMBER(18,5) NOT NULL,\n\tQTY_2 NUMBER(18,5),\n\tROTATE_G_NO VARCHAR2(64),\n\tSEQ_NO VARCHAR2(18),\n\tSERIAL_NO NUMBER(9,0) NOT NULL,\n\tUNIT VARCHAR2(3) NOT NULL,\n\tUNIT_1 VARCHAR2(3) NOT NULL,\n\tUNIT_2 VARCHAR2(3),\n\tUPDATE_TIME DATE DEFAULT SYSDATE,\n\tUPDATE_USER VARCHAR2(50),\n\tUSD_PRICE NUMBER(18,5),\n\tUSE_TYPE VARCHAR2(2)\n);\ncomment on table T_DC_BILL_LIST_PART is '表体';\ncomment on column T_DC_BILL_LIST_PART.SID is 'SID';\n\n/\n\n--插入数据\ninsert into sdcsd\nselect SID, TRADE_CODE, EMS_NO, BILL_LIST_NO, ACTL_PASS_QTY, CLASSIFY_MARK, CODE_T_S, COP_G_NO,\n       CURR, DATA_MARK, DEC_PRICE, DEC_TOTAL, DESTINATION_COUNTRY, DISTRICT_CODE,\n       DISTRICT_POST_CODE, DUTY_MODE, ENTRY_G_NO, EXG_VERSION, FACTOR_1, FACTOR_2, FACTOR_WT,\n       G_MODEL, G_NAME, G_NO, GROSS_WT, HEAD_ID, INDB_TIME, INSERT_TIME, INSERT_USER,\n       MODIFY_MARK, NET_WT, NOTE, ORIGIN_COUNTRY, PASSPORT_USED_QTY, PRE_SEQ_NO, QTY, QTY_1,\n       QTY_2, ROTATE_G_NO, SEQ_NO, SERIAL_NO, UNIT, UNIT_1, UNIT_2, UPDATE_TIME, UPDATE_USER,\n       USD_PRICE, USE_TYPE\nfrom sdsd;\ncommit;\n/\n\n重命名表\n\nDECLARE\n    isExist INTEGER;\n    num INTEGER;\nBEGIN\n    select count(1) into isExist from user_tables where table_name = 'T_DC_BILL_LIST_PART';\n    if isExist = 0 then\n      select count(1) into num from user_tables where table_name = 'T_DC_BILL_LIST';\n      if num = 1 then\n          execute immediate 'rename T_DC_BILL_LIST to T_DC_BILL_LIST_PART';\n      end if;\n    end if;\nEND;\n\ncreate index IDX_BILL_LIST_005_NEW on T_DC_BILL_LIST_NEW (TRADE_CODE, EMS_NO,HEAD_ID) local;\ncreate unique index IDX_BILL_LIST_006_NEW on T_DC_BILL_LIST_NEW (TRADE_CODE, EMS_NO,BILL_LIST_NO, SERIAL_NO) local;\n\ndeclare\n    CURSOR HEAD_PARTITION IS\n        SELECT TRADE_CODE, EMS_NO\n        FROM T_DC_BILL_HEAD\n        group by TRADE_CODE, EMS_NO ;\n    HEAD_ROW  HEAD_PARTITION%ROWTYPE;\n    MAIN_PART INTEGER;\n    SUB_PART  INTEGER;\n    MAIN_PREFIX VARCHAR2(50);\n    SUB_PREFIX VARCHAR2(50);\n    T_NAME VARCHAR2(50);\nbegin\n    for HEAD_ROW IN HEAD_PARTITION\n        LOOP\n            MAIN_PART := 0;\n            SUB_PART := 0;\n            MAIN_PREFIX := 'b_l_p_';\n            SUB_PREFIX := 'b_l_s_';\n            T_NAME := 'T_DC_BILL_LIST_NEW';\n            SELECT COUNT(1)\n            INTO MAIN_PART\n            FROM USER_TAB_SUBPARTITIONS\n            WHERE TABLE_NAME = T_NAME\n              AND PARTITION_NAME = upper(MAIN_PREFIX || HEAD_ROW.TRADE_CODE);\n            SELECT COUNT(1)\n            INTO SUB_PART\n            FROM USER_TAB_SUBPARTITIONS\n            WHERE TABLE_NAME = T_NAME\n              AND PARTITION_NAME = upper(MAIN_PREFIX || HEAD_ROW.TRADE_CODE)\n              AND SUBPARTITION_NAME = upper(SUB_PREFIX || HEAD_ROW.EMS_NO);\n            if MAIN_PART = 0 then\n                EXECUTE immediate 'alter table ' || T_NAME || ' add partition ' || MAIN_PREFIX || HEAD_ROW.TRADE_CODE ||\n                                  ' values (''' || HEAD_ROW.TRADE_CODE || ''') (\n                    subpartition ' || SUB_PREFIX || HEAD_ROW.EMS_NO || ' VALUES (''' || HEAD_ROW.EMS_NO || '''))';\n            end if;\n            if MAIN_PART > 0 and SUB_PART = 0 then\n                EXECUTE immediate 'alter table ' || T_NAME || ' modify partition ' || MAIN_PREFIX || HEAD_ROW.TRADE_CODE ||\n                                  ' add subpartition '|| SUB_PREFIX || HEAD_ROW.EMS_NO || ' VALUES (''' || HEAD_ROW.EMS_NO || ''')';\n            end if;\n        end loop;\nend;\n\n--修改表\ndeclare\n    num number;\n    old number;\nbegin\n    select count(1) into old from user_tables where table_name = 'T_DC_BILL_LIST_OLD';\n    if old = 0 then\n\n        select count(1) into num from user_tables where table_name = 'T_DC_BILL_LIST';\n        if num = 1 then\n            execute immediate 'rename T_DC_BILL_LIST to T_DC_BILL_LIST_OLD';\n        end if;\n\n        select count(1) into num from user_objects where object_type = 'INDEX' and object_name = 'IDX_BILL_LIST_001';\n        if num = 1 then\n            execute immediate 'alter index IDX_BILL_LIST_001 rename to IDX_BILL_LIST_001_OLD';\n        end if;\n    end if;\n\n    select count(1) into num from user_tables where table_name = 'T_DC_BILL_LIST';\n    if num = 0 then\n        execute immediate 'rename T_DC_BILL_LIST_NEW to T_DC_BILL_LIST';\n        execute immediate 'alter index IDX_BILL_LIST_001_NEW rename to IDX_BILL_LIST_001';\n    end if;\n\tcommit;\nend;\n\n2. 数字函数\n\nround：四舍五入\n\nround(5.89,-1)       // 10 保留十位数\nround(5.89)          // 6 保留个位数\nround(5.89,1)        // 5.9\nround(15.89,-1)      // 20\nround(15.89,-2)      // 0\n\ntrunc：截断\n\ntrunc(5.89,-1)       // 0\ntrunc(5.89)          // 5\ntrunc(5.89,1)        // 5.8\n\n3. 转换函数\n\n\n//转换为日期\nselect to_date('2018-06-18','yyyy-MM-dd') from dual\n\n//转为为二进制数\nbin_to_num(n)\n\n//2018-06-18 09:35:45\nselect to_char(sysdate,'yyyy-MM-dd HH24:mi:ss') from dual\n\n4. 日期函数\n//获取系统时间\nselect sysdate from dual        //18-6月 -18\n\n//求下个月最后一天\nselect last_day(add_mon ths(sysdate,1)) from dual\n\n//从x开始，下一个第n天的日期（从星期天开始算）\nselect next_day(sysdate,n) from dual\n\n//-.03225806\nselect months_between(sysdate,sysdate+1) from dual\n\n//18-6月 -18     01-1月 -18     01-7月 -18\nselect round(sysdate),round(sysdate,'yyyy'),round(sysdate,'MM') from dual\n\n//18-6月 -18     01-1月 -18     01-6月 -18\nselect trunc(sysdate),trunc(sysdate,'yyyy'),trunc(sysdate,'MM') from dual\n\n//2018-06-18 09:35:45\nselect to_char(sysdate,'yyyy-MM-dd HH24:mi:ss') from dual\n\n（2）聚合函数\n//count，返回非空数据的条数\nselect count(*) from A\n\n//min、max求最值\nselect min(列名),max(列名) from A\n\n//sum求和，avg求均值\nselect sum(列名),avg(列名) from A\n\n8、高级SQL查询\n\n\n//两表联查\nselect a.sno,sname from student a join score c on a.sno=c.sno\n//三表联查\nselect a.sno,sname,cname from student a join score c on a.sno=c.sno join course b on b.cno=c.cno\n\n(1)内连接 inner join\n检索两表的匹配行\n\n1）等值连接\nselect a.sno,sname from student a join score c on a.sno=c.sno where a.age=20\n\n2）不等值连\nselect a.sno,sname from student a join score c on a.sno=c.sno where a.age>20\n\n3）自然连接\n通过相同的列将两表联系起来，不用写on条件\n\nselect a.sno,sname from student natural join score\n//等价于\nselect a.sno,sname from student a join score c on a.sno=c.sno\n//等价于\nselect a.sno,sname from student join score using(sno)\n\n(2)外连接 outer join\n检索一个表的所有记录和另一表中的匹配行\n\n1）左外连接 left join\n两表匹配的行 + 左表中剩余的行\n\nselect a.sno,sname,cno from student a left outer join score c on a.sno=c.sno\n//等价于\nselect a.sno,sname,cno from student a,score c where a.sno=c.sno(+)\n\n2）右外连接 right join\n两表匹配的行 + 右表中剩余的行\n\nselect a.sno,sname,cno from student a right outer join score c on a.sno=c.sno\n//等价于\nselect a.sno,sname,cno from student a,score c where a.sno(+)=c.sno\n\n3）全连接 full join\nselect a.sno,sname,cno from student a full outer join score c on a.sno=c.sno\n1\n(3)集合运算\n1>union\n用于合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n\nSELECT column_name(s) FROM table_name1\nUNION\nSELECT column_name(s) FROM table_name2  \n\n//可重复\nSELECT column_name(s) FROM table_name1\nUNION ALL\nSELECT column_name(s) FROM table_name2  \n\n2>intersect\n求交集，两表相同的部分\n\nSELECT column_name(s) FROM table_name1\nintersect\nSELECT column_name(s) FROM table_name2\n\n3>minus\n求差集，两表不相同的部分\n\nSELECT column_name(s) FROM table_name1\nminus\nSELECT column_name(s) FROM table_name2\n\n9、子查询\n单行子查询\n多行子查询\n多列子查询\n关联子查询\n嵌套子查询\n（1）单行子查询\n子查询不能包含order by。可以在where、having、having中。\n\n//where中————查询年龄 小于 平均年龄的学生的学号和姓名\nselect id,name from student where age< (select avg(age) from student);\n\n//语法错误，聚合函数应该在having中做比较\nselect id,name from student where age<avg(age);\n\n//having中————查询课程为‘c002’的平均成绩 大于 所有学生的平均分\nselect cno,avg(score) from sc where cno='c002' group by cno \nhaving avg(score)>(select avg(score) from sc);\n\n//from中————查询哪些员工的工资 高于 所任职位的平均工资\nselect ename,sal,avgjob from emp a,\n(select avg(sal),job from emp group by job) b \nwhere a.job=b.job and a.sal>b.avgjob;\n\nselect t1.*,t2.password as uname from user t1\nleft join(\nselect * from test where password ='66' order by id desc\n) t2 on t1.temp=t2.id\n\n//错误写法，子查询返回的是一个表\nselect ename，工资 from 表名 where 工资>（select 职位，avg(工资) from 表名 group by 职位）;\n\n（2）多行子查询\n<1>使用IN操作符\n//查询 各个职位中工资最高 的员工信息 (两个职位的最高工资相同时，只显示其中一个)\nselect empno,ename,job,sal from emp where sal in(select max(sal) from emp group by job)\n\n//上面的改进版，由于查询多了个job，所以就算sal相同也会显示\nselect empno,ename,job,sal from emp where (sal,job) in(select max(sal),job from emp group by job)\n\n<2>使用exists操作符\n是否存在，返回真或者假。\n\nselect empno,ename,sal from emp where exists(select * from dept where deptno = '40')\n1\n<3>使用all操作符\nall 返回列表中的每一个值\n>all 为大于最大的（大于所有值）\n<4>使用any操作符\n10、视图\n一个或多个表上的预定义查询。\n\n（1）优点\n\n\n（2）创建语法\n\n\n（3）创建视图\ncreate or replace noforce view v_emp (\"empno\",\"ename\",\"sal\") \nas select empno,ename,sal from emp where sal>1000;\n\ncreate or replace noforce view v_emp \nas select empno,ename,sal from emp;\n\n（4）对视图的DML操作\n只能对简单的视图（基于一张表）进行DML操作。\n\ninsert into v_emp(id,name) values(001,'Jason')\ninsert into v_emp values(001,'Jason'，'lloijs',2461)\n\n<1>with check option\ncreate or replace noforce view v_emp \nas select empno,ename,sal from emp where sal>1000 with check option;\n\n//插入失败，要满足where后面的条件\ninsert into v_emp values(001,'Jason',500)\n\n<2>with read only\ncreate or replace noforce view v_emp \nas select empno,ename,sal from emp  with read only;\n\n//插入失败，因为是只读with read only\ninsert into v_emp values(001,'Jason',500)\n\n11、PL/SQL编程\n\n(1)构成\ndeclare部分\n\n定义变量、常量（CONSTANT）、游标\n\n- 变量： a number(9) := 10;\n- 常量： PI CONSTANT number(9) := 3.141592653;\n- 赋值： :=    或者    default 或者 into\n\nBEGIN和END部分\nEXCEPTION部分\n(2)变量类型\n标量类型变量<<重点>>\n复合类型变量<<重点>>\n参照类型变量\nLOB类型变量\n<1>标量类型变量\n\n创建分区\ndeclare\n    CURSOR TABLE_LIST IS\n        select PARTITION_TABLE_NAME\n        from T_HX_PARTITION;\n    CURSOR EMS_NO_LIST IS\n        select EMS_NO\n        from T_HX_DCR_LIST\n        group by EMS_NO;\n    TABLE_ROW TABLE_LIST%ROWTYPE;\n    LIST_ROW  EMS_NO_LIST%ROWTYPE;\n    MAIN_PART INTEGER;\nBEGIN\n    for TABLE_ROW in TABLE_LIST LOOP\n            for LIST_ROW in EMS_NO_LIST LOOP\n                    MAIN_PART := 0;\n                    SELECT　COUNT(1)\n                    INTO MAIN_PART\n                    FROM user_tab_partitions\n                    WHERE TABLE_NAME  = TABLE_ROW.PARTITION_TABLE_NAME\n                     AND PARTITION_NAME = LIST_ROW.EMS_NO;\n                    IF MAIN_PART = 0  then\n                    EXECUTE immediate 'alter table '|| TABLE_ROW.PARTITION_TABLE_NAME ||' add partition ' || LIST_ROW.EMS_NO || ' values (''' || LIST_ROW.EMS_NO || ''')';\n                    commit;\n                    end IF;\n             end LOOP;\n     end LOOP;\nEND;\n创建主从分区\ndeclare\n    CURSOR HEAD_PARTITION IS\n        SELECT TRADE_CODE, EMS_NO\n        FROM T_DC_BILL_HEAD\n        group by TRADE_CODE, EMS_NO ;\n    HEAD_ROW  HEAD_PARTITION%ROWTYPE;\n    MAIN_PART INTEGER;\n    SUB_PART  INTEGER;\n    MAIN_PREFIX VARCHAR2(50);\n    SUB_PREFIX VARCHAR2(50);\n    T_NAME VARCHAR2(50);\nbegin\n    for HEAD_ROW IN HEAD_PARTITION\n        LOOP\n            MAIN_PART := 0;\n            SUB_PART := 0;\n            MAIN_PREFIX := 'b_l_p_';\n            SUB_PREFIX := 'b_l_s_';\n            T_NAME := 'T_DC_BILL_LIST_NEW';\n            SELECT COUNT(1)\n            INTO MAIN_PART\n            FROM USER_TAB_SUBPARTITIONS\n            WHERE TABLE_NAME = T_NAME\n              AND PARTITION_NAME = upper(MAIN_PREFIX || HEAD_ROW.TRADE_CODE);\n            SELECT COUNT(1)\n            INTO SUB_PART\n            FROM USER_TAB_SUBPARTITIONS\n            WHERE TABLE_NAME = T_NAME\n              AND PARTITION_NAME = upper(MAIN_PREFIX || HEAD_ROW.TRADE_CODE)\n              AND SUBPARTITION_NAME = upper(SUB_PREFIX || HEAD_ROW.EMS_NO);\n            if MAIN_PART = 0 then\n                EXECUTE immediate 'alter table ' || T_NAME || ' add partition ' || MAIN_PREFIX || HEAD_ROW.TRADE_CODE ||\n                                  ' values (''' || HEAD_ROW.TRADE_CODE || ''') (\n                    subpartition ' || SUB_PREFIX || HEAD_ROW.EMS_NO || ' VALUES (''' || HEAD_ROW.EMS_NO || '''))';\n            end if;\n            if MAIN_PART > 0 and SUB_PART = 0 then\n                EXECUTE immediate 'alter table ' || T_NAME || ' modify partition ' || MAIN_PREFIX || HEAD_ROW.TRADE_CODE ||\n                                  ' add subpartition '|| SUB_PREFIX || HEAD_ROW.EMS_NO || ' VALUES (''' || HEAD_ROW.EMS_NO || ''')';\n            end if;\n        end loop;\nend;\n\n存储过程\n\nselect count(1) into num from user_objects where object_type = 'PROCEDURE' and object_name='P_INIT_DATA';\n\nDROP PROCEDURE P_INIT_DATA;\n\n视图\n\nselect count(1) from user_views where view_name='T_EMS_CUS_EXG_CUR';\n\ndrop view T_EMS_CUS_EXG_CUR;\n\n索引\n\nselect * from all_indexes where table_name ='T_HX_STK_BOM' AND INDEX_NAME = 'IDX_STK_BOM_TRANSF';\n\nselect * from user_indexes where table_name ='T_HX_STK_BOM' AND INDEX_NAME = 'IDX_STK_BOM_TRANSF';\n\nCREATE INDEX IDX_STK_BOM_TRANSF ON T_HX_STK_BOM (TRADE_CODE);\n\n查看索引及结构\n\nselect user_ind_columns.index_name,user_ind_columns.column_name,\nuser_ind_columns.column_position,user_indexes.uniqueness\nfrom user_ind_columns,user_indexes\nwhere user_ind_columns.index_name = user_indexes.index_name\nand user_ind_columns.table_name = 'T_HX_STK_BOM';\n\n\n约束\nselect count(1) from user_constraints where table_name = 'T_HX_DCR_CONSUME' and constraint_type ='P' and upper(constraint_name )=upper('pk_t_hx_dcr_consume');\n\nalter table T_HX_DCR_CONSUME drop CONSTRAINT pk_t_hx_dcr_consume;\n\nselect count(1) from user_constraints where table_name = 'T_HX_DCR_CONSUME' and constraint_type ='U' and upper(constraint_name )=upper('pk_t_hx_dcr_consume');\n\nALTER TABLE T_HX_DCR_CONSUME DROP  CONSTRAINT pk_t_hx_dcr_consume;\n\nalter table t_hx_dcr_consume\n   add constraint pk_t_hx_dcr_consume\n      UNIQUE (CAV_MARK,COP_EXG_NO,EXG_VERSION,COP_IMG_NO);\n\nselect count(1) from user_constraints where table_name = 'T_HX_DCR_CONSUME'  and upper(constraint_name )=upper('pk_t_hx_dcr_consume');\n\nalter table T_HX_DCR_CONSUME drop constraint pk_t_hx_dcr_consume cascade drop index;\n\ncreate unique index pk_t_hx_dcr_consume on t_hx_dcr_consume(CAV_MARK,COP_EXG_NO,EXG_VERSION,COP_IMG_NO;\n\n  Map<String, Object> pt_map = new HashMap<>(16);\n  pt_map.put(\"pt_scrap_info\", \"T_HX_CALC_EXG_CVRT\");\n  for(String key:pt_map.keySet()){\n      String value = pt_map.get(key).toString();\n  }\n\n  mybatis传入单个字符判断,针对字符类型值最后加.toString()\n  <if test=\"COP_G_NO != null and COP_G_NO != '' and COP_G_NO=='0'.toString()\">\n   and COP_G_NO=#{COP_G_NO}\n  </if>\n  去除多余0\n  rtrim(rtrim(to_char(l.FACTOR_1,'fm99999999999990.9000000000000'),'0'),'.')  FACTOR_1,\n  执行存储过程\n  <parameterMap type=\"java.util.Map\" id=\"checkTmpMap\">\n      <parameter property=\"P_TEMP_OWNER\" mode=\"IN\" jdbcType=\"VARCHAR\"/>\n      <parameter property=\"P_FLAG\" mode=\"IN\" jdbcType=\"VARCHAR\"/>\n      <parameter property=\"P_RET_CODE\" mode=\"INOUT\" jdbcType=\"VARCHAR\"/>\n      <parameter property=\"P_RET_STR\" mode=\"INOUT\" jdbcType=\"VARCHAR\"/>\n  </parameterMap>\n  <select id=\"checkTmpByParam\" parameterMap=\"checkTmpMap\" statementType=\"CALLABLE\">\n      CALL P_EMS_CUS_EXG_LOCK(?,?,?,?)\n  </select>\n\n 删除分区\n <update id=\"deleteDataByDCJETOnOracle\" parameterType=\"java.util.Map\">\n      BEGIN\n      EXECUTE IMMEDIATE 'alter table ' || #{table_name} || ' truncate partition ' || #{dcjet};\n      END;\n  </update>\n  \nALTER TABLE list_example ADD PARTITION part04 VALUES ('TE');\n\nALTER TABLE  list_example MODIFY PARTITION part04 ADD VALUES('MIS');\n\nALTER TABLE  list_example MODIFY PARTITION part04 DROP VALUES('MIS');\n\n分析表释放内存\nanalyze table t_hx_calc_exg_con_sum compute statistics\n   \n\n// into 关键词可以将select得到的数据赋值给变量\nsum_number number(5);\nselect count(*) into sum_number from  student\n\n\n// %type   将表中的列的类型作为变量id的数据类型。\nid 表名.列名%type;\nselect sno into id from student where sname='mike'\n\n// %rowtype   将表一行的类型作为变量id的数据类型。\nid 表名%rowtype;\nselect * into id from student where sno='001'\n\n<2>复合类型变量\n记录类型\n\n可以存储多个标量值（即一行数据），结构与行相似。\n\n记录表类型\n\n允许用户在代码中使用“表”，以便存储多行数据。\n\nset serveroutput on\ndeclare\ntype t_table is table of varchar2(20) index by binary_integer;\nt t_table;\nbegin\nt(1) := 'a';\nt(2) := 'b';\ndbms_output.put_line(t.count())\nend\n/\n\n(3)条件判断语句\nIF语句\nIF condition1 THEN\n    statement1;\nELSIF condition2 THEN\n    statement12;\nELSE \n    statement3;\nEND IF;\n\nCASE语句\nCASE 变量\nWHEN 值1 THEN statement1;\nWHEN 值2 THEN statement2;\n...\n[ELSE statementS;]\nEND CASE;\n\n循环语句\n//第一种\nloop \n    statements;\nend loop;\n\n//第二种\nwhile condition loop\n    statements;\nend loop;\n\n//第三种\nfor i in 1..10 loop \n    statements;\nend loop;\n\n//跳出循环\n[exit when condition;]\n\n练习：创建student表（id，name）并将其放入到记录表变量中，然后将记录表变量中的数据打印出来。\n\ncreate table student (id integer,name varchar2(20));\n\ndeclare\ni student.id%type;\nname student.name%type;\n\nnum integer;\nbegin \nfor n in 1..10 loop\n    insert into student values(n,'user'||n);\nend loop;\nend;\n/\n\ndeclare\ntype s_record is record(\n    id student.id%type,\n    name student.name%type\n);\ntype s_recordtable is table of s_record index by binary_integer;\nt s_recordtable;\nm int :=1;\nbegin\nfor n in (select id,name from student)loop\n    t(m) := n;\n    m:=m+1;\nend loop;\ndbms_output.put_line('记录表的长度：'|| t.count());\nfor n in t.first()..t.last() loop\n    dbms_output.put_line(t(n).id ||'————'||t(n).name);\nend loop;\nend;\n/\n\n12、游标\n游标机制处理多行记录结果集；类似于指针，使程序一次可以处理其中的一行记录。\n\n12.1隐式游标\n执行一个SQL语句时，oracle服务器将自动创建一个隐式游标，这个游标存储执行SQL语句的结果。\n\n%found：布尔型，至少影响一行操作\n%notfound：布尔型，一行都不影响\n%isopen：布尔型，游标是否已打开\n%rowcount：number型，受SQL语句影响的行数\n\ndeclare\na student%rowtype;\nbegin \nselect * into a from student where id='5';\nupdate student set name='gaide' where id>'2';\ndbms_output.put_line('受上面一句SQL语句影响的行数:'||sql%rowcount);             --8\nif sql%found then\n    dbms_output.put_line('找到数据:'||a.id);\nend if;\nexception when others then \n    dbms_output.put_line('没有找到数据！');\nend;\n/\n\n12.2显式游标\n当查询结果返回多于一行时，必须使用显式游标。\n声明->打开->检索->关闭\n\ndeclare\n    cursor mycur(m integer) is select id,name from student where id>m;      -- 定义游标\n    type s_record is record(\n        id integer,\n        name varchar2(20)\n    );\n    s s_record;\nbegin \n    open mycur(3);                  -- 打开游标\n    loop\n        fetch mycur into s;         -- 利用游标检索数据，每次找出一行，然后赋值给s\n        exit when mycur%notfound;   -- 游标到最后了\n        dbms_output.put_line(s.id||'  '||s.name);\n    end loop;\n    close mycur;                    --关闭游标\nend;\n/\n\n\n\n//下面的是另外一种查询返回多行结果的方法，t是记录表类型\nfor n in (select id,name from student)loop\n    t(m) := n;\n    m:=m+1;\nend loop;\n\n--本周\nselect trunc(sysdate, 'd') + 1 from dual;\n\nselect trunc(sysdate, 'd') + 7 from dual;\n\n--本月\nselect trunc(sysdate, 'mm') from dual;\n\nselect last_day(trunc(sysdate)) from dual;\n--本季\n\nselect trunc(sysdate, 'Q') from dual;\n\nselect add_months(trunc(sysdate, 'Q'), 3) - 1 from dual;\n\n--本年\nselect trunc(sysdate, 'yyyy') from dual;\n\nselect add_months(trunc(sysdate, 'yyyy'), 12) - 1 from dual;\n\n-- 获取上月的开始时间和结束时间\nselect to_char(to_date(to_char(add_months(sysdate, -1), 'yyyy-mm'),'yyyy-mm'),'yyyy-mm-dd hh24:mi:ss') from dual;\n\nselect to_char(to_date(to_char(sysdate, 'yyyy-mm'), 'yyyy-mm'),'yyyy-mm-dd hh24:mi:ss') from dual;\n\n-- 获取前一天的开始时间和结束时间\nselect to_char(to_date(to_char(sysdate - 1, 'yyyy-mm-dd'), 'yyyy-mm-dd'),'yyyy-mm-dd hh24:mi:ss') from dual;\n\nselect to_char(to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd'),'yyyy-mm-dd hh24:mi:ss') from dual;\n\n-- 获取当前的开始时间\nselect to_date(to_char(sysdate, 'yyyy-mm-dd') || (to_char(sysdate, 'hh24')),'yyyy-mm-dd hh24') from dual;\n\n判断表存在及创建\n\n    declare  tableExist number;\n    begin\n    select count(1) into tableExist from user_tables where table_name=upper('OneCallPRTCP') ;\n    if tableExist = 0  then\n    execute immediate\n    'CREATE TABLE OneCallPRTCP(\n    OneCallPRTCPID NCHAR(36)  NOT NULL,\n    GisProcessID NCHAR(36)  NOT NULL,\n    TicketID NCHAR(36)  NOT NULL,\n    TicketNumber VARCHAR2(255)  NOT NULL,\n    Code VARCHAR2(50)  NOT NULL,\n    Status VARCHAR2(255)  NULL,\n    CommandText VARCHAR2(255)  NOT NULL,\n    DtPositiveResponse DATE NOT NULL,\n    UserIDPositiveResponse CHAR(36)  NULL,\n    ResultCode VARCHAR2(50)  NULL,\n    ResultStatus VARCHAR2(255)  NULL,\n    ResultText VARCHAR2(255)  NULL,\n    IsPROK CHAR(1) NOT NULL,\n    StageName VARCHAR2(50)  NOT NULL,\n    MemberCode VARCHAR2(50)  NULL,\n    constraint OneCallPRTCP_PK primary key (OneCallPRTCPID))';\n    end if;\n    end;\n\n//分析表\n\nanalyze table test compute statistics;\n\n--旧的写法\nUPDATE wefz TMP\n       SET TMP.TEMP_FLAG   = 1,\n           TMP.TEMP_REMARK = TMP.TEMP_REMARK || '|存在成品料号、料件料号、版本号都相同的多行数据'\n     WHERE EXISTS (SELECT 1\n              FROM weew TMP1\n             WHERE TMP1.TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65'\n               AND TMP.COP_EXG_NO = TMP1.COP_EXG_NO\n               AND TMP.COP_IMG_NO = TMP1.COP_IMG_NO\n               AND TMP.EXG_VERSION = TMP1.EXG_VERSION\n               AND TMP.SID <> TMP1.SID)\n       AND TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65';\n\n--新的写法，性能好点\n\nmerge into T_HX_STK_IMG t\nusing DC_EMS.T_EMS_CUS_IMG_CUR e\non (t.COP_G_NO = e.COP_G_NO AND t.TRADE_CODE = e.TRADE_CODE AND t.EMS_NO = e.EMS_NO)\nwhen matched then\nupdate\nset t.G_NO = e.G_NO\nwhere nvl(t.G_NO,'')='';\n\nMERGE INTO ewwe t\n            USING(SELECT COP_IMG_NO,COP_EXG_NO,EXG_VERSION FROM wew \n            WHERE TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65'\n            GROUP BY COP_IMG_NO,COP_EXG_NO,EXG_VERSION HAVING COUNT(1)>1) e\n            ON (t.COP_EXG_NO = e.COP_EXG_NO \n            AND t.COP_IMG_NO = e.COP_IMG_NO \n            AND t.EXG_VERSION = e.EXG_VERSION\n            AND t.TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65')\n            WHEN MATCHED THEN\n            UPDATE SET t.TEMP_FLAG   = 1, t.TEMP_REMARK = t.TEMP_REMARK || '|存在成品料号、料件料号、版本号都相同的多行数据'        \n\n     \n\n--新的写法，性能差点\nMERGE INTO wefwew t\n            USING(SELECT SID,COP_IMG_NO,COP_EXG_NO,EXG_VERSION \n            from wefwe\n            WHERE TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65') e\n            ON (t.COP_EXG_NO = e.COP_EXG_NO \n            AND t.COP_IMG_NO = e.COP_IMG_NO \n            AND t.EXG_VERSION = e.EXG_VERSION \n            AND t.SID <> e.SID \n            AND t.TEMP_OWNER = '547f1618-482f-4381-8f86-813f9822cc65')\n            WHEN MATCHED THEN\n            UPDATE SET t.TEMP_FLAG   = 1,t.TEMP_REMARK = t.TEMP_REMARK || '|存在成品料号、料件料号、版本号都相同的多行数据'\n\n\n判断视图是否存在，如果不存在，再创建：\n\ndeclare viewExist number;\nbegin\nselect count(1) into viewExist from user_views where VIEW_NAME='REPORT_APPOINTMENTSBYLOCATORS';\nif viewExist=0 then\nexecute immediate\n'CREATE  VIEW REPORT_APPOINTMENTSBYLOCATORS\nAS\nSELECT appointmentID, startDateTime, endDateTime, grid, locator, \n            meetingAddress, contactNumber, company, contact, reasonForAppointment,\n            DtFirstCall, DtSecondCall,CustomerAnswerFirstCall, CustomerAnswerSecondCall, \n            IsMeetOnSite, DtLastModified, AppointmentStatus, IsLocatorArriveOnsite, \n            DtCompletedAt,DtLocatorArriveOnsite, RescheduledOn, RescheduledAt, IsRescheduled, city\nFROM   Appointment';\nend if;\n\n\n判断存储过程\n\nselect count(*) count\nfrom user_objects \nwhere object_type = 'PROCEDURE'\nand object_name='TEST'\n\nmerge into we A USING (SELECT SID FROM (SELECT SID,ROWNUM RN\n    FROM wew\n    WHERE STATUS = 'R200'\n    AND LOCK_MARK IS NULL\n    AND BUSINESS_TYPE = #{businessType}\n    ORDER BY UPDATE_TIME ASC) WHERE RN &lt;= 1) B\n    ON (A.SID=B.SID)\n    WHEN MATCHED THEN\n    UPDATE SET A.STATUS = 'R300', A.LOCK_MARK = #{batchId}, A.BEGIN_DATE = F_XDO_CURRENT_TIMESTAMP()\n\n单纯执行sql\nSELECT #{total}/#{qty} from dual\n\nUPDATE\n    wew O\n    SET LOCK_MARK = #{batchId}\n    WHERE EXISTS(\n    SELECT 1\n    FROM (\n    SELECT SID,\n    ROW_NUMBER() OVER (\n    ORDER BY INSERT_TIME) RNUM\n    FROM wewe\n    WHERE BUSINESS_TYPE = #{businessType}\n    AND STATUS = #{lockStatus}\n    AND LOCK_MARK IS NULL) T\n    WHERE T.RNUM &lt;= #{batchLockMaxCount}\n    AND T.SID = O.SID)\n\n\n<select id=\"selectByFlag\" resultMap=\"hxStkBomTmpResultMap\" parameterType=\"map\">\n    select t.* from wew t\n    <where>\n        and t.TEMP_OWNER = #{TEMP_OWNER,jdbcType=VARCHAR}\n        AND t.TEMP_FLAG IN\n        <foreach item=\"item\" index=\"index\" collection=\"TEMP_FLAG\" open=\"(\" separator=\",\" close=\")\">\n            #{item}\n        </foreach>\n    </where>\n</select>\n\n<update id=\"updateStkBomList\" parameterType=\"java.lang.String\" databaseId=\"postgresql\">\n    update wew t\n        set dec_cm=p.dec_cm,\n            dec_dm_visiable=p.dec_dm_visiable,\n            dec_dm_invisiable=p.dec_dm_invisiable,\n            exg_g_name=p.exg_g_name,\n            img_g_name=p.img_g_name,\n            img_unit=p.img_unit,\n            note=p.note,\n            update_time=p.update_time,\n            update_user=p.update_user\n    from wew p\n    where t.cav_mark = #{cavMark}\n        and p.cav_mark = #{cavMark}\n        and t.type = p.type\n        and t.exg_version = p.exg_version\n        and t.cop_exg_no = p.cop_exg_no\n        and t.cop_img_no = p.cop_img_no\n        and p.temp_owner = #{batchId};\n    insert into wew (sid, trade_code, ems_no, dcr_times, cav_mark, cop_exg_no, cop_img_no, dec_cm, dec_dm_visiable,\n    exg_g_name, exg_version, img_g_name, img_unit, insert_time, insert_user, note, update_time,\n    update_user, type, dec_dm_invisiable, exg_g_no, img_g_no)\n    select sid, trade_code, ems_no, dcr_times::double precision, cav_mark, cop_exg_no, cop_img_no, dec_cm, dec_dm_visiable,\n    exg_g_name, exg_version, img_g_name, img_unit, insert_time, insert_user, note, update_time,\n    update_user, type, dec_dm_invisiable, exg_g_no, img_g_no\n    from t_hx_stk_bom_tmp p\n    where not exists(select 1\n    from wew t\n    where t.cav_mark = #{cavMark}\n    and p.cav_mark = #{cavMark}\n    and t.type = p.type\n    and t.exg_version = p.exg_version\n    and t.cop_exg_no = p.cop_exg_no\n    and t.cop_img_no = p.cop_img_no)\n    and p.temp_owner = #{batchId}\n</update>\n\n<update id=\"updateStkBomList\" parameterType=\"java.lang.String\">\n    merge into wew t\n    using wew p\n    on (t.cav_mark = #{cavMark}\n    and p.cav_mark = #{cavMark}\n    and t.type = p.type\n    and t.exg_version = p.exg_version\n    and t.cop_exg_no = p.cop_exg_no\n    and t.cop_img_no = p.cop_img_no and p.temp_owner = #{batchId})\n    when matched then\n    update\n    set dec_cm=p.dec_cm,\n    dec_dm_visiable=p.dec_dm_visiable,\n    dec_dm_invisiable=p.dec_dm_invisiable,\n    exg_g_name=p.exg_g_name,\n    img_g_name=p.img_g_name,\n    img_unit=p.img_unit,\n    note=p.note,\n    update_time=p.update_time,\n    update_user=p.update_user\n    when not matched then\n    insert (sid, trade_code, ems_no, dcr_times, cav_mark, cop_exg_no, cop_img_no, dec_cm, dec_dm_visiable, exg_g_name,\n    exg_version, img_g_name, img_unit, insert_time, insert_user, note, update_time, update_user, type,\n    dec_dm_invisiable, exg_g_no, img_g_no)\n    VALUES (p.sid, p.trade_code, p.ems_no, p.dcr_times, p.cav_mark, p.cop_exg_no, p.cop_img_no, p.dec_cm,\n    p.dec_dm_visiable, p.exg_g_name, p.exg_version, p.img_g_name, p.img_unit, p.insert_time, p.insert_user,\n    p.note, p.update_time, p.update_user, p.type, p.dec_dm_invisiable, p.exg_g_no, p.img_g_no)\n    where p.TEMP_OWNER = #{batchId}\n</update>\n\n<update id=\"updateStkIpImgList\" parameterType=\"java.lang.String\" databaseId=\"postgresql\">\n    update we t\n    set G_NAME=p.G_NAME,\n        UNIT=p.UNIT,\n        QTY=p.QTY,\n        CURR=p.CURR,\n        DEC_PRICE=p.DEC_PRICE,\n        DEC_TOTAL=p.DEC_TOTAL,\n        RATE=p.RATE,\n        NOTE=p.NOTE,\n        UPDATE_TIME=p.UPDATE_TIME,\n        UPDATE_USER=p.UPDATE_USER\n        from wewe p\n        where t.CAV_MARK = #{cavMark}\n        and p.CAV_MARK = #{cavMark}\n        and t.WO_NO = p.WO_NO\n        and t.COP_G_NO = p.COP_G_NO\n        and p.BATCH_NO = #{batchId}\n</update>\n\n<update id=\"updateStkIpImgList\" parameterType=\"java.lang.String\">\n    update wew t\n    set (\n        G_NAME,\n        UNIT,\n        QTY,\n        CURR,\n        DEC_PRICE,\n        DEC_TOTAL,\n        RATE,\n        NOTE,\n        UPDATE_TIME,\n        UPDATE_USER) =\n        (select\n        p.G_NAME,\n        p.UNIT,\n        p.QTY,\n        p.CURR,\n        p.DEC_PRICE,\n        p.DEC_TOTAL,\n        p.RATE,\n        p.NOTE,\n        p.UPDATE_TIME,\n        p.UPDATE_USER\n        from we p\n        where p.CAV_MARK = #{cavMark}\n        and t.WO_NO = p.WO_NO\n        and t.COP_G_NO = p.COP_G_NO\n        and p.BATCH_NO = #{batchId})\n    where t.CAV_MARK = #{cavMark}\n        and exists (select 1\n        from ewwe e\n        where e.CAV_MARK = #{cavMark}\n        and t.WO_NO = e.WO_NO\n        and t.COP_G_NO = e.COP_G_NO\n        and e.BATCH_NO = #{batchId}\n        )\n</update>\n\n<select id=\"updateIpImgQty\" parameterType=\"map\" databaseId=\"postgresql\">\n    UPDATE wewe s\n    SET IP_IMG_QTY = v.IP_IMG_QTY\n        FROM (SELECT t.CAV_MARK, t.COP_G_NO, f_xdo_nvl(sum(t.QTY),0.0) AS IP_IMG_QTY\n                        FROM wew t\n                        WHERE t.CAV_MARK = #{CAV_MARK,jdbcType=VARCHAR}\n                        group by t.CAV_MARK, t.COP_G_NO\n                ) v\n    WHERE s.CAV_MARK = #{CAV_MARK,jdbcType=VARCHAR}\n        AND s.COP_G_NO = v.COP_G_NO\n</select>\n\n使用merge into系进行数据写入：\n\nmerge into t_dept_total a using (select :deptno dept_no, to_date(:opdate,'yyyy-MM-dd')op_date,1 inc from dual) b \non (a.dept_no=b.dept_no and a.op_date=b.op_date) \nwhen matched then \n\nupdate set total=total+b.inc \n\nwhen not matched then\n\ninsert(dept_no,op_date,total) values(b.dept_no,b.op_date,b.inc)\n\nsql代码块之间需要加\\n\n\n<update id=\"updateCount\">\n    begin\n    update werw set COP_IMG_NO =#{COP_IMG_NO}\n    WHERE TEMP_OWNER =#{TEMP_OWNER}\n    AND EXG_VERSION BETWEEN #{BEGIN_START} AND #{BEGIN_END};\n\n    update we set COP_EXG_NO =#{COP_EXG_NO}\n    WHERE TEMP_OWNER =#{TEMP_OWNER}\n    AND EXG_VERSION BETWEEN #{BEGIN_START} AND #{BEGIN_END};\n    end;\n</update>\n\n<select id=\"updateIpCvrtQty\" parameterType=\"map\">\n    MERGE INTO we s\n    USING (SELECT t.CAV_MARK, t.COP_IMG_NO, f_xdo_nvl(sum(t.CVNT_QTY),0.0) AS IP_CVRT_QTY\n                        FROM wewe t\n                        WHERE t.CAV_MARK = #{CAV_MARK,jdbcType=VARCHAR}\n                        group by t.CAV_MARK, t.COP_IMG_NO\n            ) v\n    ON (s.CAV_MARK = #{CAV_MARK} and v.CAV_MARK = #{CAV_MARK} AND s.COP_G_NO = v.COP_IMG_NO)\n    WHEN MATCHED THEN\n    UPDATE SET s.IP_CVRT_QTY = v.IP_CVRT_QTY\n</select>\n\ninsert into ewwe\n    (sid,\n        trade_code,\n        ems_no,\n        dcr_times,\n        cav_mark,\n        cop_g_no,\n        g_name,\n        exg_version,\n        unit,\n        qty,\n        factory,\n        type,\n        note,\n        insert_time,\n        insert_user)\n        (select sys_guid(),\n                t.trade_code,\n                t.ems_no,\n                t.dcr_times,\n                t.cav_mark,\n                t.cop_g_no,\n                t.g_name,\n                t.exg_version,\n                t.unit,\n                t.qty,\n                t.factory,\n                t.type,\n                t.note,\n                f_xdo_current_timestamp(),\n                #{userNo}\n            from wewe t\n            where t.CAV_MARK = #{cavMark}\n            and t.business_type in ('EXG_RD_NO_ENTRY', 'EXG_RD_ENTRY')\n            and t.TYPE = '1'\n            and not exists (select 1\n                            from wew b\n                            where b.CAV_MARK = #{cavMark}\n                                and b.COP_EXG_NO = t.COP_G_NO\n                                and b.EXG_VERSION = t.EXG_VERSION))\n\n")])])]),e("p",[e("a",{attrs:{href:"https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html",target:"_blank",rel:"noopener noreferrer"}},[this._v("instant-client"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=t.exports}}]);