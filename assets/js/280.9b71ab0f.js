(window.webpackJsonp=window.webpackJsonp||[]).push([[280],{771:function(n,a,t){"use strict";t.r(a);var e=t(6),r=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"day14"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day14"}},[n._v("#")]),n._v(" day14")]),n._v(" "),t("p",[n._v("回顾:\n按照类型分:输入流和输出流\n输入流的抽象父类:java.io.InputStream\n基础流:节点流    FileInputStream\n拓展流  过滤流   BufferedInputStream")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("                    输入出流的抽象父类:java.io.OutputStream\n 按照功能分:字节流和字符流\n                    字符流:BufferedReader\n                               FileReader\n                     输出:PrintWriter\n                             FileWriter\n")])])]),t("hr"),n._v(" "),t("p",[n._v("防止乱码:你的编码文件和解码文件的字符编码集要一致\n编码:字符->字节\n解码:字节->字符")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("           GBK/gb2312\n           UTF-8\n           Big5  繁体字\n           ISO-8859-1\n")])])]),t("hr"),n._v(" "),t("h2",{attrs:{id:"提纲-1-randomaccessfile-随机访问流2-进程和线程的区别3-创建线程的两种方式4-线程的常用方法5-线程的状态6-线程的同步加锁7-线程之间的通信8-死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提纲-1-randomaccessfile-随机访问流2-进程和线程的区别3-创建线程的两种方式4-线程的常用方法5-线程的状态6-线程的同步加锁7-线程之间的通信8-死锁"}},[n._v("#")]),n._v(" 提纲:\n1.RandomAccessFile   随机访问流\n2.进程和线程的区别\n3.创建线程的两种方式\n4.线程的常用方法\n5.线程的状态\n6.线程的同步加锁\n7.线程之间的通信\n8.死锁")]),n._v(" "),t("p",[n._v("知识点1:随机访问流   RandomAccessFile\n作用:可以定位到文件中的具体的位置进行读取")]),n._v(" "),t("p",[n._v("构造:\npublic RandomAccessFile(String path,String mode);")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("  mode是啥?\n  是文件打开的方式\n  r   只读\n  rw  读写\n\n  常用方法:\n          read();//读取单个字节\n          readLine();//读取一行\n          seek(long l);//定位   注意:一般是先定位再读取\n")])])]),t("hr"),n._v(" "),t("p",[n._v("Thread:\n1.进程和线程的区别:\n进程:正在运行的程序,如JVM进程,QQ进程\n线程:运行在进程的内部,共享进程,并且拥有独立的运行空间\n2.创建线程的两种方式:\na.继承java.lang.Thread 类\nb.实现 java.lang.Runable 接口\n3.常用方法:\n构造:\na.Thread t1 = new ThreadDemo1();\nb.Thread t2 = new Thread(new ThreadDemo2());\n常用方法:\n1.currentThread();//返回当前的线程\n2.getName();//返回当前线程的名称\n3.getPriority() ;//获取线程的优先级"),t("br"),n._v('\n4.setPriority();//设置线程的优先级[1-10]\n注意:并不是你设置的线程的优先级越高,就一定是它先运行\n5.interrupt() ;//中断线程\n6.join();// 等待该线程终止   让其他线程对象调用该方法,使自己进入阻塞状态\n7.sleep();//睡\n8.start();//呼叫JVM去调用run方法\n4.线程的状态:\n1.初始态(Beginning)\nThread t1 = new ThreadDemo();\n2.就绪态(Locking),也称为可运行态\nt1.start();\n3.运行态(Running)\n4.阻塞态\n通常情况下,正在运行的状态在如下三种场景会进入阻塞状态\na.等待用户输入\nb.sleep\nc.调用其他线程对象t2的join方法\n打破阻塞态,让程序重新进入运行态:\na.用户输入完毕\nb.睡眠时间到了,或者被其他线程中断\nc.t2线程运行结束,或者别其他线程中断\n5.终止态\n线程运行结束\n6."锁池"\n是一种特殊的阻塞状态,当线程来执行同步代码的时候,JVM\n会检查该线程对象是否拥有"锁"标记,有的话,就让线程进入同步代码\n并执行,否则,让该线程对象进入临界资源到"锁池"\n7.等待队列\n也是一种特殊的阻塞状态,但是JVM不会主动去调用,\n它必须是由其他线程调用notify或者notifyAll来唤醒此\n状态下的线程.让线程重返临界资源的"锁池"当中\n多线程并发访问控制:\n当多个线程操作同一个资源的时候,如果这种操作涉及到修改之类,会造成数据不一致\n在Java中,采用"锁"机制来实现线程同步')]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('        锁(Lock):是一种同步资源,它是对象所拥有的,并且当线程同步时,这个"锁"才会出现\n\n       如何实现线程同步:\n       关键字:synchronized\n\n       内同步和外同步\n\n       外同步锁加在方法上\n\n       //相当于  将整个对象当成临界资源\n        public static synchronized void withdraw(){\n              \n        }\n\n       内同步锁加在方法体中\n               public static  void withdraw(){\n                      synchronized(临界资源1){\n                            \n                      }\n                      synchronized(临界资源2){\n                            \n                      }\n                        synchronized(临界资源3){\n                            \n                      }\n        }\n')])])]),t("hr"),n._v(" "),t("h2",{attrs:{id:"死锁-多个线程在同一时刻抢占同一个资源-形成了环路等待状态-案例-静态域会造成死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁-多个线程在同一时刻抢占同一个资源-形成了环路等待状态-案例-静态域会造成死锁"}},[n._v("#")]),n._v(" 死锁:多个线程在同一时刻抢占同一个资源,形成了环路等待状态.\n案例:静态域会造成死锁")]),n._v(" "),t("h2",{attrs:{id:"线程之间如何实现通行-notify-唤醒在此对象监视器上等待的单个线程。notifyall-唤醒在此对象监视器上等待的所有线程。wait-在其他线程调用此对象的-notify-方法或-notifyall-方法前-导致当前线程等待。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程之间如何实现通行-notify-唤醒在此对象监视器上等待的单个线程。notifyall-唤醒在此对象监视器上等待的所有线程。wait-在其他线程调用此对象的-notify-方法或-notifyall-方法前-导致当前线程等待。"}},[n._v("#")]),n._v(" 线程之间如何实现通行:\nnotify:\n唤醒在此对象监视器上等待的单个线程。\nnotifyAll:\n唤醒在此对象监视器上等待的所有线程。\nwait:\n在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。")]),n._v(" "),t("p",[n._v("单元测试:对程序中最小单元进行测试和验证\n白盒测试:需要代码走查\n黑盒测试:测试功能")])])}),[],!1,null,null,null);a.default=r.exports}}]);