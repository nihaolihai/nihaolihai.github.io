(window.webpackJsonp=window.webpackJsonp||[]).push([[447],{937:function(n,e,t){"use strict";t.r(e);var r=t(6),i=Object(r.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-mvc的转发与重定向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的转发与重定向"}},[this._v("#")]),this._v(" Spring MVC的转发与重定向")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('重定向是将用户从当前处理请求定向到另一个视图（例如 JSP）或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域；转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。\n\n转发是服务器行为，重定向是客户端行为。\n1）转发过程\n客户浏览器发送 http 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request。\n\n在客户浏览器的地址栏中显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。\n2）重定向过程\n客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户。\n\n在这里 location 可以重定向到任意 URL，既然是浏览器重新发出了请求，那么就没有什么 request 传递的概念了。在客户浏览器的地址栏中显示的是其重定向的路径，客户可以观察到地址的变化。重定向行为是浏览器做了至少两次的访问请求。\n\n在 Spring MVC 框架中，控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。示例代码如下：\n@RequestMapping("/register")\npublic String register() {\n    return "register";  //转发到register.jsp\n}\n在 Spring MVC 框架中，重定向与转发的示例代码如下：\npackage controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\n@RequestMapping("/index")\npublic class IndexController {\n    @RequestMapping("/login")\n    public String login() {\n        //转发到一个请求方法（同一个控制器类可以省略/index/）\n        return "forward:/index/isLogin";\n    }\n    @RequestMapping("/isLogin")\n    public String isLogin() {\n        //重定向到一个请求方法\n        return "redirect:/index/isRegister";\n    }\n    @RequestMapping("/isRegister")\n    public String isRegister() {\n        //转发到一个视图\n        return "register";\n    }\n}\n在 Spring MVC 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 DispatcherServlet 的资源，例如：\nreturn "forward:/html/my.html";\n\n则需要使用 mvc：resources 配置：\n<mvc:resources location="/html/" mapping="/html/**" />\n\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);