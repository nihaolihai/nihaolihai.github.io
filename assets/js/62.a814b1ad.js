(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{562:function(t,n,a){"use strict";a.r(n);var s=a(6),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"条例12-总是重写tostring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条例12-总是重写tostring"}},[t._v("#")]),t._v(" 条例12： 总是重写toString")]),t._v(" "),a("p",[t._v("尽管Object提供了toString方法的实现，但它返回的字符串通常不是类的用户希望看到的。它由类名后跟着@符号和哈希码的无符号十六进制表， 比如PhoneNumber@163b91。toString的通用契约说返回的字符串应该是“简洁但是容易被阅读的信息表示”。虽然PhoneNumber@163b91可被争论为 简单且易读的，但它和707-867-5309比起来显得缺乏信息量。toString契约继续说，推荐所有子类重写这个方法。确实是个好建议。")]),t._v(" "),a("p",[t._v("尽管遵守该契约不如遵守equals和hashCode契约（条例10，11）来得关键，但是提供好的toString实现使得类使用起来更愉快，使用这些类的系统也 更容易调试。当对象传递给println,printf，字符串连接符，或者assert，或调试器打印时都会字段调用toString方法。甚至你从不调用对象的toString 方法，其他人可能会调用。比如，引用了你的对象的组件可能在打印的错误消息中包含对象的字符串表示。如果没重写toString方法。这条消息可能毫无用处。")]),t._v(" "),a("p",[t._v('如果为PhoneNumber提供了好的toString方法，可以轻松地像下面这样提供一个有用的诊断信息： System.out.println("Failed to connect to " + phoneNumber);')]),t._v(" "),a("p",[t._v("程序员会以这种方式生成诊断信息，不管是否重写了toString方法，但是除非重写了toString，否则信息没什么用。提供好的toString方法的好处从类的 实例延伸到包含这些实例的引用的对象，尤其是集合。当打印map时，你更愿意看到{Jenny=PhoneNumber@163b91}还是{Jenny=707-867-5309}?")]),t._v(" "),a("p",[t._v("实际可行时，toString方法应该返回对象中所有感兴趣的信息，就像电话号码例子中展示的。如果对象很大或包含的状态不适合字符串表示时，那么展示所有 信息是不切实际的。在这些情况下，toString方法应该返回如曼哈顿居民电话目录（1487536项）或线程[main, 5, main]。理想情况下，字符串应该是 自解释的（线程的例子，，，，todo）。字符串中未包含对象所有感兴趣信息的一个特别恼人的场景是如下的测试失败报告：")]),t._v(" "),a("p",[t._v("Assertion failure: expected {abc, 123}, but was {abc, 123}.\n当实现toString方法时要做的一个重要的决定是是否在文档中指定返回值的格式。推荐在值类中指定，比如电话号码或矩阵类。指定格式的好处是它以标准， 无歧义，可读性高的对象表示。这个表示可用在输入输出和持久的人类可读的数据对象中，比如CSV文件。如果指定了格式。通常提供一个匹配的静态工厂 或构造函数是一个好主意。这样程序员可以轻松在对象和它的字符串表示中来回转换。这种方式被Java平台类库中的许多值类采用，包括BigInteger， BigDecimal和大多数装箱的原始类。")]),t._v(" "),a("p",[t._v("指定toString返回值的缺点是一旦指定它，你将对它动弹不得，假设你的类被广泛使用。程序员会编写代码转换表示，生成它，或嵌到持久数据中。 如果未来版本中改变了类的字符串表示，你会破坏他们的代码和数据，他们会吼。如果选择不指定格式，你可以保留添加信息或在后续版本中改进格式的弹性。")]),t._v(" "),a("p",[t._v("不管你决定要不要指定格式，应该清楚地记录下你的意图。如果指定了格式，应该准确地记录。比如，下面是在条例11中PhoneNumber的toString方法。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n* 返回电话号码的字符串表示\n* 字符串由12个字符构成，格式为"XXX-YYY-ZZZZ", XXX是区号, YYY是前缀, \n* ZZZZ是线号. 每个大写字母代码单个十进制数字。\n* 如果电话号码的这三部分的任何一部分不足以填满字段，字段将以前导0补齐\n* 比如如果线号为123, 电话号码最后4个字符的字符串表示会是"0123"。\n*/')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("format")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%03d-%03d-%04d"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("areaCode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" lineNum"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("如果决定不指定格式，文档注释应该是这样的")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/**\n* 返回此药剂的简要说明。 表示的准确细节未指定且按实际变动为准\n* 可如下可视为典型：\n*\n* "[药剂 #9: 类型=爱, 口味=松脂, 外观=印度墨]"\n*/')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("读了这个注释后，当格式变更时，依赖此格式细节编写代码或持久化数据的人只能怪他们自己。 不管你是否指定格式，提供对toString方法返回值包含的信息的编程访问。比如，PhoneNumber类应该包含区号，前缀和线号的访问器。 如果没有提供，那么会强迫需要信息的程序员来转换字符串。除了会降低性能和增加程序员不必要的工作，这个过程容易出错且一旦更改了格式后导致 系统异常，变得脆落。没有提供访问器，那么就会将字符串变为API，即便被指出它可能变化。")]),t._v(" "),a("p",[t._v("在静态工具列中编写toString方法是没有意义的（条例4）。也不该在大多数枚举类型（条例34）中写toString方法，因为Java提供了一个完美的。 然而应该在那些子类共享公共字符串的抽象类中编写toString方法。比如，大多数集合实现都从抽象的集合类中继承了toString方法。")]),t._v(" "),a("p",[t._v("谷歌的开源AutoValue设施，在条例10中讨论的，会为你产生toString方法，大多数IDE也会。这些方法擅长告诉你每个字段的内容，但是没有专注于类的 含义。所以，比如，不适合在我们的PhoneNumber类中使用自动生成的toString方法（因为电话号码有标准的字符串表示），但是对于Potion类是完美采用的。 也就是说，自动生成的toString方法远比从Object中继承的可取，Object没有告诉你任何关于对象的值。")]),t._v(" "),a("p",[t._v("回顾下，在每个编写的可实例化类中重写Object的toString实现，除非父类已经进行了重写。它让类更加好用且有助于调试。toString方法应该返回一个 简介的，有用的对象描述。以美观的形式")])])}),[],!1,null,null,null);n.default=r.exports}}]);