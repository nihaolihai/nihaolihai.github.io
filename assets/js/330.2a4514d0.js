(window.webpackJsonp=window.webpackJsonp||[]).push([[330],{823:function(n,e,t){"use strict";t.r(e);var i=t(6),r=Object(i.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud-feign的自定义配置及使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-feign的自定义配置及使用"}},[this._v("#")]),this._v(" Spring Cloud Feign的自定义配置及使用")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('日志配置\n有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的日志了，以此让 Feign 把请求信息输出来。\n\n首先定义一个配置类，代码如下所示。\n@Configuration\npublic class FeignConfiguration {\n    /**\n     * 日志级别\n     *\n     * @return\n     */\n    @Bean\n    Logger.Level feignLoggerLevel() {\n        return Logger.Level.FULL;\n    }\n}\n通过源码可以看到日志等级有 4 种，分别是：\nNONE：不输出日志。\nBASIC：只输出请求方法的 URL 和响应的状态码以及接口执行的时间。\nHEADERS：将 BASIC 信息和请求头信息输出。\nFULL：输出完整的请求信息。\n\nFeign 日志等级源码如下图所示：\npublic enum Level {\n    NONE,\n    BASIC,\n    HEADERS,\n    FULL\n}\n\n配置类建好后，我们需要在 Feign Client 中的 @FeignClient 注解中指定使用的配置类，代码如下所示。\n@FeignClient(value = "eureka-client-user-service", configuration = FeignConfiguration. class)\npublic interface UserRemoteClient {\n    // ...\n}\n\n在配置文件中执行 Client 的日志级别才能正常输出日志，格式是“logging.level.client 类地址=级别”。\nlogging.level.net.biancheng.feign_demo.remote.UserRemoteClient=DEBUG\n\n最后通过 Feign 调用我们的 /user/hello 接口\n\n契约配置\nSpring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，原生的使用方法我们在后面会讲解。\n\n如果你想在 Spring Cloud 中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract，代码如下所示。\n@Configuration\npublic class FeignConfiguration {\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n}\n当你配置使用默认的契约后，之前定义的 Client 就用不了，之前上面的注解是 Spring MVC 的注解。\nBasic 认证配置\n通常我们调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，比如 Basic 认证方式。在 Feign 中我们可以直接配置 Basic 认证，代码如下所示。\n@Configuration\npublic class FeignConfiguration {\n    @Bean\n    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {\n        return new BasicAuthRequestInterceptor("user", "password");\n    }\n}\n或者你可以自定义属于自己的认证方式，其实就是自定义一个请求拦截器。在请求之前做认证操作，然后往请求头中设置认证之后的信息。通过实现 RequestInterceptor 接口来自定义认证方式，代码如下所示。\npublic class FeignBasicAuthRequestInterceptor implements RequestInterceptor {\n    public FeignBasicAuthRequestInterceptor() {\n    }\n    @Override\n    public void apply(RequestTemplate template) {\n        // 业务逻辑\n    }\n}\n然后将配置改成我们自定义的就可以了，这样当 Feign 去请求接口的时候，每次请求之前都会进入 FeignBasicAuthRequestInterceptor 的 apply 方法中，在里面就可以做属于你的逻辑了，代码如下所示。\n@Configuration\npublic class FeignConfiguration {\n    @Bean\n    public FeignBasicAuthRequestInterceptor basicAuthRequestInterceptor() {\n        return new FeignBasicAuthRequestInterceptor();\n    }\n}\n超时时间配置\n通过 Options 可以配置连接超时时间和读取超时时间（代码如下所示），Options 的第一个参数是连接超时时间（ms），默认值是 10×1000；第二个是取超时时间（ms），默认值是 60×1000。\n@Configuration\npublic class FeignConfiguration {\n    @Bean\n    public Request.Options options() {\n        return new Request.Options(5000, 10000);\n    }\n}\n客户端组件配置\nFeign 中默认使用 JDK 原生的 URLConnection 发送 HTTP 请求，我们可以集成别的组件来替换掉 URLConnection，比如 Apache HttpClient，OkHttp。\n\n配置 OkHttp 只需要加入 OkHttp 的依赖，代码如下所示。\n<dependency>\n    <groupId>io.github.openfeign</groupId>\n    <artifactId>feign-okhttp</artifactId>\n</dependency>\n\n然后修改配置，将 Feign 的 HttpClient 禁用，启用 OkHttp，配置如下：\n#feign 使用 okhttp\nfeign.httpclient.enabled=false\nfeign.okhttp.enabled=true\n\n关于配置可参考源码 org.springframework.cloud.openfeign.FeignAutoConfiguration。\nHttpClient 自动配置源码如下所示：\n@Configuration\n@ConditionalOnClass(ApacheHttpClient.class)\n@ConditionalOnMissingClass("com.netflix.loadbalancer.ILoadBalancer")\n@ConditionalOnProperty(value = "feign.httpclient.enabled", matchIfMissing = true)\nprotected static class HttpClientFeignConfiguration {\n    @Autowired(required = false)\n    private HttpClient httpClient;\n    @Bean\n    @ConditionalOnMissingBean(Client.class)\n    public Client feignClient() {\n        if (this.httpClient != null) {\n            return new ApacheHttpClient(this.httpClient);\n        }\n        return new ApacheHttpClient();\n    }\n}\nOkHttp 自动配置源码如下所示：\n@Configuration\n@ConditionalOnClass(OkHttpClient.class)\n@ConditionalOnMissingClass("com.netflix.loadbalancer.ILoadBalancer")\n@ConditionalOnProperty(value = "feign.okhttp.enabled", matchIfMissing = true)\nprotected static class OkHttpFeignConfiguration {\n    @Autowired(required = false)\n    private okhttp3.OkHttpClient okHttpClient;\n    @Bean\n    @ConditionalOnMissingBean(Client.class)\n    public Client feignClient() {\n        if (this.okHttpClient != null) {\n            return new OkHttpClient(this.okHttpClient);\n        }\n        return new OkHttpClient();\n    }\n}\n上面所示两段代码分别是配置 HttpClient 和 OkHttp 的方法。其通过 @ConditionalOnProperty 中的值来决定启用哪种客户端（HttpClient 和 OkHttp），@ConditionalOnClass 表示对应的类在 classpath 目录下存在时，才会去解析对应的配置文件。\nGZIP 压缩配置\n开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP 来压缩数据：\nfeign.compression.request.enabled=true\nfeign.compression.response.enabled=true\n\n还可以配置压缩的类型、最小压缩值的标准：\nfeign.compression.request.mime-types=text/xml,application/xml,application/json\nfeign.compression.request.min-request-size=2048\n\n只有当 Feign 的 Http Client 不是 okhttp3 的时候，压缩才会生效，配置源码在 org.spring-framework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration，代码如下所示。\n@Configuration\n@EnableConfigurationProperties(FeignClientEncodingProperties.class)\n@ConditionalOnClass(Feign.class)\n@ConditionalOnBean(Client.class)\n@ConditionalOnProperty(value = "feign.compression.response.enabled", matchIfMissing = false)\n@ConditionalOnMissingBean(type = "okhttp3.OkHttpClient")\n@AutoConfigureAfter(FeignAutoConfiguration.class)\npublic class FeignAcceptGzipEncodingAutoConfiguration {\n    @Bean\n    public FeignAcceptGzipEncodingInterceptor feignAcceptGzipEncodingInterceptor(\n            FeignClientEncodingProperties properties) {\n        return new FeignAcceptGzipEncodingInterceptor(properties);\n    }\n}\n核心代码就是 @ConditionalOnMissingBean（type="okhttp3.OkHttpClient"），表示 Spring BeanFactory 中不包含指定的 bean 时条件匹配，也就是没有启用 okhttp3 时才会进行压缩配置。\n编码器解码器配置\nFeign 中提供了自定义的编码解码器设置，同时也提供了多种编码器的实现，比如 Gson、Jaxb、Jackson。我们可以用不同的编码解码器来处理数据的传输。如果你想传输 XML 格式的数据，可以自定义 XML 编码解码器来实现获取使用官方提供的 Jaxb。\n\n配置编码解码器只需要在 Feign 的配置类中注册 Decoder 和 Encoder 这两个类即可，代码如下所示。\n@Bean\npublic Decoder decoder() {\n    return new MyDecoder();\n}\n@Bean\npublic Encoder encoder() {\n    return new MyEncoder();\n}\n使用配置自定义 Feign 的配置\n除了使用代码的方式来对 Feign 进行配置，我们还可以通过配置文件的方式来指定 Feign 的配置。\n# 链接超时时间\nfeign.client.config.feignName.connectTimeout=5000\n# 读取超时时间\nfeign.client.config.feignName.readTimeout=5000\n# 日志等级\nfeign.client.config.feignName.loggerLevel=full\n# 重试\nfeign.client.config.feignName.retryer=com.example.SimpleRetryer\n# 拦截器\nfeign.client.config.feignName.requestInterceptors[0]=com.example.FooRequestInterceptor\nfeign.client.config.feignName.requestInterceptors[1]=com.example.BarRequestInterceptor\n# 编码器\nfeign.client.config.feignName.encoder=com.example.SimpleEncoder\n# 解码器\nfeign.client.config.feignName.decoder=com.example.SimpleDecoder\n# 契约\nfeign.client.config.feignName.contract=com.example.SimpleContract\n\n继承特性\nFeign 的继承特性可以让服务的接口定义单独抽出来，作为公共的依赖，以方便使用。\n\n创建一个 Maven 项目 feign-inherit-api，用于存放 API 接口的定义，增加 Feign 的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n\n定义接口，指定服务名称，代码如下所示。\n@FeignClient("feign-inherit-provide")\npublic interface UserRemoteClient {\n    @GetMapping("/user/name")\n    String getName();\n}\n创建一个服务提供者 feign-inherit-provide，引入 feign-inherit-api，代码如下所示。\n<dependency>\n    <groupId>net.biancheng</groupId>\n    <artifactId>feign-inherit-api</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n\n实现 UserRemoteClient 接口，代码如下所示。\n@RestController\npublic class DemoController implements UserRemoteClient {\n    @Override\n    public String getName() {\n        return "zhangsan";\n    }\n}\n创建一个服务消费者 feign-inherit-consume，同样需要引入 feign-inherit-api 用于调用 feign-inherit-provide 提供的 /user/name 接口，代码如下所示。\n@RestController\npublic class DemoController {\n    @Autowired\n    private UserRemoteClient userRemoteClient;\n    @GetMapping("/call")\n    public String callHello() {\n        String result = userRemoteClient.getName();\n        System.out.println("getName调用结果：" + result);\n    }\n}\n通过将接口的定义单独抽出来，服务提供方去实现接口，服务消费方直接就可以引入定义好的接口进行调用，非常方便。\n多参数请求构造\n多参数请求构造分为 GET 请求和 POST 请求两种方式，首先来看 GET 请求的多参数请求构造方式，代码如下所示。\n@GetMapping("/user/info")\nString getUserInfo(@RequestParam("name")String name,@RequestParam("age")int age);\n\n另一种是通过 Map 来传递多个参数，参数数量可以动态改变，笔者在这里还是推荐大家用固定的参数方式，不要用 Map 来传递参数，Map 传递参数最大的问题是可以随意传参。代码如下所示。\n@GetMapping("/user/detail")\nString getUserDetail(@RequestParam Map<String, Object> param);\n\nPOST 请求多参数就定义一个参数类，通过 @RequestBody 注解的方式来实现，代码如下所示。\n@PostMapping("/user/add")\nString addUser(@RequestBody User user);\n\n实现类中也需要加上 @RequestBody 注解，代码如下所示。\n@RestController\npublic class DemoController implements UserRemoteClient {\n    @Override\n    public String addUser(@RequestBody User user) {\n        return user.getName();\n    }\n}\n注意：使用继承特性的时候实现类也需要加上 @RequestBody 注解。\n\n\n')])])])])}),[],!1,null,null,null);e.default=r.exports}}]);