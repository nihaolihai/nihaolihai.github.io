(window.webpackJsonp=window.webpackJsonp||[]).push([[381],{870:function(n,e,r){"use strict";r.r(e);var t=r(6),o=Object(t.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-boot-starter的介绍及使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-starter的介绍及使用"}},[this._v("#")]),this._v(" Spring Boot Starter的介绍及使用")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('目前提供的 Spring Boot Starter 包有：\nspring-boot-starter-web：快速构建基于 Spring MVC 的 Web 项目，使用 Tomcat 做默认嵌入式容器。\nspring-boot-starter-data-redis：操作 Redis。\nspring-boot-starter-data-mongodb：操作 Mongodb。\nspring-boot-starter-data-jpa：操作 Mysql。\nspring-boot-starter-activemq：操作 Activemq。\n……\n\n自动配置非常方便，当我们要操作 Mongodb 的时候，只需要引入 spring-boot-starter-data-mongodb 的依赖，然后配置 Mongodb 的链接信息 spring.data.mongodb.uri=mongodb：//localhost/test 就可以使用 MongoTemplate 来操作数据，MongoTemplate 的初始化工作全部交给 Starter 来完成。\n\n自动配置麻烦的是当出现错误时，排查问题的难度上升了。自动配置的逻辑都在 Spring Boot Starter 中，要想快速定位问题，就必须得了解 Spring Boot Starter 的内部原理。接下来我们自己动手来实现一个 Spring Boot Starter。\nSpring Boot Starter项目创建\n创建一个项目 spring-boot-starter-demo，pom.xml 配置代码如下所示。\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n</dependencies>\n创建一个配置类，用于在属性文件中配置值，相当于 spring.data.mongo 这种形式，代码如下所示。\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport lombok.Data;\n@Data\n@ConfigurationProperties("spring.user")\npublic class UserPorperties {\n    private String name;\n}\n再定义一个 Client，相当于 MongoTemplate，里面定一个方法，用于获取配置中的值，代码如下所示。\npublic class UserClient {\n    private UserPorperties userPorperties;\n    public UserClient() {\n    }\n    public UserClient(UserPorperties p) {\n        this.userPorperties = p;\n    }\n    public String getName() {\n        return userPorperties.getName();\n    }\n}\n自动创建客户端\n一个最基本的 Starter 包定义好了，但目前肯定是不能使用 UserClient，因为我们没有自动构建 UserClient 的实例。接下来开始构建 UserClient，代码如下所示。\n@Configuration\n@EnableConfigurationProperties(UserPorperties.class)\npublic class UserAutoConfigure {\n    @Bean\n    @ConditionalOnProperty(prefix = "spring.user", value = "enabled", havingValue = "true")\n    public UserClient userClient(UserPorperties userPorperties) {\n        return new UserClient(userPorperties);\n    }\n}\nSpring Boot 会默认扫描跟启动类平级的包，假如我们的 Starter 跟启动类不在同一个主包下，如何能让 UserAutoConfigure 生效？\n\n在 resources 下创建一个 META-INF 文件夹，然后在 META-INF 文件夹中创建一个 spring.factories 文件，文件中指定自动配置的类：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.cxytiandi.demo.UserAutoConfigure\n\nSpring Boot 启动时会去读取 spring.factories 文件，然后根据配置激活对应的配置类，至此一个简单的 Starter 包就实现了。\n使用 Starter\n现在可以在其他的项目中引入这个 Starter 包，代码如下所示。\n<dependency>\n    <groupId>com.cxytiandi</groupId>\n    <artifactId>spring-boot-starter-demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n引入之后就直接可以使用 UserClient，UserClient 在项目启动的时候已经自动初始化好，代码如下所示。\n@RestController\npublic class UserController {\n    @Autowired\n    private UserClient userClient;\n    @GetMapping("/user/name")\n    public String getUserName() {\n        return userClient.getName();\n    }\n}\n属性文件中配置 name 的值和开启 UserClient：\nspring.user.name=zhangsan\nspring.user.enabled=true\n\n访问 /user/name 就可以返回我们配置的 zhangsan。\n使用注解开启 Starter 自动构建\n很多时候我们不想在引入 Starter 包时就执行初始化的逻辑，而是想要由用户来指定是否要开启 Starter 包的自动配置功能，比如常用的 @EnableAsync 这个注解就是用于开启调用方法异步执行的功能。\n\n同样地，我们也可以通过注解的方式来开启是否自动配置，如果用注解的方式，那么 spring.factories 就不需要编写了，下面就来看一下怎么定义启用自动配置的注解，代码如下所示。\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import({UserAutoConfigure.class})\npublic @interface EnableUserClient {\n\n}\n\n这段代码的核心是 @Import（{UserAutoConfigure.class}），通过导入的方式实现把 UserAutoConfigure 实例加入 SpringIOC 容器中，这样就能开启自动配置了。\n\n使用方式就是在启动类上加上该注解，代码如下所示。\n@SpringBootApplication\npublic class SpringBootDemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDemoApplication.class, args);\n    }\n}\n使用配置开启 Starter 自动构建\n在某些场景下，UserAutoConfigure 中会配置多个对象，对于这些对象，如果不想全部配置，或是想让用户指定需要开启配置的时候再去构建对象，这个时候我们可以通过 @ConditionalOnProperty 来指定是否开启配置的功能，代码如下所示。\n@Bean\n@ConditionalOnProperty(prefix = "spring.user",value = "enabled",havingValue = "true")\npublic UserClient userClient(UserPorperties userPorperties) {\n    return new UserClient(userPorperties);\n}\n通过上面的配置，只有当启动类加了 @EnableUserClient 并且配置文件中 spring.user.enabled=true 的时候才会自动配置 UserClient。\n配置 Starter 内容提示\n在自定义 Starter 包的过程中，还有一点比较重要，就是对配置的内容项进行提示，需要注意的是，Eclipse 中是不支持提示的，Spring Tools 4 for Eclipse 中可以提示。\n\n定义提示内容需要在 META-INF 中创建一个 spring-configuration-metadata.json 文件，代码如下所示。\n{ "properties": [ { "name": "spring.user.name", "defaultValue": "cxytinadi" }, { "name": "spring.user.enabled", "type": "java.lang.Boolean", "defaultValue": false } ] }\n\nname：配置名\ntype：配置的数据类型\ndefaultValue：默认值\n\n')])])])])}),[],!1,null,null,null);e.default=o.exports}}]);