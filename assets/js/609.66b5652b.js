(window.webpackJsonp=window.webpackJsonp||[]).push([[609],{1103:function(n,e,t){"use strict";t.r(e);var a=t(6),s=Object(a.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring基于xml装配bean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring基于xml装配bean"}},[this._v("#")]),this._v(" Spring基于XML装配Bean")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('Bean 的装配可以理解为依赖关系注入，Bean 的装配方式也就是 Bean 的依赖注入方式。Spring 容器支持多种形式的 Bean 的装配方式，如基于 XML 的 Bean 装配、基于 Annotation 的 Bean 装配和自动装配等。\n\nSpring 基于 XML 的装配通常采用两种实现方式，即设值注入（Setter Injection）和构造注入（Constructor Injection）。本节将讲解如何在 XML 配置文件中使用这两种注入方式。\n\n在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足以下两点要求。\n必须提供一个默认的无参构造方法。\n必须为需要注入的属性提供对应的 setter 方法。\n\n使用设值注入时，在 Spring 配置文件中，需要使用 <bean> 元素的子元素 <property> 元素为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 <constructor-arg> 标签定义构造方法的参数，可以使用其 value 属性（或子元素）设置该参数的值。下面通过案例演示基于 XML 方式的 Bean 的装配。\n1. 创建 Person 类\n在项目 springDemo02 中的 src 目录下，创建一个名称为 com.mengma.assembly 的包，在该包下创建一个 Person 类，如下所示。\npackage com.mengma.assembly;\npublic class Person {\n    private String name;\n    private int age;\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    // 重写toString()方法\n    public String toString() {\n        return "Person[name=" + name + ",age=" + age + "]";\n    }\n    // 默认无参的构造方法\n    public Person() {\n        super();\n    }\n    // 有参的构造方法\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n}\n上述代码中，定义了 name 和 age 两个属性，并为其提供了 getter 和 setter 方法，由于要使用构造注入，所以需要提供有参的构造方法。为了能更清楚地看到输出结果，这里还重写了 toString() 方法。\n2. 创建 Spring 配置文件\n在 com.mengma.assembly 包下创建一个名为 applicationContext.xml 的配置文件，如下所示。\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">\n    \x3c!-- 使用设值注入方式装配Person实例 --\x3e\n    <bean id="person1" class="com.mengma.assembly.Person">\n        <property name="name" value="zhangsan" />\n        <property name="age" value="20" />\n    </bean>\n    \x3c!-- 使用构造方法装配Person实例 --\x3e\n    <bean id="person2" class="com.mengma.assembly.Person">\n        <constructor-arg index="0" value="lisi" />\n        <constructor-arg index="1" value="21" />\n    </bean>\n</beans>\n上述代码中，首先使用了设值注入方式装配 Person 类的实例，其中 <property> 子元素用于调用 Bean 实例中的 setXxx() 方法完成属性赋值。然后使用了构造方式装配了 Person 类的实例，其中 <constructor-arg> 元素用于定义构造方法的参数，其属性 index 表示其索引（从 0 开始），value 属性用于设置注入的值。\n3. 创建测试类\n在 com.mengma.assembly 包下创建一个名称为 XmlBeanAssemblyTest 的测试类，编辑后如下所示。\n纯文本复制\npackage com.mengma.assembly;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class XmlBeanAssemblyTest {\n    @Test\n    public void test() {\n        // 定义Spring配置文件路径\n        String xmlPath = "com/mengma/assembly/applicationContext.xml";\n        // 初始化Spring容器，加载配置文件，并对bean进行实例化\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n                xmlPath);\n        // 设值方式输出结果\n        System.out.println(applicationContext.getBean("person1"));\n        // 构造方式输出结果\n        System.out.println(applicationContext.getBean("person2"));\n    }\n}\n上述代码中，分别获取并输出了 id 为 person1 和 person2 的实例。\n4. 运行项目并查看结果\n使用 JUnit 测试运行 test() 方法，运行成功\n\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);