(window.webpackJsonp=window.webpackJsonp||[]).push([[276],{767:function(n,t,e){"use strict";e.r(t);var a=e(6),i=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"day10"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day10"}},[n._v("#")]),n._v(" day10")]),n._v(" "),e("h2",{attrs:{id:"day10笔记提纲-1-java-lang-object重点讲解-getclass-tostring-clone-equals和hashcode-finalize-2-基本类型和对应的包装类型以及其中的常用方法3-java对字符串的处理-java-lang-stringjava-lang-stringbufferjava-lang-stringbuilder"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day10笔记提纲-1-java-lang-object重点讲解-getclass-tostring-clone-equals和hashcode-finalize-2-基本类型和对应的包装类型以及其中的常用方法3-java对字符串的处理-java-lang-stringjava-lang-stringbufferjava-lang-stringbuilder"}},[n._v("#")]),n._v(" day10笔记\n提纲:1.java.lang.Object\n重点讲解:getClass()  toString()    clone()     equals和hashCode()   finalize()\n2.基本类型和对应的包装类型以及其中的常用方法\n3.Java对字符串的处理   java.lang.String\njava.lang.StringBuffer\njava.lang.StringBuilder")]),n._v(" "),e("p",[n._v("知识点1:\njava.lang.Object"),e("br"),n._v("\nObject类是所有类的基础类,所有的类都是间接或者直接去继承它.")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('      常用方法:\n               1.getClass()方法\n               public final Class<?> getClass();//获取运行时类型\n\n               注意一点:一个类无论被实例化多少次,它在JVM中的class实例只有1个\n               比如:Student s1 = new Student();\n                       Student s2 = new Student();\n                       System.out.println(s1.getClass()==s2.getClass());//true\n             java.lang.Class<?>\n                JVM当中描述类的类,有了它,我们就可以获取类的所有信息\n                它是反射技术的基础类\n        JVM中如何获取Class实例,5种方式\n        1.对象名.getClass();\n        2.类名.class\n        3.Class.forName("类的全限定名");//此方法要求强制处理异常\n           注意:如果传入的类的全限定名错误,则会抛出java.lang.ClassNotFoundException异常\n        4.基本类型.class\n        5.包装类型.class\n')])])]),e("hr"),n._v(" "),e("p",[n._v("2.toString()\n作用:将对象转换成字符串的表现形式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    getClass()+'@'+Integer.toHexString(hashCode());\n\n    注意:一般对象都会去自动调用该方法,通常我们都要重写该方法\n            因为原版的打印内容不符合我们的业务要求.\n\n            如果打印对象不是出现上面的形式,那么它或者它父类当中肯定重写了该方法\n")])])]),e("hr"),n._v(" "),e("p",[n._v("3.equals()方法\n1.==比较的是内存地址\n2.equals方法中,基本类型用==比较,对象调用equals方法,\n默认比较的也是内存地址,一般都会选择去重写它,让它比较对象中的值\n3.String和Date已经重写过equals方法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("   重写equals步骤:\n   1.非空性\n   2.自反性\n   3.对称性\n   4.一致性\n   5.传递性\n\n  public boolean equals(Object obj){\n          //1.非空性\n          if(null==obj){\n              return false;\n          }\n          //2.自反性\n          if(this==obj){\n              return true;\n          }\n          //3.类型判断\n          if(obj instanceof Student){\n                Student s = (Student)obj;//强制类型转换\n                return s.getName().equals(name)\n          }\n          return false;\n  }\n")])])]),e("p",[n._v("hashCode():哈希码\n作用:主要是用来查询")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("      注意: 1.一般equals方法和hashCode()方法成对出现\n               2.相同对象(s1.equals(s2)返回true),保证哈希值要相同\n               3.不同对象,尽可能保证哈希值不同\n               4.equals方法中出现的属性一定也要出现在hashCode()方法中\n")])])]),e("hr"),n._v(" "),e("p",[n._v("clone()方法:\n就是将对象拷贝一份给副本,Object当中的clone方法都是浅层复制")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("        protected Object clone() throws CloneNotSupportedException\n        浅层复制:也称为浅拷贝  就是将基本类型拷贝一份给副本,对象类型共享\n        深层复制:也称为深拷贝  所有类型都拷贝一份给副本,需要我们手动写代码.\n\n        注意点:1.String和Date类型除外\n                    2.被克隆的实体类要去实现Cloneable接口,否则会抛出\n                       CloneNotSupportedException\n                    3.protected改成public \n")])])]),e("hr"),n._v(" "),e("h2",{attrs:{id:"finalize-protected-void-finalize-throws-throwable1-它是由jvm来调用的而非人为调用2-作用-jvm将对象清理出内存之前的做的一些必要的清理工作笔试题-final-finally-finalize-之间的区别final-表示最终的-final修饰的变量叫做常量-一旦赋值了就不允许修改final修饰的方法-不允许重写final修饰的类-不允许继承finally-一般是和try-catch-块连用的-程序一旦出现异常-就会进入到相应的catch块中但是无论程序是否出现异常-都会执行finally中的程序-除非出现system-exit-0-中断虚拟机进程注意一点finally在return之前执行的finally块中一般是用来做资源释放-连接池关闭-io关闭等操作finalize-由jvm调用-不管程序抛不抛异常-finalize-不会抛异常-并且程序可"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#finalize-protected-void-finalize-throws-throwable1-它是由jvm来调用的而非人为调用2-作用-jvm将对象清理出内存之前的做的一些必要的清理工作笔试题-final-finally-finalize-之间的区别final-表示最终的-final修饰的变量叫做常量-一旦赋值了就不允许修改final修饰的方法-不允许重写final修饰的类-不允许继承finally-一般是和try-catch-块连用的-程序一旦出现异常-就会进入到相应的catch块中但是无论程序是否出现异常-都会执行finally中的程序-除非出现system-exit-0-中断虚拟机进程注意一点finally在return之前执行的finally块中一般是用来做资源释放-连接池关闭-io关闭等操作finalize-由jvm调用-不管程序抛不抛异常-finalize-不会抛异常-并且程序可"}},[n._v("#")]),n._v(" finalize():\nprotected void finalize() throws Throwable\n1.它是由JVM来调用的而非人为调用\n2.作用:JVM将对象清理出内存之前的做的一些必要的清理工作\n笔试题:final  finally  finalize  之间的区别\nfinal:表示最终的,final修饰的变量叫做常量,一旦赋值了就不允许修改\nfinal修饰的方法,不允许重写\nfinal修饰的类,不允许继承\nfinally:一般是和try{}catch(){}块连用的,程序一旦出现异常,就会进入到相应的catch块中\n但是无论程序是否出现异常,都会执行finally中的程序,除非出现System.exit(0)中断虚拟机进程\n注意一点finally在return之前执行的\nfinally块中一般是用来做资源释放/连接池关闭/IO关闭等操作\nfinalize():由JVM调用,不管程序抛不抛异常,finalize()不会抛异常,并且程序可")]),n._v(" "),e("p",[n._v("基本类型和它对应的包装类型(包装类型也是对象)\nbyte--------------\x3eByte\nshort-------------\x3eShort\nint----------------\x3eInteger\nlong--------------\x3eLong\ndouble----------\x3eDouble\nfloat-------------\x3eFloat\nchar--------------\x3eCharacter\nboolean---------\x3eBoolean")]),n._v(" "),e("p",[n._v("以上6种数字类型的包装类型的父类都是java.lang.Number\nNumber是一个抽象类")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("      byteValue   以byte形式返回指定的数值\n      shortValue  以short形式返回指定的数值\n      doubleValue 以double形式返回指定的数值\n      intValue        以int形式返回指定的数值\n      floatValue     以float形式返回指定的数值\n      longValue    以long形式返回指定的数值\n")])])]),e("hr"),n._v(" "),e("p",[n._v("Integer:\njava.lang.Integer")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("      1.构造方法\n          public Integer(String s);//将字符串转换成Integer\n                                             //注意:如果传入的字符串不是数字类型的,会抛出java.lang.NumberFormatException\n          public Integer(int i);//将基本类型转换成Integer\n      2.常量\n              MAX_VALUE   int类型的最大值  2^31-1\n              MIN_VALUE    int 类型的最小值  -2^31\n      3.基本类型和包装类型之间可以相互转换\n          JDK5.0以后,支持自动解封箱(Auto Boxing/unBoxing)\n\n          Integer i = 5;//自动封箱\n          int i2 = i;//自动解箱\n       4.常用方法:\n                  public static int parseInt(String s);//将字符串解析成int类型\n                  public static Integer valueOf(String s);//将字符串转换成Integer\n                  public static Integer valueOf(int i);//将int类型转换成Integer\n                  public String toString();//将Integer转换成字符串\n\n                  public static String toBinaryString(int i);//转换成二进制\n                  public static String toHexString(int i);//转换成十六进制\n                  public static String toOctalString(int i);//转换成八进制\n")])])]),e("hr"),n._v(" "),e("p",[n._v("Character\n字符集")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("      1.构造方法:\n              public Character(char ch);\n       2.常用方法:\n                public static boolean isDigit(char ch);//判断该字符是否为数字\n\n                public static boolean  isLetter(char ch);//判断该字符是否为字母\n\n                public static boolean isLowerCase(char ch);//判断该字符是否为小写\n\n                public static boolean isUpperCase(char ch);//判断该字符是否为大写\n\n                public static boolean isWhitespace(char ch);//判断该字符是否为空白\n\n                public static Character valueOf(char c);//char转换成Character\n")])])]),e("hr"),n._v(" "),e("p",[n._v("Boolean\n1.构造方法\npublic Boolean(boolean b);//将boolean转换成Boolean\npublic Boolean(String s);//将String类型转换成Boolean")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('     2.常用方法\n          public static boolean parseBoolean(String s);//将字符串解析成布尔类型\n                                                                        //  //注意:当且仅当String是"true"结果返回true\n                                                                        //其他全部是false\n          public static Boolean valueOf(String s);//..........\n          public static Boolean valueOf(boolean b);//..............\n')])])]),e("hr"),n._v(" "),e("p",[n._v("BigInteger\n大整数型数据类型\n1.构造\n2.常量\n3.方法\n4.案例   阶乘")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("                public static int fac(int i){\n                      //1.指定递归出口\n                      if(i==1){\n                            return 1;....\n                      }\n                      return i*fac(i-1)\n                      .....\n                }\n")])])]),e("h2",{attrs:{id:"bigdecimal大浮点型数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bigdecimal大浮点型数据类型"}},[n._v("#")]),n._v(" BigDecimal\n大浮点型数据类型")]),n._v(" "),e("h2",{attrs:{id:"java-text-numberformat格式化数字类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-text-numberformat格式化数字类"}},[n._v("#")]),n._v(" java.text.NumberFormat\n格式化数字类")]),n._v(" "),e("p",[n._v("Java关于字符串的处理\n1.String类   是final类型的")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('          2.构建构建String对象\n              a.通过new关键字申请空间  String s = new String("xyz")\n              b.通过串池的方式,此效率比较高,比较第二次创建字符串的时候,会\n                 先到串池当中去找有没有创建过.\n                 String s = "abc";\n          3.字符串拼接  +=   效率低下\n             通常是采用java.lang.StringBuilder中的append方法来替代\n\n             java.lang.StringBuilder   轻量级字符串处理类 效率高  线程不安全\n             java.lang.StringBuffer     重量级....   线程安全      效率低\n')])])]),e("hr"),n._v(" "),e("p",[n._v('java.lang.String\n常用方法:\n//1.返回指定索引处的char值  索引从0开始\nSystem.out.println(new String("ABC").charAt(2));//C\n//2.按照字典顺序比较两个字符串\nSystem.out.println(new String("我").compareTo(new String("你")));\n//3.在字符串的末尾拼接\nSystem.out.println(new String("ABC").concat("DE"));//ABCDE\n//4.当且仅当此字符串包含指定的 char 值序列时，返回 true\nSystem.out.println(new String("1+1").contains("+"));//true\n//5.endsWith(String suffix)   测试此字符串是否以指定的后缀结束。\nSystem.out.println(new String("ABCDE").endsWith("DE"));//true\n//6.将此 String 与另一个 String 比较，不考虑大小写。\nSystem.out.println(new String("a").equalsIgnoreCase(new String("A")));//true\n//7.返回指定字符在此字符串中第一次出现处的索引\nSystem.out.println(new String("你好!我好!大家好!").indexOf("好"));//1\n//8.返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。\nSystem.out.println(new String("你坏!我坏!她更坏!").indexOf("坏", 2));//4\n//9.当且仅当 length() 为 0 时返回 true\nSystem.out.println(new String("   ").isEmpty());//false\n//10.返回指定字符在此字符串中最后一次出现处的索引。\nSystem.out.println(new String("你好!我好!大家好!").lastIndexOf("好"));//8\n//11. 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。\nSystem.out.println(new String("你好!我好!大家好!").lastIndexOf("好",7));//4\n//12.返回此字符串的长度\nSystem.out.println(new String("I love He").length());//9\n//13.返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。\nSystem.out.println(new String("I love Java").replace("Java", "美女"));\n//14.根据给定正则表达式的匹配拆分此字符串  192.168.0.41\nString[] arr = new String("192.168.0.41").split("\\.");//可以传入正则\nSystem.out.println(Arrays.toString(arr));\n//15.字符串的本质是char类型的数组\nchar c[] = {\'a\',\'b\',\'c\'};\nSystem.out.println(c);//abc\n//16.返回字符串的副本，忽略前导空白和尾部空白  去的头跟尾的空\nSystem.out.println(new String(" ab c ").trim().length());//4\n//17.将其他类型转换成String\n//比如将int类型转换成String\nString s = String.valueOf(2);\nSystem.out.println(s+1);//21\n//18.startsWith(String prefix)  以..开头\n//19.toLowerCase()   转小写\n//20.toUpperCase()   转大写')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('\t//21 截取\n\t// 返回一个新的字符串，它是此字符串的一个子字符串。\n\tSystem.out.println(new String("ABC,DE").substring(2));//C,DE\n\t//22.返回一个新字符串，它是此字符串的一个子字符串。[start,end)\n\tSystem.out.println(new String("ABC,DE").substring(1, 4));//BC,\n\t//23.将此字符串转换为一个新的字符数组。\n\tchar[] cstr = new String("ABC").toCharArray();\n\tSystem.out.println(cstr);//ABC\n')])])]),e("hr"),n._v(" "),e("p",[n._v('java.lang.StringBuilder\n常用方法:\n//1.构建StringBuilder\nStringBuilder s = new StringBuilder("abc");\nStringBuilder s2 = new StringBuilder(123);\n//2.append  拼接\nSystem.out.println(new StringBuilder("abc").append("DE"));\n//3.返回当前容量  默认的是16\nSystem.out.println(new StringBuilder("abc").capacity());//19\n//4. 返回长度（字符数）。\nSystem.out.println(new StringBuilder("abc").length());//3\n//5.返回此序列中指定索引处的 char 值\nSystem.out.println(new StringBuilder("acv").charAt(1));//c\n//6.移除此序列的子字符串中的字符。[start,end)\nSystem.out.println(new StringBuilder("I love gan you").delete(7,11));//I love you\n//7.  移除此序列指定位置上的 char。\nSystem.out.println(new StringBuilder("I love gan you").deleteCharAt(0));//I love you\n//8.indexOf  同String\n//9. 将 char 参数的字符串表示形式插入此序列中。\nSystem.out.println(new StringBuilder("I love gan you").insert(2, "very "));\n//10.lastIndexOf  同上\n//11.使用给定 String 中的字符替换此序列的子字符串中的字符。\nSystem.out.println(new StringBuilder("I love Java").replace(7, 10, "*"));\n//12.将此字符序列用其反转形式取代\nSystem.out.println(new StringBuilder("0101").reverse());\n//13.将给定索引处的字符设置为 ch。\nStringBuilder builder = new StringBuilder("ABC");\nbuilder.setCharAt(1, \'D\');\nSystem.out.println(builder);//ADC\n//14.subString()同String方法一样')])])}),[],!1,null,null,null);t.default=i.exports}}]);