(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{669:function(e,t,n){"use strict";n.r(t);var r=n(6),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"java-网络编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-网络编程"}},[e._v("#")]),e._v(" Java 网络编程")]),e._v(" "),n("p",[e._v("网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。")]),e._v(" "),n("p",[e._v("java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。")]),e._v(" "),n("p",[e._v("java.net 包中提供了两种常见的网络协议的支持：")]),e._v(" "),n("p",[e._v("TCP：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。")]),e._v(" "),n("p",[e._v("UDP：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。")]),e._v(" "),n("p",[e._v("本教程主要讲解以下两个主题。")]),e._v(" "),n("p",[e._v("Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。")]),e._v(" "),n("p",[e._v("URL 处理：这部分会在另外的篇幅里讲，点击这里更详细地了解在 Java 语言中的 URL 处理。")]),e._v(" "),n("p",[e._v("Socket 编程\n套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。")]),e._v(" "),n("p",[e._v("当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。")]),e._v(" "),n("p",[e._v("java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。")]),e._v(" "),n("p",[e._v("以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：")]),e._v(" "),n("p",[e._v("服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。")]),e._v(" "),n("p",[e._v("服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。")]),e._v(" "),n("p",[e._v("服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。")]),e._v(" "),n("p",[e._v("Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。")]),e._v(" "),n("p",[e._v("在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。")]),e._v(" "),n("p",[e._v("连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。")]),e._v(" "),n("p",[e._v("TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。")]),e._v(" "),n("p",[e._v("ServerSocket 类的方法\n服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。")]),e._v(" "),n("p",[e._v("ServerSocket 类有四个构造方法：")]),e._v(" "),n("p",[e._v("序号\t方法描述\n1\tpublic ServerSocket(int port) throws IOException\n创建绑定到特定端口的服务器套接字。\n2\tpublic ServerSocket(int port, int backlog) throws IOException\n利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。\n3\tpublic ServerSocket(int port, int backlog, InetAddress address) throws IOException\n使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。\n4\tpublic ServerSocket() throws IOException\n创建非绑定服务器套接字。\n创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。")]),e._v(" "),n("p",[e._v("这里有一些 ServerSocket 类的常用方法：")]),e._v(" "),n("p",[e._v("序号\t方法描述\n1\tpublic int getLocalPort()\n返回此套接字在其上侦听的端口。\n2\tpublic Socket accept() throws IOException\n侦听并接受到此套接字的连接。\n3\tpublic void setSoTimeout(int timeout)\n通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。\n4\tpublic void bind(SocketAddress host, int backlog)\n将 ServerSocket 绑定到特定地址（IP 地址和端口号）。\nSocket 类的方法\njava.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。")]),e._v(" "),n("p",[e._v("Socket 类有五个构造方法.")]),e._v(" "),n("p",[e._v("序号\t方法描述\n1\tpublic Socket(String host, int port) throws UnknownHostException, IOException.\n创建一个流套接字并将其连接到指定主机上的指定端口号。\n2\tpublic Socket(InetAddress host, int port) throws IOException\n创建一个流套接字并将其连接到指定 IP 地址的指定端口号。\n3\tpublic Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.\n创建一个套接字并将其连接到指定远程主机上的指定远程端口。\n4\tpublic Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.\n创建一个套接字并将其连接到指定远程地址上的指定远程端口。\n5\tpublic Socket()\n通过系统默认类型的 SocketImpl 创建未连接套接字\n当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。")]),e._v(" "),n("p",[e._v("下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。")]),e._v(" "),n("p",[e._v("序号\t方法描述\n1\tpublic void connect(SocketAddress host, int timeout) throws IOException\n将此套接字连接到服务器，并指定一个超时值。\n2\tpublic InetAddress getInetAddress()\n返回套接字连接的地址。\n3\tpublic int getPort()\n返回此套接字连接到的远程端口。\n4\tpublic int getLocalPort()\n返回此套接字绑定到的本地端口。\n5\tpublic SocketAddress getRemoteSocketAddress()\n返回此套接字连接的端点的地址，如果未连接则返回 null。\n6\tpublic InputStream getInputStream() throws IOException\n返回此套接字的输入流。\n7\tpublic OutputStream getOutputStream() throws IOException\n返回此套接字的输出流。\n8\tpublic void close() throws IOException\n关闭此套接字。\nInetAddress 类的方法\n这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：")]),e._v(" "),n("p",[e._v("序号\t方法描述\n1\tstatic InetAddress getByAddress(byte[] addr)\n在给定原始 IP 地址的情况下，返回 InetAddress 对象。\n2\tstatic InetAddress getByAddress(String host, byte[] addr)\n根据提供的主机名和 IP 地址创建 InetAddress。\n3\tstatic InetAddress getByName(String host)\n在给定主机名的情况下确定主机的 IP 地址。\n4\tString getHostAddress()\n返回 IP 地址字符串（以文本表现形式）。\n5\tString getHostName()\n获取此 IP 地址的主机名。\n6\tstatic InetAddress getLocalHost()\n返回本地主机。\n7\tString toString()\n将此 IP 地址转换为 String。\nSocket 客户端实例\n如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。")]),e._v(" "),n("p",[e._v("GreetingClient.java 文件代码：\n// 文件名 GreetingClient.java")]),e._v(" "),n("p",[e._v("import java.net."),n("em",[e._v(";\nimport java.io.")]),e._v(";")]),e._v(" "),n("p",[e._v('public class GreetingClient\n{\npublic static void main(String [] args)\n{\nString serverName = args[0];\nint port = Integer.parseInt(args[1]);\ntry\n{\nSystem.out.println("连接到主机：" + serverName + " ，端口号：" + port);\nSocket client = new Socket(serverName, port);\nSystem.out.println("远程主机地址：" + client.getRemoteSocketAddress());\nOutputStream outToServer = client.getOutputStream();\nDataOutputStream out = new DataOutputStream(outToServer);')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('     out.writeUTF("Hello from " + client.getLocalSocketAddress());\n     InputStream inFromServer = client.getInputStream();\n     DataInputStream in = new DataInputStream(inFromServer);\n     System.out.println("服务器响应： " + in.readUTF());\n     client.close();\n  }catch(IOException e)\n  {\n     e.printStackTrace();\n  }\n')])])]),n("p",[e._v("}\n}\nSocket 服务端实例\n如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。")]),e._v(" "),n("p",[e._v("GreetingServer.java 文件代码：\n// 文件名 GreetingServer.java")]),e._v(" "),n("p",[e._v("import java.net."),n("em",[e._v(";\nimport java.io.")]),e._v(";")]),e._v(" "),n("p",[e._v("public class GreetingServer extends Thread\n{\nprivate ServerSocket serverSocket;")]),e._v(" "),n("p",[e._v("public GreetingServer(int port) throws IOException\n{\nserverSocket = new ServerSocket(port);\nserverSocket.setSoTimeout(10000);\n}")]),e._v(" "),n("p",[e._v('public void run()\n{\nwhile(true)\n{\ntry\n{\nSystem.out.println("等待远程连接，端口号为：" + serverSocket.getLocalPort() + "...");\nSocket server = serverSocket.accept();\nSystem.out.println("远程主机地址：" + server.getRemoteSocketAddress());\nDataInputStream in = new DataInputStream(server.getInputStream());\nSystem.out.println(in.readUTF());\nDataOutputStream out = new DataOutputStream(server.getOutputStream());\nout.writeUTF("谢谢连接我：" + server.getLocalSocketAddress() + "\\nGoodbye!");\nserver.close();\n}catch(SocketTimeoutException s)\n{\nSystem.out.println("Socket timed out!");\nbreak;\n}catch(IOException e)\n{\ne.printStackTrace();\nbreak;\n}\n}\n}\npublic static void main(String [] args)\n{\nint port = Integer.parseInt(args[0]);\ntry\n{\nThread t = new GreetingServer(port);\nt.run();\n}catch(IOException e)\n{\ne.printStackTrace();\n}\n}\n}\n编译以上两个 java 文件代码，并执行以下命令来启动服务，使用端口号为 6066：')]),e._v(" "),n("p",[e._v("$ javac GreetingServer.java\n$ java GreetingServer 6066\n等待远程连接，端口号为：6066...\n新开一个命令窗口，执行以上命令来开启客户端：")]),e._v(" "),n("p",[e._v("$ javac GreetingClient.java\n$ java GreetingClient localhost 6066\n连接到主机：localhost ，端口号：6066\n远程主机地址：localhost/127.0.0.1:6066\n服务器响应： 谢谢连接我：/127.0.0.1:6066\nGoodbye!")]),e._v(" "),n("p",[e._v("同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。")]),e._v(" "),n("p",[e._v("以银行取款为例：")]),e._v(" "),n("p",[e._v("同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理IO 读写）；")]),e._v(" "),n("p",[e._v("异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO 时，Java 将 IO 读写委托给OS 处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS 需要支持异步IO操作API）；")]),e._v(" "),n("p",[e._v("阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。")]),e._v(" "),n("p",[e._v("以银行取款为例：")]),e._v(" "),n("p",[e._v("阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；")]),e._v(" "),n("p",[e._v("非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）")]),e._v(" "),n("p",[e._v("1.BIO 编程")]),e._v(" "),n("p",[e._v("Blocking IO： 同步阻塞的编程方式。")]),e._v(" "),n("p",[e._v("BIO编程方式通常是在JDK1.4版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个ServerSocket来监听网络请求，客户端启动Socket发起网络请求，默认情况下ServerSocket回建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。")]),e._v(" "),n("p",[e._v("且建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：")]),e._v(" "),n("p",[e._v("同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。")]),e._v(" "),n("p",[e._v("BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。")]),e._v(" "),n("p",[e._v("使用线程池机制改善后的BIO模型图如下:")]),e._v(" "),n("p",[e._v("2.NIO 编程：Unblocking IO（New IO）： 同步非阻塞的编程方式。")]),e._v(" "),n("p",[e._v("NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题，NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。")]),e._v(" "),n("p",[e._v("NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。")]),e._v(" "),n("p",[e._v("在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题")]),e._v(" "),n("p",[e._v("3.AIO编程：Asynchronous IO： 异步非阻塞的编程方式。")]),e._v(" "),n("p",[e._v("与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：AsynchronousSocketChannel、AsynchronousServerSocketChannel、AsynchronousFileChannel、AsynchronousDatagramChannel")]),e._v(" "),n("p",[e._v("bio示例")]),e._v(" "),n("p",[e._v("server示例：")]),e._v(" "),n("p",[e._v("public class Server {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('public static void main(String[] args) {\n    int port = genPort(args);\n    \n    ServerSocket server = null;\n    ExecutorService service = Executors.newFixedThreadPool(50);\n    \n    try{\n        server = new ServerSocket(port);\n        System.out.println("server started!");\n        while(true){\n            Socket socket = server.accept();\n            \n            service.execute(new Handler(socket));\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }finally{\n        if(server != null){\n            try {\n                server.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        server = null;\n    }\n}\n\nstatic class Handler implements Runnable{\n    Socket socket = null;\n    public Handler(Socket socket){\n        this.socket = socket;\n    }\n    @Override\n    public void run() {\n        BufferedReader reader = null;\n        PrintWriter writer = null;\n        try{\n            \n            reader = new BufferedReader(\n                    new InputStreamReader(socket.getInputStream(), "UTF-8"));\n            writer = new PrintWriter(\n                    new OutputStreamWriter(socket.getOutputStream(), "UTF-8"));\n            String readMessage = null;\n            while(true){\n                System.out.println("server reading... ");\n                if((readMessage = reader.readLine()) == null){\n                    break;\n                }\n                System.out.println(readMessage);\n                writer.println("server recive : " + readMessage);\n                writer.flush();\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally{\n            if(socket != null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            socket = null;\n            if(reader != null){\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            reader = null;\n            if(writer != null){\n                writer.close();\n            }\n            writer = null;\n        }\n    }\n    \n}\n\nprivate static int genPort(String[] args){\n    if(args.length > 0){\n        try{\n            return Integer.parseInt(args[0]);\n        }catch(NumberFormatException e){\n            return 9999;\n        }\n    }else{\n        return 9999;\n    }\n}\n')])])]),n("p",[e._v("}\n2.client示例：")]),e._v(" "),n("p",[e._v('public class Client {\npublic static void main(String[] args) {\nString host = null;\nint port = 0;\nif(args.length > 2){\nhost = args[0];\nport = Integer.parseInt(args[1]);\n}else{\nhost = "127.0.0.1";\nport = 9999;\n}')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    Socket socket = null;\n    BufferedReader reader = null;\n    PrintWriter writer = null;\n    Scanner s = new Scanner(System.in);\n    try{\n        socket = new Socket(host, port);\n        String message = null;\n        \n        reader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream(), "UTF-8"));\n        writer = new PrintWriter(\n                socket.getOutputStream(), true);\n        while(true){\n            message = s.nextLine();\n            if(message.equals("exit")){\n                break;\n            }\n            writer.println(message);\n            writer.flush();\n            System.out.println(reader.readLine());\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }finally{\n        if(socket != null){\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        socket = null;\n        if(reader != null){\n            try {\n                reader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        reader = null;\n        if(writer != null){\n            writer.close();\n        }\n        writer = null;\n    }\n}\n')])])]),n("p",[e._v("}\n以上只是简单示例，仅供参考！")]),e._v(" "),n("p",[e._v("JeoSaber\nJeoSaber")]),e._v(" "),n("p",[e._v("lov***ming09@163.com")]),e._v(" "),n("p",[e._v("2年前 (2018-08-07)\n一生默默守护你")]),e._v(" "),n("p",[e._v("187***86490@163.com")]),e._v(" "),n("p",[e._v("61\nDatagramSocket(UDP)简单示例")]),e._v(" "),n("p",[e._v("服务端：")]),e._v(" "),n("p",[e._v('public class Server {\npublic static void main(String[] args) {\ntry {\nDatagramSocket server = new DatagramSocket(5060);\nDatagramPacket packet = new DatagramPacket(new byte[1024], 1024);\nserver.receive(packet);\nSystem.out.println(packet.getAddress().getHostName() + "(" + packet.getPort() + "):" + new String(packet.getData()));\npacket.setData("Hello Client".getBytes());\npacket.setPort(5070);\npacket.setAddress(InetAddress.getLocalHost());\nserver.send(packet);\nserver.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n}\n客户端:')]),e._v(" "),n("p",[e._v('public class Client {\npublic static void main(String[] args){\ntry {\nDatagramSocket client = new DatagramSocket(5070);\nDatagramPacket packet = new DatagramPacket(new byte[1024],1024);\npacket.setPort(5060);\npacket.setAddress(InetAddress.getLocalHost());\npacket.setData("Hello Server".getBytes());\nclient.send(packet);\nclient.receive(packet);\nSystem.out.println(packet.getAddress().getHostName() + "(" + packet.getPort() + "):" + new String(packet.getData()));\nclient.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n}')])])}),[],!1,null,null,null);t.default=a.exports}}]);