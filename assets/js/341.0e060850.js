(window.webpackJsonp=window.webpackJsonp||[]).push([[341],{830:function(n,t,s){"use strict";s.r(t);var u=s(6),e=Object(u.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-cloud-zuul路由配置详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-zuul路由配置详解"}},[this._v("#")]),this._v(" Spring Cloud Zuul路由配置详解")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('在教程《Zuul网关介绍和使用》中，我们学习了如何结合 Eureka 来实现动态的路由转发。当 Zuul 集成 Eureka 之后，其实就可以为 Eureka 中所有的服务进行路由操作了，默认的转发规则就是“API 网关地址+访问的服务名称+接口 URI”。\n\n在给服务指定名称的时候，应尽量短一点，这样的话我们就可以用默认的路由规则进行请求，不需要为每个服务都定一个路由规则，这样就算新增了服务，API 网关也不用修改和重启了。\n\n默认规则举例：\nAPI 网关地址：http://localhost:2103。\n用户服务名称：user-service。\n用户登录接口：/user/login。\n\n那么通过 Zuul 访问登录接口的规则就是 http://localhost：2103/user-service/user/login。\n1. 指定具体服务路由\n我们可以为每一个服务都配置一个路由转发规则：\nzuul.routes.fsh-house.path=/api-house/**\n\n上述代码将 fsh-house 服务的路由地址配置成了 api-house，也就是当需要访问 fsh-house 中的接口时，我们可以通过 api-house/house/hello 来进行。这其实就是将服务名称变成了我们自定义的名称。\n\n有的时候服务名称太长了，放在 URL 中不太友好，我们希望它变得更友好一点，就可以这么去配置。这里的 api-house/** 后面一定要配置两个星号，两个星号表示可以转发任意层级的 URL，比如“/api-house/house/1”。如果只配置一个星号，那么就只能转发一级，比如“/api-house/house”。\n2. 路由前缀\n有的时候我们会想在 API 前面配置一个统一的前缀，比如像 http://c.biancheng.net/user/login 这样登录接口，如果想将其变成 http://c.biancheng.net/rest/user/login，即在每个接口前面加一个 rest，此时我们就可以通过 Zuul 中的配置来实现：\nzuul.prefix=/rest\n\n3. 本地跳转\nZuul 的 API 路由还提供了本地跳转功能，通过 forward 就可以实现。\nzuul.routes.fsh-substitution.path=/api/**\nzuul.routes.fsh-substitution.url=forward:/local\n\n当我们想在访问 api/1 的时候会路由到本地的 local/1 上去，就可以参照上述代码实现。local 是本地接口需要我们自行添加，因此我们要建一个 Controller，代码如下所示。\n纯文本复制\n@RestController\npublic class LocalController {\n    @GetMapping("/local/{id}")\n    public String local(@PathVariable String id) {\n        return id;\n    }\n}\n然后访问 http://localhost：2103/api/1 就可以看到我们想要的返回结果了\n\n\n')])])])])}),[],!1,null,null,null);t.default=e.exports}}]);