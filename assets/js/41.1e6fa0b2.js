(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{528:function(t,D,e){"use strict";e.r(D);var r=e(6),n=Object(r.a)({},(function(){var t=this,D=t.$createElement,e=t._self._c||D;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"spark-rdd-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spark-rdd-是什么"}},[t._v("#")]),t._v(" Spark(RDD)是什么")]),t._v(" "),e("p",[t._v("RDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。\n只读：不能修改，只能通过转换操作生成新的 RDD。\n分布式：可以分布在多台机器上进行并行处理。\n弹性：计算过程中内存不够时它会和磁盘进行数据交换。\n基于内存：可以全部或部分缓存在内存中，在多次计算间重用。")]),t._v(" "),e("p",[t._v("RDD 实质上是一种更为通用的迭代并行计算框架，用户可以显示控制计算的中间结果，然后将其自由运用于之后的计算。")]),t._v(" "),e("p",[t._v("在大数据实际应用开发中存在许多迭代算法，如机器学习、图算法等，和交互式数据挖掘工具。这些应用场景的共同之处是在不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。")]),t._v(" "),e("p",[t._v("RDD 正是为了满足这种需求而设计的。虽然 MapReduce 具有自动容错、负载平衡和可拓展性的优点，但是其最大的缺点是采用非循环式的数据流模型，使得在迭代计算时要进行大量的磁盘 I/O 操作。")]),t._v(" "),e("p",[t._v("通过使用 RDD，用户不必担心底层数据的分布式特性，只需要将具体的应用逻辑表达为一系列转换处理，就可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘 I/O 和数据序列化的开销。\nRDD 基本操作\nRDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。")]),t._v(" "),e("p",[t._v("RDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。")]),t._v(" "),e("ol",[e("li",[t._v("构建操作\nSpark 里的计算都是通过操作 RDD 完成的，学习 RDD 的第一个问题就是如何构建 RDD，构建 RDD 的方式从数据来源角度分为以下两类。\n从内存里直接读取数据。\n从文件系统里读取数据，文件系统的种类很多，常见的就是 HDFS 及本地文件系统。")])]),t._v(" "),e("p",[t._v("第一类方式是从内存里构造 RDD，需要使用 makeRDD 方法，代码如下所示。\nval rdd01 = sc.makeRDD(List(l,2,3,4,5,6))")]),t._v(" "),e("p",[t._v("这个语句创建了一个由“1,2,3,4,5,6”六个元素组成的 RDD。")]),t._v(" "),e("p",[t._v("第二类方式是通过文件系统构造 RDD，代码如下所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('val rdd:RDD[String] == sc.textFile("file:///D:/sparkdata.txt",1)\n')])])]),e("p",[t._v("这里例子使用的是本地文件系统，所以文件路径协议前缀是 file://。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("转换操作\nRDD 的转换操作是返回新的 RDD 的操作。转换出来的 RDD 是惰性求值的，只有在行动操作中用到这些 RDD 时才会被计算。")])]),t._v(" "),e("p",[t._v("许多转换操作都是针对各个元素的，也就是说，这些转换操作每次只会操作 RDD 中的一个元素，不过并不是所有的转换操作都是这样的。表 1 描述了常用的 RDD 转换操作。")]),t._v(" "),e("p",[t._v("表 1 RDD转换操作（rdd1={1, 2, 3, 3}，rdd2={3,4,5})\n函数名\t作用\t示例\t结果\nmap()\t将函数应用于 RDD 的每个元素，返回值是新的 RDD\trdd1.map(x=>x+l)\t{2,3,4,4}\nflatMap()\t将函数应用于 RDD 的每个元素，将元素数据进行拆分，变成迭代器，返回值是新的 RDD \trdd1.flatMap(x=>x.to(3))\t{1,2,3,2,3,3,3}\nfilter()\t函数会过滤掉不符合条件的元素，返回值是新的 RDD\trdd1.filter(x=>x!=1)\t{2,3,3}\ndistinct()\t将 RDD 里的元素进行去重操作\trdd1.distinct() \t(1,2,3)\nunion()\t生成包含两个 RDD 所有元素的新的 RDD\trdd1.union(rdd2)\t{1,2,3,3,3,4,5}\nintersection()\t求出两个 RDD 的共同元素 \trdd1.intersection(rdd2)\t{3}\nsubtract()\t将原 RDD 里和参数 RDD 里相同的元素去掉\trdd1.subtract(rdd2)\t{1,2}\ncartesian()\t求两个 RDD 的笛卡儿积 \trdd1.cartesian(rdd2) \t{(1,3),(1,4)......(3,5)}")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("行动操作\n行动操作用于执行计算并按指定的方式输出结果。行动操作接受 RDD，但是返回非 RDD，即输出一个值或者结果。在 RDD 执行过程中，真正的计算发生在行动操作。表 2 描述了常用的 RDD 行动操作。")])]),t._v(" "),e("p",[t._v("表 2 RDD 行动操作（rdd={1,2,3,3}）\n函数名\t作用\t示例\t结果\ncollect()\t返回 RDD 的所有元素\trdd.collect()\t{1,2,3,3}\ncount()\tRDD 里元素的个数\trdd.count()\t4\ncountByValue()\t各元素在 RDD 中的出现次数\trdd.countByValue()\t{(1,1),(2,1),(3,2})}\ntake(num)\t从 RDD 中返回 num 个元素  \trdd.take(2)\t{1,2}\ntop(num)\t从 RDD 中，按照默认（降序）或者指定的排序返回最前面的 num 个元素 \trdd.top(2)\t{3,3}\nreduce()\t并行整合所有 RDD 数据，如求和操作\trdd.reduce((x,y)=>x+y)\t9\nfold(zero)(func)\t和 reduce() 功能一样，但需要提供初始值\trdd.fold(0)((x,y)=>x+y)\t9\nforeach(func)\t对 RDD 的每个元素都使用特定函数\trdd1.foreach(x=>printIn(x))\t打印每一个元素\nsaveAsTextFile(path)\t将数据集的元素，以文本的形式保存到文件系统中\trdd1.saveAsTextFile(file://home/test)\t\nsaveAsSequenceFile(path) \t将数据集的元素，以顺序文件格式保存到指 定的目录下\tsaveAsSequenceFile(hdfs://home/test)\t aggregate() 函数的返回类型不需要和 RDD 中的元素类型一致，所以在使用时，需要提供所期待的返回类型的初始值，然后通过一个函数把 RDD 中的元素累加起来放入累加器。")]),t._v(" "),e("p",[t._v("考虑到每个结点都是在本地进行累加的，所以最终还需要提供第二个函数来将累加器两两合并。")]),t._v(" "),e("p",[t._v("aggregate(zero)(seqOp,combOp) 函数首先使用 seqOp 操作聚合各分区中的元素，然后再使用 combOp 操作把所有分区的聚合结果再次聚合，两个操作的初始值都是 zero。")]),t._v(" "),e("p",[t._v("seqOp 的操作是遍历分区中的所有元素 T，第一个 T 跟 zero 做操作，结果再作为与第二个 T 做操作的 zero，直到遍历完整个分区。")]),t._v(" "),e("p",[t._v("combOp 操作是把各分区聚合的结果再聚合。aggregate() 函数会返回一个跟 RDD 不同类型的值。因此，需要 seqOp 操作来把分区中的元素 T 合并成一个 U，以及 combOp 操作把所有 U 聚合。")]),t._v(" "),e("p",[t._v("下面举一个利用 aggreated() 函数求平均数的例子。")])])}),[],!1,null,null,null);D.default=n.exports}}]);