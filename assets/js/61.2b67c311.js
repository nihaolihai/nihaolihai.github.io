(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{550:function(s,a,t){"use strict";t.r(a);var e=t(6),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"条例11-当重写equals方法时总是重写hashcode方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条例11-当重写equals方法时总是重写hashcode方法"}},[s._v("#")]),s._v(" 条例11： 当重写equals方法时总是重写hashCode方法")]),s._v(" "),t("p",[s._v("每个重写了equals方法的类中必须重写hashCode方法。如果没有这样做，类将违反hashCode的通用契约，这将妨碍 类在诸如HashMap和HashSet集合中的正常使用。下面是契约，对Object规范描述做了调整：")]),s._v(" "),t("p",[s._v("在程序执行过程中当对象的hashCode方法被反复调用时，在equals中比较的信息没有任何修改的情况下，必须持续返回相同的值。 hashCode值不需要在执行的程序之间保持一致。")]),s._v(" "),t("p",[s._v("如果equals(Object)方法返回两个对象是相等的，那么在两个对象上调用hashCode必须产生相同的整型值。")]),s._v(" "),t("p",[s._v("如果equals(Object)方法返回的两个对象不相等，并不要求每个对象调用hashCode方法必须产生不同的结果。然后，程序员应当意识到 为不同的对象产生不同的hashCode值可以提升hash表的性能。")]),s._v(" "),t("p",[s._v("当没有重写hashCode方法违反的第二个条例是：相等对象必须具有相同的hash码。根据类的equals方法，两个不同的实例可能是逻辑相等的， 但是对于Object的hashCode方法，它们只是没有什么共同的两个对象。所以Object的hashCode方法返回两个似乎是随机的数值，而不是契约 要求的两个相等的数值。")]),s._v(" "),t("p",[s._v("比如，假设尝试使用条例10中的PhoneNumber类的实例作为HashMap的键")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('Map<PhoneNumber, String> m = new HashMap<>();\nm.put(new PhoneNumber(707, 867, 5309), "Jenny");\n')])])]),t("p",[s._v('此时，你可能希望m.get(new PhoneNumber(707, 867, 5309))返回"Jenny"，然后结果是，它返回null。注意涉及到 两个PhoneNumber实例：一个用来插入到HashMap，第二个，相同的实例用来（尝试）获取。PhoneNumber类没有重写 hashCode方法导致两个相等示例具有不同的hashCode，违反了hashCode契约。所以，get方法可能在不同于之前通过 put方法存储的hash桶里查找电话号码。即便两个示例碰巧散列到相同的桶里(海祥备注：hashCode不等，但是取模落到同一个桶)，get方法几乎肯定返回null，因为HashMap 具有优化功能：可以缓存与每个条目关联的哈希码，如果哈希码不匹配就不用再去检查对象的相等性。')]),s._v(" "),t("p",[s._v("解决此问题的简单方式是在PhoneNumber类中编写一个合适的hashCode方法。那hashCode方法是什么样的呢？ 很容易写一个糟糕的hashCode方法。比如，下面这个合法却永不应使用的：")]),s._v(" "),t("p",[s._v("// 最糟糕的可能合法的hashCode实现 ——永不要使用\n@Override\npublic int hashCode() { return 42; }\n它合法是因为它确保了相等对象具有相同的哈希码。它恶心是因为它确保每个对象具有相同的哈希码。所以每个对象散列到 相同的桶中，且哈希表退化为链表。程序应该以线性时间运行而不是次方时间。对于大型哈希表，这就是有效和无效的区别。")]),s._v(" "),t("p",[s._v("一个好的哈希函数往往为不同的实例产生不相等的哈希码。这正是hashCode契约第三部分的含义。理想情况下，哈希函数应该 将不相等实例的任何合理集合均匀分布在所有的int值上。达到这个理想目标可是困难的。所幸，要达到合理的近似值不是特别难。 下面是简单的建议：")]),s._v(" "),t("p",[s._v("声明名为result的int变量，将其初始化为对象中第一个有效字段的哈希码，下面在2.a这一步中计算（回忆下条例10有效字段 是影响相等性比较的字段）\n对于对象中剩余的每个有效字段f，操作如下： a. 计算字段的int型哈希码c： i. 如果字段是原始类型，计算Type.hashCode(f)，Type是对应f的类型的装箱类型类。 ii. 如果字段是对象引用，且类的equals方法通过递归调用equals方法比较字段，那么在字段上递归调用hashCode。 如果需要更复杂的比较，计算字段的规范表示然后在规范标识上调用hashCode。如果字段的值是null，使用0（或者 其他常量，但是一般用0）。 iii. 如果是数组字段，将每个有效的元素视为单独的字段。也就是说，为每个有效元素递归使用这些规则，将每个值 和步骤2.b结合。如果数组没有有效元素，使用常量，最好不使用0。如果所有元素是有效的，使用Arrays.hashCode。 b. 将2.a计算出的hash码结合到结果中，如下： result = 31 * result + c;\n返回result\n当写完了hashCode方法，反问下相同实例是否有相同的哈希码。编写单元测试来验证你的直觉（除非使用AutoValue来生成equals和 hashCode方法，这种情况下可以安全跳过这些测试）。如果相同实例哈希码不等，找出原因并修复这个问题。")]),s._v(" "),t("p",[s._v("可以排除对派生出的字段进行哈希码计算。换句话说，可以忽略那些可以由包含在计算中的字段计算出来的字段。必须排除没有 用在equals比较中的字段，否则有我烦hashCode契约的第二条规定的风险。")]),s._v(" "),t("p",[s._v("步骤2.b中的乘法使得结果取决于字段的顺序，如果类有多个类似字段，将产生好得多的哈希函数 举例，如果String哈希函数省略了乘法运算，所有相同异序的字母将具有相同的哈希码。选择31这个值因为它是一个奇素数。 如果是偶数，一旦乘法溢出，信息将丢失，因为2的乘法等价于位移运算。使用素数的优点没那么大，不过也是传统口做法。 31的非常好的特性是乘法可以通过位移及减法运算以在一些计算机体系架构中取得较好性能。31 * i == (i << 5) - i。 现在虚拟机自动做这种优化。")]),s._v(" "),t("p",[s._v("让我们对PhoneNumber类使用先前的处方。")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 典型的hashCode方法")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Override")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("areaCode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("prefix"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("lineNum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("因为这个方法返回简单确定的计算结果，因为方法的输入只是PhoneNumber实例的3个有效字段，很明显相等的PhoneNumber 实例具有相同的哈希码。这个方法事实上是PhoneNumber实例的完美的好的hashCode实现，和Java平台库中的相当。 它很简单，相当快，并且在将不同的电话号码分到不同的哈希桶中起到了合理的作用。")]),s._v(" "),t("p",[s._v("尽管本条例中的处方产生了相当好的哈希函数，但他们不是最先技术。他们的质量与Java平台库中的值类型的哈希函数相当， 且适合大多数使用场景。如果你需要哈希哈数较少产生碰撞，可以参看Guava's的com.google.common.hash.Hashing[Guava]")]),s._v(" "),t("p",[s._v("Objects类有个静态方法接收任意数量的对象且为他们返回哈希码。这个方法名为hash,使得可以编写一行hashCode方法，它的效果 和遵循本例中的处方编写的hashCode方法相当。不幸的是，它们运行更加缓慢，因为要创建数组容纳可变数量的参数，同时如果参数 存在原始类型还要进行装箱拆箱的操作。这种风格的哈希函数只推荐在性能不是关键问题的场景下使用。下面是使用这项技术编写 PhoneNumber类的哈希函数：")]),s._v(" "),t("p",[s._v("// 一行hashCode方法 - 一般性能\n@Override\npublic int hashCode() {\nreturn Objects.hash(lineNum, prefix, areaCode);\n}\n如果类是不可变的，且计算哈希码的开销是显著的，你可能会考虑缓存对象的哈希码而不是每次请求时重新计算。如果你相信 这个类型的大多数对象将被用作哈希键，那么实例在创建时你该计算哈希码。否则，你可能选择在第一次调用hashCode时延迟 初始化哈希码。需要注意确保在展示延迟初始化化的字段时需要保持类的线程安全性（条例83）。我们的PhoneNumber类不需要 处理这点，但是为了展示如何做，如下演示了。注意hashCode字段的初始化（本例中，是0）不应该是通常创建的实例的哈希码。")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 具有延迟初始化缓存的哈希码的hashCode方法")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" hashCode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 自动初始化为0")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Override")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" hashCode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("areaCode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("prefix"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Short")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("lineNum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    hashCode "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("不要尝试从哈希码计算中排除有效字段以提升性能。尽管促成哈希函数运行更快，它的低质量可能拉低哈希表的性能甚至于不可用， 尤其当哈希函数遇到只在你选择忽略的字段上有区别的实例的大的集合时。一旦发生这种情况，哈希函数将这些实例映射成少量的 哈希码，本来程序可运行在线性时间的，现在反而运行在次方时间。")]),s._v(" "),t("p",[s._v("这不仅是理论问题。在Java 2之前，String哈希函数从第一个字符开始，最多使用均匀间隔整个字符串的16个字符。对于层次结构 名称的大集合，比如URLs，整个函数正表现出前面描述的病态行为。")]),s._v(" "),t("p",[s._v("不要为hashCode返回的值提供详细的规范，所以客户端代码不会有理由去依赖它。这为你更改它提供了弹性。Java库中的许多类， 诸如String和Integer，指定了它们的hashCode方法返回的准确值指定为实例值的一个函数。这非但不是好的主意，确是一个我们 被迫使用的一个错误：它妨碍了在未来版本中提升哈希函数的能力。如果不指定细节，那么在未来发现哈希函数的缺点或更好的哈希函数 时，可以在后续的版本中更改。")]),s._v(" "),t("p",[s._v("总结来说，每次重写equals方法时必须重写hashCode方法，否则程序将不能正常运行。hashCode方法必须遵循Object中指定的通用 契约，且需要合理地将不等的哈希码分配给不等的实例。这很容易做到，如果有些枯燥，使用51页给的方法。条例10中提到，AutoValue 框架提供了手工编写equals和hashCode方法的好的替代方案。IDE也提供了一些功能。")])])}),[],!1,null,null,null);a.default=n.exports}}]);