(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{605:function(n,e,o){"use strict";o.r(e);var a=o(6),t=Object(a.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h2",{attrs:{id:"javaenu"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#javaenu"}},[n._v("#")]),n._v(" javaenu")]),n._v(" "),o("p",[n._v("JAVA基础")]),n._v(" "),o("blockquote",[o("p",[n._v("基本数据类型\nbyte、short、int、long、float、double、char、boolean\nHashMap的数据结构\n使用哈希表（数组+链表）来存储，当链表长度超过阈值8时会将链表转成红黑树，增加查找性能\n默认长度是16，当长度不够时，左移一位也就是扩容为原来的2倍\nArrayList的数据结构\n使用动态数组存储，初始化容量为10，扩容为原来的1.5倍，当remove其中一个元素时，需要移动size-index-1个元素，所以在插入和删除慢，但是随机访问效率快，因为事先分配长度，所以有浪费\nLinkedList的数据结构\n双向链表结构，每个节点都存储上一个节点和下一个节点的引用，插入和删除快，但是随机访问效率慢，因为维护了上一个节点与下一个节点，所以比较大一些\nHashMap存储数据过程\n获得key对象的hashCode\n根据hashcode计算出hash值\n生成Entry对象\n将Entry对象放到table数组中\n如何通过反射调用一个类中的方法\n首先使用forName加载\n使用newInstance实例化对象\n使用getMethod获得方法\n调用invoke方法调用\n创建一个对象时，构造器的调用顺序\n首先调用父类的构造器\n按照声明的顺序调用成员初始化\n调用当前对象类本身的构造器\n原子类\n原子类是非锁的线程安全的类，实现数据操作的原子性\n常见的原子类有"),o("br"),n._v("\nAtomicBoolean\nAtomicInteger\nAtomicLong\nIO与NIO的区别\nIO是面向流的阻塞IO，NIO是面向缓冲的非阻塞IO\nConcurrentHashMap与HashTable的区别\n1.ConcurrentHashMap使用分段锁的思想来保证线程安全，对于不同的数据段使用不同的锁，可以支持多个线程同时访问不同的数据段，所以就不存在锁竞争，从而提高了并发效率\n2.HashTable是使用在方法中加锁的方式来保证线程安全，所以在线程竞争激烈的情况下效率底下。\n代理模式\n1.静态代理：被代理对象与代理对象实现相同的接口或者继承相同的类\n2.动态代理：不需要实现接口，但是目标对象要实现接口，使用InvocationHandler接口实现动态代理，需要实现接口\n3.CGLIB代理：当没有实现接口时使用，将MethodInterceptor传入Enhancer实现，在MethodInterceptor中具体实现，不需要实现接口\nJVM相关\nJVM主要组成部分\nJVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。\n运行时数据区包括\n方法区、虚拟机栈、本地方法栈、堆、程序计数器\n其中方法区、堆跟随虚拟机启动而存在，线程共享的，虚拟机栈、本地方法栈、程序计数器是跟随线程启动而存在的，线程私有\n运行时常量池也是方法区的一部分\n类加载器\n启动类加载器\n扩展类加载器\n系统类加载器\n用户自定义类加载器\n为什么使用双亲委派模型\n防止内存中出现多份同样的字节码，保证一个类是由同一个加载器加载的，保证安全静态变量放在方法区\n创建对象的方式：\n使用new关键词\n使用Class的newInstance方法\n使用Construtor的newInstance方法\n使用clone方法\n反序列化\n为对象分配内存的两种方式\n指针碰撞（堆内存规整时，把用过的内存放在一边，指针向另一边移动与对象大小相当的距离）\n空闲列表（堆内存不规整时，虚拟机维护一个列表记录哪些内存可用，找到一个可以容纳对象的内存分配给对象）\n创建对象时的并发安全问题\n对分配内存空间的动作做同步处理（使用CAS（比较再交换）+失败重试来保障更新操作的原子性）\n讲内存分配的动作以线程为单位划分在不同的空间进行，每个线程在Java堆中预先分配一块内存，这块区域叫做本地线程分配缓冲（TLAB），线程分配内存时在各自的TLAB上分配，当TLAB用完时，才需要同步锁，可以使用UserTLAB参数设定是否使用TLAB\n对象的访问定位\n指针：直接指向对象，代表一个对象在内存中的起始地址\n句柄：相当于指向指针的指针，维护着对象的指针，不直接指向对象\nJVM垃圾回收策略有几种\n标记清除：效率低、回收后的内存过于碎片化\n复制算法：可用内存只有一半\n标记整理：将存活的对象移向一边，把剩下的内存清除掉\n分代回收算法：分为新生代和老年代，使用不同的回收算法进行回收，新生代使用复制算法，老年代使用标记清除或者标记整理算法\nJVM垃圾收集器\n新生代收集器：Serial、ParNew、Parallel Scavenge\n老年代收集器：Serial Old、Parallel Old、CMS\n整堆收集器：G1；\n几种GC\nMinor GC：新生代GC，比较频繁，回收速度快\nFull GC：又称Major GC发生在老年的GC")])]),n._v(" "),o("p",[n._v("Spring相关")]),n._v(" "),o("blockquote",[o("p",[n._v("Spring的AOP与IOC\nIOC，依赖注入，控制反转，和AOP，面向切面编程\nIOC就是典型的工厂模式，使用反射生成所需要的bean，通过sessionfactory去注入实例。\nAOP就是典型的代理模式的体现。\nSpring中bean的作用域\nsingleton\nprototype\nrequest\nsession\nglobal-session\nbean的生命周期\n实例化 Instantiation\n属性赋值 Populate\n初始化 Initialization\n销毁 Destruction")])]),n._v(" "),o("p",[n._v("SpringCloud相关")]),n._v(" "),o("blockquote",[o("p",[n._v("SpringCloud五大组件：\n服务发现——Netflix Eureka\n客服端负载均衡——Netflix Ribbon\n断路器——Netflix Hystrix\n服务网关——Netflix Zuul\n分布式配置——Spring Cloud Config\nSpring Cloud 和Dubbo区别"),o("br"),n._v("\n（1）服务调用方式 dubbo是RPC SpringCloud Rest Api\n（2）注册中心,dubbo 是zookeeper SpringCloud是eureka，也可以是zookeeper\n（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。")])]),n._v(" "),o("p",[n._v("多线程相关：")]),n._v(" "),o("blockquote",[o("p",[n._v("synchronized和ReentrantLock的区别\nReentrantLock是一个类，相比synchronized关键字而言更灵活，可以对获取锁的等待时间进行设置，这样就避免了死锁，可以获得锁的各种信息。\nReadWriteLock是什么\n是一个读写锁，实现了读写的分离，读锁是共享的，当多个线程做读的操作时是不会互斥的，写锁是独占的，提高了读写的性能\n创建线程的方式\n继承Thread类\n实现Runnable接口\n实现Callable接口（可以有FutureTask返回值，可以捕获异常）\n线程的五种状态\n新建状态（创建了线程对象还没有调用start方法）\n就绪状态（调用了start方法但是还没有获取到CPU资源）\n运行状态（获取到了CPU资源，正在执行任务）\n阻塞状态（失去CPU资源时）\n死亡状态（完成任务时）")])]),n._v(" "),o("p",[n._v("线程池相关")]),n._v(" "),o("blockquote",[o("p",[n._v("常见线程池\n1.newCachedThreadPool 创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n2.newFixedThreadPool 创建一个定长线程池，可控制最大并发数，超出的线程将在队列中等待。\n3.newScheduledThreadPool 创建一个定时线程池，支持定时及周期性的执行任务。\n4.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序执行(FIFO,LIFO)。\n线程池重要参数：\ncorePoolSize：核心线程数量，没有用的时候也不会被回收的现成数量\nmaximumPoolSize：线程池可以容纳的最大线程数量\nworkQueue：等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则(先进先出)\n线程池配置思路\n高并发、任务执行时间段的业务，线程数可以配置为CPU核心数+1，减少线程上下文切换\nIO密集型任务需要加大线程数量，让CPU处理更多的业务\n计算密集型任务使用CPU核心数+1，减少上下文切换\n线程池的工作队列\n1、ArrayBlockingQueue\n是一个基于数组结构的有界阻塞队列，此队列按 FIFO(先进先出)原则对元素进行排序。\n2、LinkedBlockingQueue\n一个基于链表结构的阻塞队列，此队列按FIFO (先进先出) 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n3、SynchronousQueue\n一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n4、PriorityBlockingQueue\n一个具有优先级的无限阻塞队列。\n线程池的好处\n1.降低资源消耗：通过利用重复创建的线程降低线程创建和销毁造成的消耗\n2.提高响应速度：当任务到达时，任务可以不用等到线程创建就能立即执行\n3.提高线程的可管理性：线程是稀缺资源，如果无限制的创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程可以进行统一分配，调优和监控\n线程池工作原理(重要参数：核心线程，最大线程数量，等待队列)\n1.当提交一个新任务到线程池时，线程池判断核心线程是否都在执行任务，如果有空闲线程，则新建一个新的工作线程来执行任务，直到当前线程数等于核心线程数\n2.如果当前线程数为核心线程数，继续提交的任务将会保存到阻塞队列中，等待被执行\n3.如果阻塞队列满了，那就创建新的线程执行当前任务，直到线程池中的线程达到最大线程数，这时再有任务进来由饱和策略来处理提交的任务\n线程池的拒绝策略\nAbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。\nCallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。\nDiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。\nDiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。")])]),n._v(" "),o("p",[n._v("Mysql相关")]),n._v(" "),o("blockquote",[o("p",[n._v("SQL语句怎么优化\n尽量避免全表扫描，在where及orderby涉及的列上建立索引\n不用select * 这种写法，要写出具体字段\n尽量避免在字段开头模糊查询\n尽量减少子查询的加载数据量\n尽量避免在列上做运算或者使用函数，这样会使索引失效\n尽量避免在where中对null值进行判断，可以使用其他默认值代替null\n尽量避免在where中使用不等操作符\n尽量避免使用or来链接条件，可以使用union all\n尽量避免使用in  not in，可以使用exists代替\n建立索引的原则\n1.尽量减少索引的数量，会带来无意义的硬盘开销，并且会拖累性能\n2.更新频繁字段不适合创建索引\n3.较频繁作为查询条件的字段才去创建索引\n4.尽量避免对大字段建立索引\n5.不在很多重复值的字段上建立索引\n索引算法\nB树算法：树状结构，可以用在=，>登操作符，也可以用在like操作符（前缀形式）的操作中\nHash算法：只能用于对等比较，因为Hash与数据顺序无关\nB树与B+树的区别\nB树的内部节点和叶子节点都可以放键值，B+树的内部节点都是键，值放在叶子节点\nB+树的叶子节点有一条链相连，B树的叶子节点格子的独立\nB+树一次可以读取更多的键，有利于更快得缩小查找范围，有一条链相连可以更快的遍历\nB+树与红黑树的区别\n在内存中，红黑树比B树效率更高，但是涉及到磁盘操作，B树就更优了；B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表；查询过程中B树可能需要跨层访问，而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了\nInnoDB与MyISAM的区别\nInnoDB:支持事务，行锁，支持外键，支持B树索引\nMyISAM:有存储限制，不支持事务，支持B树索引，支持全文索引，内存使用低\n悲观锁和乐观锁\n1.悲观锁：数据库自带的锁，每次更新数据的时候先获取锁才能对相同数据的操作\n2.乐观锁：在操作数据时不做任何特殊处理，在更新的时候再去判断数据是否被修改，如果被修改就不更新，如果未被修改则更新数据\nObject有哪些方法\nequals(),hashCode(),getClass(),toString(),clone(),finalize(),wait(),notify(),notifyAll()方法\n序列化与反序列化\n1.把对象转换成字节序列的过程称为对象的序列化\n2.把字节序列恢复为对象的过程称为对象的反序列化\njdk1.8新特性\nlambda表达式(函数式编程，允许把函数作为一个方法的参数，代码更加简洁，紧凑)；\n函数式接口，方法引用，Stream(创建stream，中间操作，过滤，map，终止操作)，并行数组（递归分合，分而治之），布隆过滤器")])]),n._v(" "),o("p",[n._v("事务相关")]),n._v(" "),o("blockquote",[o("p",[n._v("事务的四大特征\nACI\bD\n原子性、一致性、隔离性、持久性\n事务的四种隔离级别\n脏读  不可重复读  幻读\nRead uncommitted(读未提交) 是 是 是\nRead committed（读已提交）  否 是 是 （Oracle默认隔离级别）\nRepeatable read（可重复读） 否 否 是 （Mysql默认隔离级别）\nSerializable（串行读）      否 否 否\n什么是脏读，不可重复读，幻读\n脏读:简单来说,就是一个事务读取到了另一个事务未提交的数据。\n不可重复读:就是说,比如在A事务中进行多次相同的查询,B事务在A事务多次查询之间修改对应表中的数据,导致A事务多次读取的结果不一致。\n幻读:举例来说,就是A事务将表中'性别'列的值都更改为1,B事务在A事务修改之后又添加了一条记录,而'性别'的值为0,回过来A再查询所以的记录时会发现有一条记录的'性别'为0,这种情况就是所谓的幻读\n事务的传播行为\n事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。\n事务的七种传播行为\nPROPAGATION_REQUIRED 表示当前方法必须在一个具有事务的 上下文中运行,如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。( 如果被调用端发生异常,那么调用端和被调用端事务都将回滚)\nPROPAGATION_SUPPORTS 表示当前方法不必需要具有一个事务 上下文,但是如果有一个事务的话,它也可以在这个事务中运行\nPROPAGATION_MANDATORY 表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常\nPROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\nPROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。\nPROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常\nPROPAGATION_NESTED表示如果当前方法正有一个事务在运行中,则该方法应该运行在一个嵌套事务中 ,被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在,并且外层事务抛出异常回滚，那么内层事务必须回滚,反之,内层事务并不影响外层事务。如果封装事务不存在,则同propagation. required的一样")])]),n._v(" "),o("p",[n._v("＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝\nJDBC Connection接口提供了两种事务模式:自动提交和手工提交\nJDBC中的事务java.sql.Connection的三个方法与事务有关:\nsetAutoCommt(bolean): 设置是否自动提交事务,如果true(默认true)表示自动提交,也就是每条执行的SQL语句都是一个单独的事务,如果设置为false,需要手动提交事务.\ncommit(): 提交结束事务\nrollback(): 回滚事务")])])}),[],!1,null,null,null);e.default=t.exports}}]);