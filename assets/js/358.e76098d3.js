(window.webpackJsonp=window.webpackJsonp||[]).push([[358],{846:function(n,e,a){"use strict";a.r(e);var t=a(6),o=Object(t.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"apollo在java中的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#apollo在java中的使用"}},[this._v("#")]),this._v(" Apollo在Java中的使用")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('普通 Java 项目中使用\n加入 Apollo Client 的 Maven 依赖，代码如下所示。\n<dependency>\n    <groupId>com.ctrip.framework.apollo</groupId>\n    <artifactId>apollo-client</artifactId>\n    <version>1.1.0</version>\n</dependency>\n\n使用 API 的方式来获取配置，具体代码如下所示。\npublic class App {\n    public static void main(String[] args) {\n        Config config = ConfigService.getAppConfig();\n        String key = "username";\n        String defaultValue = "张三";\n        String username = config.getProperty(key, defaultValue);\n        System.out.println("username=" + username);\n    }\n}\n通过 ConfigService 得到 Config 对象，config.getProperty() 方法可以传入你想获取的配置 Key，defaultValue 是当配置中心找不到配置的时候返回的默认值，避免空指针异常。\n\n运行上面这段代码，输出的结果是默认值“张三”。因为我们还没有指定 Apollo 需要的一些必要信息，这些信息包括 Meta Server、AppId 和 Environment。Cluster 可以不用指定，用默认即可。\n1. Meta Server 配置\nApollo 支持应用在不同的环境中有不同的配置，所以需要运行提供给 Apollo 客户端当前环境的 Apollo Meta Server 信息。\n\n在默认情况下，meta server 和 config service 是部署在同一个 JVM 进程里的，所以 meta server 的地址就是 config service 的地址。\n\n目前我们用的快速启动包只有一个 DEV 环境，config service 的地址是 http://localhost：8080，这个已经在启动脚本 demo.sh 中定义好了。\n\n为了能够让示例代码在各位读者的电脑上也能直接运行，我们将配置定在 classpath：/META-INF/app.properties 中。内容为 apollo.meta=http://localhost：8080。\n2. APPid 配置\nAPPid 是应用的身份信息，是从服务端获取配置的一个重要信息。同样 APPid 的配置方式也有多种，我们采用跟 Meta Server 一样的方式，配置在 classpath：/META-INF/app.properties 中。内容为 app.id=SampleApp。\n\nSampleApp 在 Portal 的项目主页面中有展示，如果是你自己新建的项目，那么就是你自定义的 AppId。\n3. Environment 配置\nEnvironment 跟项目本身没有关系，一个项目可以部署在不同的环境中，代码不需要改变，需要变化的只是配置值而已。所以 Environment 的配置不能配置在项目中，最常用的有如下两种配置方式。\n1）通过 Java System Property\n可以通过 Java 的 System Property env 来指定环境。\n在 Java 程序启动脚本中，可以指定 -Denv=YOUR-ENVIRONMENT。\n如果是运行 jar 文件，需要注意格式为 java-Denv=YOUR-ENVIRONMENT-jar xxx.jar。\n注意 key 为全小写。\n2）通过配置文件\n最后一个推荐的方式是通过配置文件来指定 env=YOUR-ENVIRONMENT。\n对于 Mac/Linux，文件位置为 /opt/settings/server.properties。\n对于 Windows，文件位置为 C：\\opt\\settings\\server.properties。\n\nserver.properties 内容为 env=DEV。\n\n同样的，为了能够让示例代码能够更方便地在各位读者的电脑上运行，我们就用 ava System Property 的方式来指定 Environment，要么在 IDE 的启动参数中指定，要么就在 main 方法的第一行通过代码指定（仅供开发演示用，不能用于生产环境）。具体代码所示。\npublic static void main(String[] args) {\n    System.setProperty("env", "DEV");\n    // ....\n}\n\n所有配置完成之后，我们再次运行前面的示例代码，可以看到输出的内容就是我们自己配置的值。\n4. 监听配置变化事件\n在某些场景下，当配置发生变化的时候，我们需要进行一些特殊的处理。比如，数据库连接串变化后需要重建连接等，就可以使用 API 提供的监听机制。具体代码如下所示。\nconfig.addChangeListener(new ConfigChangeListener() {\n    public void onChange(ConfigChangeEvent changeEvent) {\n        System.out.println("发生修改数据的命名空间是：" + changeEvent.getNamespace());\n        for (String key : changeEvent.changedKeys()) {\n            ConfigChange change = changeEvent.getChange(key);\n            System.out.println(\n                    String.format("发现修改 - 配置key: %s, 原来的值: %s, 修改后的值: %s, 操作类型: %s", \n                            change.getPropertyName(),\n                            change.getOldValue(), change.getNewValue(), change.getChangeType()));\n        }\n    }\n});\n当我们在 Portal 中进行修改配置时，就会触发监听事件，输出结果为：\n发生修改数据的命名空间是：application\n发现修改 - 配置key: username, 原来的值: zhangsan, 修改后的值: zhangsan1, 操作类型: MODIFIED\n\nSpring Boot 中使用\n首先准备一个 Spring Boot 项目，加入 Apollo Client 的 Maven 依赖，具体代码如下所示：\n<dependency>\n    <groupId>com.ctrip.framework.apollo</groupId>\n    <artifactId>apollo-client</artifactId>\n    <version>1.1.0</version>\n</dependency>\n\n然后配置 Apollo 的信息，配置放在 application.properties 中：\napp.id=SampleApp\napollo.meta=http://localhost:8080\napollo.bootstrap.enabled=true\napollo.bootstrap.namespaces=application\n\n其中，\napp.id：身份信息。\napollo.meta：Meta Server（Config Service）。\napollo.bootstrap.enabled：项目启动的 bootstrap 阶段，向 Spring 容器注入配置信息。\napollo.bootstrap.namespaces：注入命名空间。\n\n环境同样在 main 方法中指定，代码如下所示。\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        // 指定环境(仅供开发演示用, 不能用于生产环境))\n        System.setProperty("env", "DEV");\n        SpringApplication.run(App.class, args);\n    }\n}\n1. Placeholder 注入配置\nPlaceholder 注入配置代码如下所示。\n/**\n* 用户名, 默认值为zhangsan\n*/\n@Value("${username:zhangsan}")\nprivate String username;\n\n2. Java Config 使用方式\nJava Config 使用方式具体代码如下所示。\n@Data\n@Configuration\npublic class UserConfig {\n    @Value("${username:zhangsan}")\n    private String username;\n}\n使用 Config 配置类注入具体代码如下所示：\n@Autowired\nprivate UserConfig userConfig;\n\n3. ConfigurationProperties 使用方式\nConfigurationProperties 的使用方法具体代码如下所示。\n@Data\n@Configuration\n@ConfigurationProperties(prefix = "redis.cache")\npublic class RedisConfig {\n    private String host;\n}\n配置中心只需要增加 redis.cache.host 配置项即可实现注入，配置内容如下：\nredis.cache.host = 192.168.1.1\n\nConfigurationProperties 方式有个缺点，当配置的值发生变化时不会自动刷新，而是需要手动实现刷新逻辑，笔者建议大家不要使用这种方式，比较繁琐。\n\n如果有配置需要加统一前缀的方式可以用 Java Config 的方式代替。\n4. Spring Annotation 支持\n1）@ApolloConfig\n用来自动注入 Apollo Config 对象，代码如下所示。\n@ApolloConfig\nprivate Config config;\n@GetMapping("/config/getUserName3")\npublic String getUserName3() {\n    return config.getProperty("username", "zhangsan");\n}\n2）@ApolloConfigChangeListener\n用来自动注册 ConfigChangeListener，代码如下所示。\n@ApolloConfigChangeListener\nprivate void someOnChange(ConfigChangeEvent changeEvent) {\n    if(changeEvent.isChanged("username")) {\n        System.out.println("username发生修改了");\n    }\n}\n3）@ApolloJsonValue\n用来把配置的 JSON 字符串自动注入为对象。\n\n定义一个实体类，代码如下所示。\n@Data\npublic class Student {\n    private int id;\n    private String name;\n}\n\n对象注入，代码如下所示。\n@ApolloJsonValue("${stus:[]}")\nprivate List<Student> stus;\n\n后台增加配置内容如下：\nstus = [{"id":1,"name":"jason"}]\n\n')])])])])}),[],!1,null,null,null);e.default=o.exports}}]);