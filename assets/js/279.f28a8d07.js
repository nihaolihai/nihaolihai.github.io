(window.webpackJsonp=window.webpackJsonp||[]).push([[279],{770:function(e,t,a){"use strict";a.r(t);var r=a(6),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"day13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#day13"}},[e._v("#")]),e._v(" day13")]),e._v(" "),a("h2",{attrs:{id:"java-高级应用之io流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-高级应用之io流"}},[e._v("#")]),e._v(" Java 高级应用之IO流")]),e._v(" "),a("h2",{attrs:{id:"java-io流作用-就是用来加载本地或者远程的文件-也支持对二进制文件或者字符文件的读写-如何将文件映射成java的对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-io流作用-就是用来加载本地或者远程的文件-也支持对二进制文件或者字符文件的读写-如何将文件映射成java的对象"}},[e._v("#")]),e._v(" Java IO流\n作用:就是用来加载本地或者远程的文件,\n也支持对二进制文件或者字符文件的读写.\n如何将文件映射成Java的对象?")]),e._v(" "),a("p",[e._v("Java提供了java.io.File\n但是注意一点:只能对文件夹或者文件的本身信息进行读取,\n但是不能读写文件里面的内容,操作文件里面的内容需要\n用到流(Stream)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    构造方法:\n          public File(String path);//通过一个指定的路径来构建一个File实例\n          public File(File parent, String child) ;\n          public File(String parent,String child);\n\n   常用方法:\n      业务判断方法:\n            delete();//删除此抽象路径名下的文件或者文件夹\n                        //注意:文件可以直接删除,但是文件夹必须为空才能删\n             \n            exists() ;//判断路径下是否存在了该文件或者文件夹\n\n            isDirectory() ;//判断是文件还是文件夹\n\n            isFile();//判断是否文件\n")])])]),a("hr"),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("       文件或者文件夹创建的:\n            mkdir() :\n            mkdirs():\n                  ---上面两个都是用来创建目录的,但是后者可以创建多层次结构的目录\n            createNewFile() ;//创建一个空文件\n")])])]),a("hr"),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("        获取文件或者文件夹信息的有:\n            length();//判断文件的长度\n      \n            listFiles();//输出指定目录下面的所有文件\n\n            listFiles(FilterName fiterName);//输出指定目录下面的指定后缀的文件\n\n            getAbsolutePath() ;//得到该文件或者文件夹的绝对路径\n\n            getName();//得到文件或者文件夹的名称\n\n            getParent() ;//获取指定父目录路径\n\n            getPath() ;//将抽象路径转换成字符串表现形式\n")])])]),a("hr"),e._v(" "),a("p",[e._v("Java IO流(Stream):\n作用: 从源头到目标不停地搬运内容的对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("           源头:网络,键盘,网盘.....\n           目标:网络,网盘,硬盘,显示器......\n          \n      类进行分类:按照流的类型可以分成输入流(InputStream)和输出流(OutputStream)\n\n      输入:由外界到JVM\n      输出:由JVM到外界\n\n    按照功能分为字节流和字符流\n\n    字节输入流:java.io.InputStream      IO流的顶级抽象父类\n                    --ByteArrayInputStream  操作字节数组的输入流\n                    --FileInputStream            操作文件的输入流\n                    --ObjectInputStream        操作对象类型的输入流\n                    -- FilterInputStream         过滤输入流\n                        \\\\--BufferedInputStream  带缓存功能的输入流\n                        \\\\--DataInputStream       操作基本类型的输入流\n    公用方法:\n                    read();//每次只能读单个字节\n                    read(byte[] buf);//每次读取的内容放到缓冲区byte中\n                                            //如果到达文件末尾,没有流可读,返回-1\n                    read(byte[] buf,int off,int len);\n                          b - 读入数据的缓冲区。\n                          off - 数组 b 中将写入数据的初始偏移量。\n                          len - 要读取的最大字节数。\n                     close();关闭流\n     \n     字节输出流:  java.io.OutputStream     字节输出流的顶级抽象父类\n                    --ByteArrayOutputStream  操作字节数组的输出流\n                    --FileOutputStream            操作文件的输出流\n                    --ObjectOutputStream        操作对象类型的输出流\n                    -- FilterOutputStream         过滤输出流\n                        \\\\--BufferedOutputStream  带缓存功能的输出流\n                        \\\\--DataOutputStream       操作基本类型的输出流\n     公用方法:\n                    write();//每次写单个字节\n                    write(byte[] b) ;将 b.length 个字节从指定的 byte 数组写入此输出流\n                    write(byte[] b, int off, int len) ; 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。\n                    close();//关闭流\n")])])]),a("p",[e._v("//步骤:\n1.定位源头和目标\n2.初始化源头和目标\n3.循环读取\n进行业务操作(加密,复制,写入...)\n4.关闭流")]),e._v(" "),a("h2",{attrs:{id:"案例-实现文件的拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例-实现文件的拷贝"}},[e._v("#")]),e._v(" 案例:实现文件的拷贝")]),e._v(" "),a("p",[e._v('IO流框架的设计思想\n[装饰模式]也称为"油漆工"模式')]),e._v(" "),a("p",[e._v("就是把我们的类分成两大类,一个叫做基础类(节点流),一个叫做拓展类(过滤流)\n基础类是具有真正的读写能力的,但是拓展类只是用来进行功能拓展\n本身不具备真正的读写能力,它需要以基础类作为支撑")]),e._v(" "),a("p",[e._v("节点流:\nByteArrayInputStream/ByteArrayOutputStream\nFileInputStream/FileOutputStream\n过滤流:\nObjectInputStream/ObjectOutputStream\nFilterInputStream/FileterOutputStream\nBufferedInputStream/BufferedOutputStream\nDataInputStream/DataOutputStream")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    IO流之所以这样设计,就是可以任意组合节点流和过滤流\n\n    比如:1.构建一个带缓存的文件输入流\n    BufferedInputStream bs = new BufferedInputStream(new FileInputStream(String path));\n")])])]),a("hr"),e._v(" "),a("p",[e._v("读取对象类型(本质就是对象的序列化)\nJava对象序列化的要求:\n1)要求被序列化的对象必须要是吸纳java.io.Serializable接口\n2)如果自定义类中有其他自定义类型的属性,则这个属性也要实现序列化接口\n3)如果序列化一个集合对象,则要求集合中的所有元素都必须实现序列化接口")]),e._v(" "),a("h2",{attrs:{id:"瞬态关键字-transient如果序列化的对象-不想持久化某一个或者多个属性-则可以使用此关键字来修饰这个属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#瞬态关键字-transient如果序列化的对象-不想持久化某一个或者多个属性-则可以使用此关键字来修饰这个属性"}},[e._v("#")]),e._v(" 瞬态关键字:transient\n如果序列化的对象,不想持久化某一个或者多个属性,则可以使用此关键字来修饰这个属性")]),e._v(" "),a("h2",{attrs:{id:"字符流-作用是用来操作文本文件的字符输入流java-io-reader-字符输入流的顶级抽象父类-chararrayreader-操作字符数组的输入流-filterreader-过滤输入流-stringreader-操作字符串的输入流-inputstreamreader-桥接器-是字节流通向字符流的桥梁-filereader-操作文件的输入流-bufferedreader-带缓存功能的字符输入流公用方法-readline-读取一整行文本字符输出流-java-io-writer-字符输出流的顶级抽象父类-printwriter-它是节点流特点-1-自带缓存功能2-关闭流不需要抓异常write-写入print-println-写入-线程安全的-filewriter-操作文件的字符输出流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符流-作用是用来操作文本文件的字符输入流java-io-reader-字符输入流的顶级抽象父类-chararrayreader-操作字符数组的输入流-filterreader-过滤输入流-stringreader-操作字符串的输入流-inputstreamreader-桥接器-是字节流通向字符流的桥梁-filereader-操作文件的输入流-bufferedreader-带缓存功能的字符输入流公用方法-readline-读取一整行文本字符输出流-java-io-writer-字符输出流的顶级抽象父类-printwriter-它是节点流特点-1-自带缓存功能2-关闭流不需要抓异常write-写入print-println-写入-线程安全的-filewriter-操作文件的字符输出流"}},[e._v("#")]),e._v(" 字符流:作用是用来操作文本文件的\n字符输入流\njava.io.Reader  字符输入流的顶级抽象父类\n---CharArrayReader  操作字符数组的输入流\n---FilterReader           过滤输入流\n---StringReader          操作字符串的输入流\n---InputStreamReader  桥接器  (是字节流通向字符流的桥梁)\n---FileReader             操作文件的输入流\n---BufferedReader      带缓存功能的字符输入流\n公用方法:\nreadLine();//读取一整行文本\n字符输出流:\njava.io.Writer   字符输出流的顶级抽象父类\n----PrintWriter   它是节点流\n特点:1.自带缓存功能\n2.关闭流不需要抓异常\nwrite();//写入\nprint();\nprintln();//写入   线程安全的\n----FileWriter  操作文件的字符输出流")]),e._v(" "),a("p",[e._v("笔试题:java.util.Scanner 类是用来获取键盘输入的,不允许用此类\n来实现获取键盘输入\n用桥接器 InputStreamReader来实现的")])])}),[],!1,null,null,null);t.default=n.exports}}]);