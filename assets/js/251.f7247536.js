(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{740:function(e,n,r){"use strict";r.r(n);var t=r(6),o=Object(t.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"mybatis一对一关联查询-级联查询"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mybatis一对一关联查询-级联查询"}},[this._v("#")]),this._v(" MyBatis一对一关联查询（级联查询）")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('一对一级联关系在现实生活中是十分常见的，例如一个大学生只有一张一卡通，一张一卡通只属于一个学生。再如人与身份证的关系也是一对一的级联关系。\n\nMyBatis 如何处理一对一级联查询呢？在 MyBatis 中，通过 <resultMap> 元素的子元素 <association> 处理这种一对一级联关系。\n\n在 <association> 元素中通常使用以下属性。\nproperty：指定映射到实体类的对象属性。\ncolumn：指定表中对应的字段（即查询返回的列名）。\njavaType：指定映射到实体对象属性的类型。\nselect：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询。\n\n下面以个人与身份证之间的关系为例讲解一对一级联查询的处理过程，读者只需参考该实例即可学会一对一级联查询的 MyBatis 实现。\n1）创建数据表\nCREATE TABLE \'idcard\' (\n    \'id\' tinyint(2) NOT NULL AUTO_INCREMENT,\n    \'code\' varchar(18) COLLATE utf8_unicode_ci DEFAULT NULL,\n    PRIMARY KEY (\'id\')\n)；\nCREATE TABLE \'person\'(\n    \'id\' tinyint(2) NOT NULL,\n    \'name\' varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,\n    \'age\' int(11) DEFAULT NULL,\n    \'idcard_id\' tinyint(2) DEFAULT NULL,\n    PRIMARY KEY (\'id\'),\n    KEY \'idcard_id\' (\'idcard_id\'),\n    CONSTRAINT \'idcard_id\' FOREIGN KEY (\'idcard_id\') REFERENCES \'idcard\'(\'id\')\n);\n2）创建持久化类\n在 myBatisDemo02 应用的 com.po 包中创建数据表对应的持久化类 Idcard 和 Person。\n\nIdcard 的代码如下：\npackage com.mybatis.po;\npublic class Idcard {\n    private Integer id;\n    private String code;\n    // 省略setter和getter方法\n    /**\n     * 为方便测试，重写了toString方法\n     */\n    @Override\n    public String toString() {\n        return "Idcard [id=" + id + ",code=" + code + "]";\n    }\n}\nPerson 的代码如下：\npackage com.mybatis.po;\npublic class Person {\n    private Integer id;\n    private String name;\n    private Integer age;\n    // 个人身份证关联\n    private Idcard card;\n    // 省略setter和getter方法\n    @Override\n    public String toString() {\n        return "Person[id=" + id + ",name=" + name + ",age=" + age + ",card="\n                + card + "]";\n    }\n}\n3）创建映射文件\n首先，在 MyBatis 的核心配置文件 mybatis-config.xml（com.mybatis）中打开延迟加载开关，代码如下：\n\x3c!--在使用MyBatis嵌套查询方式进行关联查询时，使用MyBatis的延迟加载可以在一定程度上提高查询效率--\x3e\n<settings>\n    \x3c!--打开延迟加载的开关--\x3e\n    <setting name= "lazyLoadingEnabled" value= "true"/>\n    \x3c!--将积极加载改为按需加载--\x3e\n    <setting name="aggressiveLazyLoading" value="false"/>\n</settings>\n然后，在 myBatisDemo02 应用的 com.mybatis 中创建两张表对应的映射文件 IdCardMapper.xml 和 PersonMapper.xml。在 PersonMapper.xml 文件中以 3 种方式实现“根据 id 查询个人信息”的功能，详情请看代码备注。\n\nIdCardMapper.xml 的代码如下：\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\nPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n"http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="com.dao.IdCardDao">\n    <select id="selectCodeById" parameterType="Integer" resultType= "com.po.Idcard">\n        select * from idcard where id=#{id}\n    </select>\n</mapper>\nPersonMapper.xml 的代码如下：\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\nPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n"http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="com.dao.PersonDao">\n    \x3c!-- 一对一根据id查询个人信息：级联查询的第一种方法（嵌套查询，执行两个SQL语句）--\x3e\n    <resultMap type="com.po.Person" id="cardAndPerson1">\n        <id property="id" column="id"/>\n        <result property="name" column="name"/>\n        <result property="age" column="age"/>\n        \x3c!-- 一对一级联查询--\x3e\n        <association property="card" column="idcard_id" javaType="com.po.Idcard"\n        select="com.dao.IdCardDao.selectCodeByld"/>\n    </resultMap>\n    <select id="selectPersonById1" parameterType="Integer" resultMap=\n    "cardAndPerson1">\n        select * from person where id=#{id}\n    </select>\n    \x3c!--对一根据id查询个人信息：级联查询的第二种方法（嵌套结果，执行一个SQL语句）--\x3e\n    <resultMap type="com.po.Person" id="cardAndPerson2">\n        <id property="id" column="id"/>\n        <result property="name" column="name"/>\n        <result property="age" column="age"/>\n        \x3c!-- 一对一级联查询--\x3e\n        <association property="card" javaType="com.po.Idcard">\n            <id property="id" column="idcard_id"/>\n            <result property="code" column="code"/>\n        </association>\n    </resultMap>\n    <select id="selectPersonById2" parameterType="Integer" resultMap= "cardAndPerson2">\n        select p.*,ic.code\n        from person p, idcard ic\n        where p.idcard_id=ic.id and p.id=#{id}\n    </select>\n    \x3c!-- 一对一根据id查询个人信息：连接查询（使用POJO存储结果）--\x3e\n    <select id="selectPersonById3" parameterType="Integer" resultType= "com.pojo.SelectPersonById">\n        select p.*,ic.code\n        from person p, idcard ic\n        where p.idcard_id = ic.id and p.id=#{id}\n    </select>\n</mapper>\n4）创建 POJO 类\n在 myBatisDemo02 应用的 com.pojo 包中创建在第 3 步中使用的 POJO 类 com.pojo.SelectPersonById。\n\nSelectPersonById 的代码如下：\npackage com.pojo;\npublic class SelectPersonById {\n    private Integer id;\n    private String name;\n    private Integer age;\n    private String code;\n    //省略setter和getter方法\n    @Override\n    public String toString() {\n        return "Person [id=" +id+",name=" +name+ ",age=" +age+ ",code=" +code+ "]";\n    }\n}\n5）创建数据操作接口\n在 myBatisDemo02 应用的 com.dao 包中创建第 3 步中映射文件对应的数据操作接口 IdCardDao 和 PersonDao。\n\nIdCardDao 的代码如下：\n@Repository("idCardDao")\n@Mapper\npublic interface IdCardDao {\n    public Idcard selectCodeById(Integer i);\n}\nPersonDao 的代码如下：\n@Repository("PersonDao")\n@Mapper\npublic interface PersonDao {\n    public Person selectPersonById1(Integer id);\n    public Person selectPersonById2(Integer id);\n    public SelectPersonById selectPersonById3(Integer id);\n}\n6）调用接口方法及测试\n在 myBatisDemo02 应用的 com.controller 包中创建 OneToOneController 类，在该类中调用第 5 步的接口方法，同时创建测试类 TestOneToOne。\n\nOneToOneController 的代码如下：\n@Controller("oneToOneController")\npublic class OneToOneController {\n    @Autowired\n    private PersonDao personDao;\n    public void test(){\n        Person p1 = personDao.selectPersonById1(1);\n        System.out.println(p1);\n        System.out.println("=============================");\n        Person p2 = personDao.selectPersonById2(1);\n        System.out.println(p2);\n        System.out.println("=============================");\n        selectPersonById p3 = personDao.selectPersonById3(1);\n        System.out.println(p3);\n    }\n}\nTestOneToOne 的代码如下：\n纯文本复制\npublic class TestOneToOne {\n    public static void main(String[] args) {\n        ApplicationContext appcon = new ClassPathXmlApplicationContext("applicationContext.xml");\n        OneToOneController oto = (OneToOneController)appcon.getBean("oneToOne-Controller");\n        oto.test();\n    }\n}\n\n')])])])])}),[],!1,null,null,null);n.default=o.exports}}]);