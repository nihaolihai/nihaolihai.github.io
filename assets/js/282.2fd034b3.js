(window.webpackJsonp=window.webpackJsonp||[]).push([[282],{775:function(n,a,t){"use strict";t.r(a);var o=t(6),e=Object(o.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"day16"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day16"}},[n._v("#")]),n._v(" day16")]),n._v(" "),t("h2",{attrs:{id:"提纲-注解annotation简介jdk内置的annotationannotation的定义annotation的使用annotation的高级特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提纲-注解annotation简介jdk内置的annotationannotation的定义annotation的使用annotation的高级特性"}},[n._v("#")]),n._v(" 提纲：注解\nAnnotation简介\nJDK内置的Annotation\nAnnotation的定义\nAnnotation的使用\nAnnotation的高级特性")]),n._v(" "),t("p",[n._v("为什么使用Annotation?\n在Java应用中,我们经常遇到模板代码.比如:我们编写一个\nWeb Service 我们需要提供一个接口和实现作为模板,如果\n使用Annotation来修饰远程访问的代码,这些模板可以通过\n工具自动生成!")]),n._v(" "),t("p",[n._v("现在框架的使用:Hibernate  Spring......\n好处:使用注解维护附属文件(配置文件)比较便利.并且不容易错误")]),n._v(" "),t("p",[n._v("Annotation的工作方式:\n它是JDK1.5以后的新特性,它允许开发者自己定义并且使用!")]),n._v(" "),t("p",[n._v("注意点:1.Annotation它本身是不会对程序的语义产生作用,它可以看作类似程序的工具或者类库\n,它会反过来对正在运行的程序语义有所影响\n2.它可以从源文件,可以从CLASS文件获取,还可以从以运行时反射的多种方式进行获取")]),n._v(" "),t("h2",{attrs:{id:"annotation组成-1-一个定义annotation类型的语法2-一个描述annotation声明的语法3-调用annotation的api4-一个使用-interface修饰的类-interface是定义注解的关键字5-一组维护annotation的工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#annotation组成-1-一个定义annotation类型的语法2-一个描述annotation声明的语法3-调用annotation的api4-一个使用-interface修饰的类-interface是定义注解的关键字5-一组维护annotation的工具"}},[n._v("#")]),n._v(" Annotation组成:\n1.一个定义Annotation类型的语法\n2.一个描述Annotation声明的语法\n3.调用Annotation的API\n4.一个使用@interface修饰的类--------\x3e@interface是定义注解的关键字\n5.一组维护Annotation的工具")]),n._v(" "),t("h2",{attrs:{id:"jdk内置注解-override-代表方法重写-overload-代表方法重载-deprecated-代表已过时-suppresswarnings-抑制警告-unused-定义了变量但是没有使用-rawtypes-抑制没有加入泛型的警告-serial-抑制没有添加序列号的警告-all-抑制所有的警告-unchecked"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk内置注解-override-代表方法重写-overload-代表方法重载-deprecated-代表已过时-suppresswarnings-抑制警告-unused-定义了变量但是没有使用-rawtypes-抑制没有加入泛型的警告-serial-抑制没有添加序列号的警告-all-抑制所有的警告-unchecked"}},[n._v("#")]),n._v(" JDK内置注解\n@override       代表方法重写\n@overload      代表方法重载\n@deprecated  代表已过时\n@SuppressWarnings   抑制警告\n---unused   定义了变量但是没有使用\n---rawtypes  抑制没有加入泛型的警告\n---serial        抑制没有添加序列号的警告\n---all             抑制所有的警告\n---unchecked")]),n._v(" "),t("p",[n._v("自定义Annotation\n使用@interface来定义Annotation类型\n自动继承(隐式继承)  java.lang.annotation.Annotation接口\n由编译器完成细节")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("     注:在定义Annotation类型时,不能继承其他的Annotation型或者是接口\n\n     语法:public @interface MyAnnotation{\n                    //只有属性的概念,没有方法,默认的方法名是value\n                    //还可以通过default给它一个默认值\n                    String[] value();\n     }\n")])])]),t("hr"),n._v(" "),t("p",[n._v("Annotation的高级特性\n1.  java.lang.annotation.Target  类型\n指示注释类型所适用的程序元素的种类")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("        默认的代表注解使用在全局\n\n        一般它是配合java.lang.annotation.ElementType里面的枚举值使用\n        常用的枚举类型有:\n                  TYPE:类/接口等\n                  FIELD属性\n                  METHOD:方法\n                     .....等等\n\n         2.java.lang.annotation.Retention   注解的保留策略\n            配合java.lang.annotatin.RetentionPolicy 里面的枚举常量来使用\n                    CLASS :可以从CLASS文件中获取注解信息\n                    SOURCE:可以从源文件中获取注解信息\n                    RUNTIME:可以反射读取注解信息\n")])])]),t("hr"),n._v(" "),t("h2",{attrs:{id:"注解继承-子类可以继承父类加在类上面的注解-但是父类中方法上面的注解不能够被子类继承-因为父类的方法还是会被子类重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注解继承-子类可以继承父类加在类上面的注解-但是父类中方法上面的注解不能够被子类继承-因为父类的方法还是会被子类重写"}},[n._v("#")]),n._v(" 注解继承:子类可以继承父类加在类上面的注解,但是父类中方法上面的\n注解不能够被子类继承,因为父类的方法还是会被子类重写")])])}),[],!1,null,null,null);a.default=e.exports}}]);