(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{624:function(n,s,i){"use strict";i.r(s);var t=i(6),a=Object(t.a)({},(function(){var n=this,s=n.$createElement,i=n._self._c||s;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h2",{attrs:{id:"java-继承"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java-继承"}},[n._v("#")]),n._v(" Java 继承")]),n._v(" "),i("p",[n._v("继承的概念\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。")]),n._v(" "),i("p",[n._v("继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。")]),n._v(" "),i("p",[n._v("生活中的继承：")]),n._v(" "),i("p",[n._v("兔子和羊属于食草动物类，狮子和豹属于食肉动物类。")]),n._v(" "),i("p",[n._v("食草动物和食肉动物又是属于动物类。")]),n._v(" "),i("p",[n._v("所以继承需要符合的关系是：is-a，父类更通用，子类更具体。")]),n._v(" "),i("p",[n._v("虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。")]),n._v(" "),i("p",[n._v("类的继承格式\n在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：")]),n._v(" "),i("p",[n._v("类的继承格式\nclass 父类 {\n}")]),n._v(" "),i("p",[n._v("class 子类 extends 父类 {\n}\n为什么需要继承\n接下来我们通过实例来说明这个需求。")]),n._v(" "),i("p",[n._v("开发动物类，其中动物分别为企鹅以及老鼠，要求如下：")]),n._v(" "),i("p",[n._v('企鹅：属性（姓名，id），方法（吃，睡，自我介绍）\n老鼠：属性（姓名，id），方法（吃，睡，自我介绍）\n企鹅类：\npublic class Penguin {\nprivate String name;\nprivate int id;\npublic Penguin(String myName, int  myid) {\nname = myName;\nid = myid;\n}\npublic void eat(){\nSystem.out.println(name+"正在吃");\n}\npublic void sleep(){\nSystem.out.println(name+"正在睡");\n}\npublic void introduction() {\nSystem.out.println("大家好！我是"         + id + "号" + name + ".");\n}\n}\n老鼠类：\npublic class Mouse {\nprivate String name;\nprivate int id;\npublic Mouse(String myName, int  myid) {\nname = myName;\nid = myid;\n}\npublic void eat(){\nSystem.out.println(name+"正在吃");\n}\npublic void sleep(){\nSystem.out.println(name+"正在睡");\n}\npublic void introduction() {\nSystem.out.println("大家好！我是"         + id + "号" + name + ".");\n}\n}\n从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类：')]),n._v(" "),i("p",[n._v("公共父类：\npublic class Animal {\nprivate String name;"),i("br"),n._v('\nprivate int id;\npublic Animal(String myName, int myid) {\nname = myName;\nid = myid;\n}\npublic void eat(){\nSystem.out.println(name+"正在吃");\n}\npublic void sleep(){\nSystem.out.println(name+"正在睡");\n}\npublic void introduction() {\nSystem.out.println("大家好！我是"         + id + "号" + name + ".");\n}\n}\n这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：')]),n._v(" "),i("p",[n._v("企鹅类：\npublic class Penguin extends Animal {\npublic Penguin(String myName, int myid) {\nsuper(myName, myid);\n}\n}\n老鼠类：\npublic class Mouse extends Animal {\npublic Mouse(String myName, int myid) {\nsuper(myName, myid);\n}\n}\n继承类型\n需要注意的是 Java 不支持多继承，但支持多重继承。")]),n._v(" "),i("p",[i("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png",alt:"RUNOOB 图标"}})]),n._v(" "),i("p",[n._v("继承的特性\n子类拥有父类非 private 的属性、方法。")]),n._v(" "),i("p",[n._v("子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。")]),n._v(" "),i("p",[n._v("子类可以用自己的方式实现父类的方法。")]),n._v(" "),i("p",[n._v("Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。")]),n._v(" "),i("p",[n._v("提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。")]),n._v(" "),i("p",[n._v("继承关键字\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。")]),n._v(" "),i("p",[n._v("extends关键字\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。")]),n._v(" "),i("p",[n._v("extends 关键字\npublic class Animal {\nprivate String name;"),i("br"),n._v("\nprivate int id;\npublic Animal(String myName, String myid) {\n//初始化属性值\n}\npublic void eat() {  //吃东西方法的具体实现  }\npublic void sleep() { //睡觉方法的具体实现  }\n}")]),n._v(" "),i("p",[n._v("public class Penguin  extends  Animal{\n}\nimplements关键字\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。")]),n._v(" "),i("p",[n._v("implements 关键字\npublic interface A {\npublic void eat();\npublic void sleep();\n}")]),n._v(" "),i("p",[n._v("public interface B {\npublic void show();\n}")]),n._v(" "),i("p",[n._v("public class C implements A,B {\n}\nsuper 与 this 关键字\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。")]),n._v(" "),i("p",[n._v("this关键字：指向自己的引用。")]),n._v(" "),i("p",[n._v('实例\nclass Animal {\nvoid eat() {\nSystem.out.println("animal : eat");\n}\n}')]),n._v(" "),i("p",[n._v('class Dog extends Animal {\nvoid eat() {\nSystem.out.println("dog : eat");\n}\nvoid eatTest() {\nthis.eat();   // this 调用自己的方法\nsuper.eat();  // super 调用父类方法\n}\n}')]),n._v(" "),i("p",[n._v("public class Test {\npublic static void main(String[] args) {\nAnimal a = new Animal();\na.eat();\nDog d = new Dog();\nd.eatTest();\n}\n}\n输出结果为：")]),n._v(" "),i("p",[n._v("animal : eat\ndog : eat\nanimal : eat\nfinal关键字\nfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：")]),n._v(" "),i("p",[n._v("声明类：")]),n._v(" "),i("p",[n._v("final class 类名 {//类体}\n声明方法：")]),n._v(" "),i("p",[n._v("修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}\n注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final")]),n._v(" "),i("p",[n._v("构造器\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。")]),n._v(" "),i("p",[n._v("如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。")]),n._v(" "),i("p",[n._v('实例\nclass SuperClass {\nprivate int n;\nSuperClass(){\nSystem.out.println("SuperClass()");\n}\nSuperClass(int n) {\nSystem.out.println("SuperClass(int n)");\nthis.n = n;\n}\n}\n// SubClass 类继承\nclass SubClass extends SuperClass{\nprivate int n;')]),n._v(" "),i("p",[n._v('SubClass(){ // 自动调用父类的无参数构造器\nSystem.out.println("SubClass");\n}')]),n._v(" "),i("p",[n._v('public SubClass(int n){\nsuper(300);  // 调用父类中带有参数的构造器\nSystem.out.println("SubClass(int n):"+n);\nthis.n = n;\n}\n}\n// SubClass2 类继承\nclass SubClass2 extends SuperClass{\nprivate int n;')]),n._v(" "),i("p",[n._v('SubClass2(){\nsuper(300);  // 调用父类中带无参数的构造器\nSystem.out.println("SubClass2");\n}')]),n._v(" "),i("p",[n._v('public SubClass2(int n){ // 自动调用父类的有参数构造器\nSystem.out.println("SubClass2(int n):"+n);\nthis.n = n;\n}\n}\npublic class TestSuperSub{\npublic static void main (String args[]){\nSystem.out.println("------SubClass 类继承------");\nSubClass sc1 = new SubClass();\nSubClass sc2 = new SubClass(100);\nSystem.out.println("------SubClass2 类继承------");\nSubClass2 sc3 = new SubClass2();\nSubClass2 sc4 = new SubClass2(200);\n}\n}\n输出结果为：')]),n._v(" "),i("p",[n._v("------SubClass 类继承------\nSuperClass()\nSubClass\nSuperClass(int n)\nSubClass(int n):100\n------SubClass2 类继承------\nSuperClass(int n)\nSubClass2\nSuperClass()\nSubClass2(int n):200")])])}),[],!1,null,null,null);s.default=a.exports}}]);