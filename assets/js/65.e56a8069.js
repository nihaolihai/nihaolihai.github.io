(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{551:function(n,i,t){"use strict";t.r(i);var a=t(6),e=Object(a.a)({},(function(){var n=this,i=n.$createElement,t=n._self._c||i;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"条例2-当构造函数的参数很多时-考虑使用构建器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条例2-当构造函数的参数很多时-考虑使用构建器"}},[n._v("#")]),n._v(" 条例2：当构造函数的参数很多时，考虑使用构建器")]),n._v(" "),t("p",[n._v("静态工厂方法和构造函数都有一个共同的限制：它们对大量可选参数的扩展性不好。举个表示包装食品上的营养成分标签的类的例子，\n成分标签上有一些必填字段——分量，每个容器的分量和每份的卡路里以及二十多个可选字段——总脂肪，饱和脂肪，反式脂肪，胆固醇，\n钠等。大多数产品仅对其中部分可选字段具有非零值。")]),n._v(" "),t("p",[n._v("你会为这样的一个类编写出怎样的构造函数或静态工厂方法？传统上，程序员使用伸缩构造函数模式，这种模式提供一个只有必填字段\n的构造函数，另一个是在必填参数构造函数的基础上多一个可选参数的构造函数，再提供一个比必填构造函数多两个参数的构造函数，\n依次类推。直到一个具有必填字段和所有可选参数的构造函数。下面是实际上它看上去的样子。为了简单起见，只有四个可选的字段展示\n在下面：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 伸缩构造函数模式——不能很好地扩展\npublic class NutritionFacts {\n    private final int servingSize;      //(mL)  必填\n    private final int servings;         //(per container) 必填\n    private final int calories;         //(per serving) 可选\n    private final int fat;              //(g / serving)   可选\n    private final int sodium;           //(mg / serving)  可选\n    private final int carbohydrate;     //(g / serving)   可选\n\n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n")])])]),t("p",[n._v("当你想创建一个实例时，使用包含所需设置的所有参数的最短参数列表的构造函数。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("NutritionFacts cocoCola = new NutritionFacts(240, 8, 100, 0, 35, 27);\n")])])]),t("p",[n._v("通常这个构造函数调用会需要许多你需要设置的参数，但是你被迫要给它们传个值。上面例子中，我们给fat传了个0。只有6\n个参数可能看起来不是那么糟，但是随着参数数量的增加，它很快就就失控了。")]),n._v(" "),t("p",[n._v("简而言之，伸缩构造函数模式可以用，但是当有很多构造函数参数时，很难编写客户端代码，而且可读性很差。阅读代码的人\n对参数值充满疑问，且必须数着参数才能搞清楚。相同类型参数的长序列可能导致细微的错误。如果使用方意外地弄反了两个同类型\n参数，编译器不会检测出来，但是程序会在运行期出现非预期行为。")]),n._v(" "),t("p",[n._v("当面对带有许多可选参数的构造函数时的第二种可选方法是JavaBeans模式，这种模式下，调用无参数的构造函数来创建对象，然后\n调用对象的setter方法来为每个必填字段和感兴趣的可选字段设置值。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//JavaBeans 模式 ———允许不一致性，要求可变性\npublic class NutritionFacts {\n    //参数初始化为默认值（如果有的话）\n    private int servingSize = -1; //必填，没有默认值\n    private int servings = -1;    //必填，没有默认值\n    private int calories = 0;\n    private int fat = 0;\n    private int sodium = 0;\n    private int carbohydrate = 0;\n\n    public NutritionFacts() { }\n\n    public void setServingSize(int val) { servingSize = val; }\n    public void setServings(int val) { servings = val; }\n    public void setCalories(int val) { calories = val; }\n    public void setFat(int val) { fat = val; }\n    public void setSodium(int val) { sodium = val; }\n    public void setCarbohydrate(int val) { carbohydrate = val; }\n}\n")])])]),t("p",[n._v("这个模式没有伸缩模式的任何缺点。它很简单，创建实例很容易(如果有些冗长)，代码很容易阅读。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("NutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServingSize(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);`\n")])])]),t("p",[n._v("不幸的是，JavaBeans模式本身有严重的缺点。因为构造横跨多个调用，JavaBean在其构造过程中可能处于不一致的状态。\n这个类不能仅仅通过检查构造函数参数的有效性来强制一致性。在对象处于不一致状态时使用它可能会导致失败，这些失败\n和包含错误的代码相去甚远，因此很难调试。一个相关的缺点是JavaBeans模式排除了将类置为不可变的可能性且要求程序员\n付出额外的努力来确保线程安全。")]),n._v(" "),t("p",[n._v("在对象构造完成前手动地冻结对象，且在冻结期间不允许使用它可以减少JavaBeans模式的缺点，但是这些变体很笨拙，在实践中\n也很少使用。甚者，可能在运行期引发错误，因为编译器不能确保程序员在使用对象前对它调用了冻结方法。")]),n._v(" "),t("p",[n._v("幸运地是，有第三种可选方案综合了伸缩狗杂函数模式的安全及JavaBeans模式的可读性。它是构造者模式的形式。与直接构造目标\n对象相反的是，使用者调用带有所有必填参数的构造函数或静态工厂方法，且获得一个构造者对象。然后使用者在构造者对象上调用\n类似setter的方法设置每个感兴趣的参数。最终，使用者调用无参的build方法来产生目标对象，它通常是不可变的。构造者通常是\n它要构造的类的静态成员类。下面是实际中使用的样子：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 构造者模式\npublic class NutritionFacts {\n    private final int servingSize;      //(mL)  必填\n    private final int servings;         //(per container) 必填\n    private final int calories;         //(per serving) 可选\n    private final int fat;              //(g / serving)   可选\n    private final int sodium;           //(mg / serving)  可选\n    private final int carbohydrate;     //(g / serving)   可选\n\n    public static class Builder {\n        //必填参数\n        private final int servingSize;\n        private final int servings;\n\n        //可先参数初始化为默认值\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val;\n            return this;\n        }\n\n        public Builder sodium(int val) {\n            sodium = val;\n            return this;\n        }\n\n        public Builder fat(int val) {\n            fat = val;\n            return this;\n        }\n\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n            return this;\n        }\n\n        public NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n}\n")])])]),t("p",[t("code",[n._v("NutritionFacts")]),n._v("类是不可变的，所有参数默认值都在同一个地方。构造者的setter方法返回构造者本身这样调用就可以链接起来，\n形成流式API。如下为使用代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("NutritionFacts cocaCola = new Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();\n")])])]),t("p",[n._v("使用代码很容易编写，更重要的是可读性好。构造者模式模拟了Python和Scala中的命名可选参数。")]),n._v(" "),t("p",[n._v("出于简便，验证检查省略了。为尽可能快地侦测到不合法参数，在构造器的构造函数和方法中检查参数有效性。\n检查build方法调用的构造函数中的多个参数的不变性。为确保这些不变量免受攻击，在从构造器中拷贝参数到\n目标实例后，实施对象字段的检查。如果检查失败，扔出"),t("code",[n._v("IllegalArgumentException")]),n._v("，它的详细信息中表示了\n哪些参数是不合法的。")]),n._v(" "),t("p",[n._v("构造器模式很适合类层次结构。使用并行的构造器层次，每个嵌套在对应的类中。抽象类拥有抽象的构造器了具体类\n有具体的构造器，比如，看一下代表了不同种类pizza的层级的根部的抽象类")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//类层次的构造器模式\npublic abstract class Pizza {\n    public enum Topping {\n        HAM, MUSHROOM, ONION, PEPPER, SAUSAGE\n    }\n\n    final Set<Topping> toppings;\n\n    abstract static class Builder<T extends Builder<T>> {\n        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);\n\n        public T addTopping(Topping topping) {\n            toppings.add(Objects.requireNonNull(topping));\n            return self();\n        }\n\n        abstract Pizza build();\n\n        // 子类必须重写这个方法返回this\n        protected abstract T self();\n    }\n\n    Pizza(Builder<?> builder) {\n        toppings = builder.toppings.clone();\n    }\n}\n")])])]),t("p",[n._v("注意Pizza.Builder是带有递归类型参数的泛型类型。")])])}),[],!1,null,null,null);i.default=e.exports}}]);