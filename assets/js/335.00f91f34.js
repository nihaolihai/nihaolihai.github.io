(window.webpackJsonp=window.webpackJsonp||[]).push([[335],{836:function(e,n,l){"use strict";l.r(n);var t=l(6),i=Object(t.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"spring-cloud-feign整合hystrix实现容错处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-feign整合hystrix实现容错处理"}},[this._v("#")]),this._v(" Spring Cloud Feign整合Hystrix实现容错处理")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('创建一个新的 Maven 项目 hystrix-feign-demo，增加 EurekaClient，Feign，Hystrix 的依赖，然后在属性文件中开启 Feign 对 Hystrix 的支持：\nfeign.hystrix.enabled=true\n\n1. Fallback 方式\n在 Feign 的客户端类上的 @FeignClient 注解中指定 fallback 进行回退（代码如下所示），创建一个 Feign 的客户端类 UserRemoteClient，为其配置 fallback。\n@FeignClient (value = "eureka-client-user-service", fallback = UserRemoteClientFallback.class)\npublic interface UserRemoteClient {\n    @GetMapping("/user/hello")\n    String hello();\n}\nUserRemoteClientFallback 类需要实现 UserRemoteClient 类中所有的方法，返回回退时的内容，代码如下所示。\n@Component\npublic class UserRemoteClientFallback implements UserRemoteClient {\n    @Override\n    public String hello() {\n        return "fail";\n    }\n}\n停掉所有 eureka-client-user-service 服务，然后访问 /callHello 接口，这个时候 eureka-client-user-service 服务是不可用的，必然会触发回退，返回的内容是 fail 字符串，这证明回退生效了。\n\n在这种情况下，如果你的接口调用了多个服务的接口，那么只有 eureka-client-user-service 服务会没数据，不会影响别的服务，如果不用 Hystrix 回退处理，整个请求都将失败。\n{\n    code:200,\n    message:"",\n    data:{\n        id:1,\n        money:100.12,\n        name:"fail"\n    }\n}\n\n下面我们将启用 Hystrix 断路器禁用：\nfeign.hystrix.enabled=false\n\n再次访问 /callHello 可以看到返回的就是 500 错误信息了，整个请求失败。\n2. FallbackFactory 方式\n通过 fallback 已经可以实现服务不可用时回退的功能，如果你想知道触发回退的原因，可以使用 FallbackFactory 来实现回退功能，代码如下所示。\n@Component\npublic class UserRemoteClientFallbackFactory implements FallbackFactory<UserRemoteClient> {\n    private Logger logger = LoggerFactory.getLogger(UserRemoteClientFallbackFactory.class);\n    @Override\n    public UserRemoteClient create(final Throwable cause) {\n        logger.error("UserRemoteClient回退：", cause);\n        return new UserRemoteClient() {\n            @Override\n            public String hello() {\n                return "fail";\n            }\n        };\n    }\n}\nFallbackFactory 的使用就是在 @FeignClient 中用 fallbackFactory 指定回退处理类，代码如下所示。\n@FeignClient(value = "eureka-client-user-service", configuration = FeignConfiguration.class, fallbackFactory = UserRemoteClientFallbackFactory.class)\n\n笔者在这个回退处理的时候，将异常信息通过日志输出了，我们重新调用接口，可以看到异常信息在开发工具的控制台中输出了，FallbackFactory 和 Fallback 唯一的区别就在这里。\nFeign 中禁用 Hystrix\n禁用 Hystrix 还是比较简单的，目前有两种方式可以禁用，一种是在属性文件中进行全部禁用，默认就是禁用的状态。\nfeign.hystrix.enabled=false\n\n另一种是通过代码的方式禁用某个客户端，在 Feign 的配置类中增加如下所示的代码。\n纯文本复制\n@Configuration\npublic class FeignConfiguration {\n    @Bean \n    @Scope("prototype")\n    public Feign.Builder feignBuilder() {\n        return Feign.builder();\n    }\n}\n\n\n')])])])])}),[],!1,null,null,null);n.default=i.exports}}]);