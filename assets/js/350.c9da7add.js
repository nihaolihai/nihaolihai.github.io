(window.webpackJsonp=window.webpackJsonp||[]).push([[350],{839:function(n,e,t){"use strict";t.r(e);var a=t(6),r=Object(a.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud-gateway的常用路由断言工厂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-gateway的常用路由断言工厂"}},[this._v("#")]),this._v(" Spring Cloud Gateway的常用路由断言工厂")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('Spring Cloud Gateway 内置了许多路由断言工厂，可以通过配置的方式直接使用，也可以组合使用多个路由断言工厂。接下来为大家介绍几个常用的路由断言工厂类。\n1）Path 路由断言工厂\nPath 路由断言工厂接收一个参数，根据 Path 定义好的规则来判断访问的 URI 是否匹配。\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: host_route\n    uri: http://c.biancheng.net\n    predicates:\n      - Path=/blog/detail/{segment}\n\n如果请求路径为 /blog/detail/xxx，则此路由将匹配。也可以使用正则，例如 /blog/detail/** 来匹配 /blog/detail/ 开头的多级 URI。\n\n我们访问本地的网关：http://localhost：2001/blog/detail/36185 ，可以看到显示的是 http://c.biancheng.net/blog/detail/36185 对应的内容。\n2）Query 路由断言工厂\nQuery 路由断言工厂接收两个参数，一个必需的参数和一个可选的正则表达式。\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: query_route\n      uri: http://c.biancheng.net\n      predicates:\n        - Query=foo, ba.\n\n如果请求包含一个值与 ba 匹配的 foo 查询参数，则此路由将匹配。bar 和 baz 也会匹配，因为第二个参数是正则表达式。\n\n测试链接：http://localhost：2001/?foo=baz。\n3）Method 路由断言工厂\nMethod 路由断言工厂接收一个参数，即要匹配的 HTTP 方法。\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: method_route\n  uri: http://baidu.com\n  predicates:\n    - Method=GET\n\n4）Header 路由断言工厂\nHeader 路由断言工厂接收两个参数，分别是请求头名称和正则表达式。\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: header_route\n  uri: http://example.org\n  predicates:\n    - Header=X-Request-Id, \\d+\n\n如果请求中带有请求头名为 x-request-id，其值与 \\d+ 正则表达式匹配（值为一个或多个数字），则此路由匹配。\n\n如果你想学习更多路由断言工厂的用法，可以参考官方文档进行学习。\n自定义路由断言工厂\n自定义路由断言工厂需要继承 AbstractRoutePredicateFactory 类，重写 apply 方法的逻辑。\n\n在 apply 方法中可以通过 exchange.getRequest() 拿到 ServerHttpRequest 对象，从而可以获取到请求的参数、请求方式、请求头等信息。\n\napply 方法的参数是自定义的配置类，在使用的时候配置参数，在 apply 方法中直接获取使用。\n\n命名需要以 RoutePredicateFactory 结尾，比如 CheckAuthRoutePredicateFactory，那么在使用的时候 CheckAuth 就是这个路由断言工厂的名称。代码如下所示。\n@Component\npublic class CheckAuthRoutePredicateFactory\n        extends AbstractRoutePredicateFactory<CheckAuthRoutePredicateFactory.Config> {\n    public CheckAuthRoutePredicateFactory() {\n        super(Config.class);\n    }\n    @Override\n    public Predicate<ServerWebExchange> apply(Config config) {\n        return exchange -> {\n            System.err.println("进入了CheckAuthRoutePredicateFactory\\t" + config.getName());\n            if (config.getName().equals("zhangsan")) {\n                return true;\n            }\n            return false;\n        };\n    }\n    public static class Config {\n        private String name;\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getName() {\n            return name;\n        }\n    }\n}\n使用示例如下所示：\nspring:\n  cloud:\n    gateway:\n      routes:\n  - id: customer_route\n  uri: http://c.biancheng.net\n  predicates:\n    - name: CheckAuth\n  args:\n    name: zhangsan\n\n')])])])])}),[],!1,null,null,null);e.default=r.exports}}]);