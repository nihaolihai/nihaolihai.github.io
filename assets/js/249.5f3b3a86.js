(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{744:function(e,t,n){"use strict";n.r(t);var s=n(6),r=Object(s.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"mybatis-resultmap元素的结构及使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-resultmap元素的结构及使用"}},[this._v("#")]),this._v(" MyBatis resultMap元素的结构及使用")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('<resultMap> 元素表示结果映射集，是 MyBatis 中最重要也是最强大的元素，主要用来定义映射规则、级联的更新以及定义类型转化器等。\n<resultMap> 元素的结构\n<resultMap> 元素包含了一些子元素，结构如下：\n<resultMap id="" type="">\n    <constructor>\x3c!-- 类再实例化时用来注入结果到构造方法 --\x3e\n        <idArg/>\x3c!-- ID参数，结果为ID --\x3e\n        <arg/>\x3c!-- 注入到构造方法的一个普通结果 --\x3e  \n    </constructor>\n    <id/>\x3c!-- 用于表示哪个列是主键 --\x3e\n    <result/>\x3c!-- 注入到字段或JavaBean属性的普通结果 --\x3e\n    <association property=""/>\x3c!-- 用于一对一关联 --\x3e\n    <collection property=""/>\x3c!-- 用于一对多、多对多关联 --\x3e\n    <discriminator javaType="">\x3c!-- 使用结果值来决定使用哪个结果映射 --\x3e\n        <case value=""/>\x3c!-- 基于某些值的结果映射 --\x3e\n    </discriminator>\n</resultMap>\n<resultMap> 元素的 type 属性表示需要的 POJO，id 属性是 resultMap 的唯一标识。\n子元素 <constructor> 用于配置构造方法（当 POJO 未定义无参数的构造方法时使用）。\n子元素 <id> 用于表示哪个列是主键。\n子元素 <result> 用于表示POJO和数据表普通列的映射关系。\n子元素 <association>、<collection> 和 <discriminator> 用在级联的情况下。关于级联的问题比较复杂，后面教程会详细讲解。\n\n一条查询 SQL 语句执行后将返回结果，而结果可以使用 Map 存储，也可以使用 POJO 存储。\n使用 Map 存储结果集\n任何 select 语句都可以使用 Map 存储结果，示例代码如下：\n\x3c!-- 查询所有用户信息存到Map中 --\x3e\n<select id="selectAllUserMap" resultType="map">\n    select * from user\n</select>\n测试上述 SQL 配置文件的过程如下：\n\n首先在 com.dao.UserDao 接口中添加以下接口方法。\npublic List<Map<String,Object>> selectAllUserMap();\n\n然后在 com.controller 包的 UserController 类中调用接口方法，具体代码如下。\n// 查询所有用户信息存到Map中\nList<Map<String, Object>> lmp = userDao.selectAllUserMap();\nfor (Map<String, Object> map : lmp) {\n    System.out.println(map);\n}\n上述 Map 的 key 是 select 语句查询的字段名（必须完全一样），而 Map 的 value 是查询返回结果中字段对应的值，一条记录映射到一个 Map 对象中。Map 用起来很方便，但可读性稍差，有的开发者不太喜欢使用 Map，更多时候喜欢使用 POJO 的方式。\n使用POJO存储结果集\n有的开发者喜欢使用 POJO 的方式存储结果集，一方面可以使用自动映射，例如使用 resultType 属性，但有时候需要更为复杂的映射或级联，这时候就需要使用 <select> 元素的 resultMap 属性配置映射集合。具体步骤如下：\n1）创建 POJO 类\n在 myBatisDemo02 应用的 com.pojo 包中创建 POJO 类 MapUser。MapUser 类的代码如下：\npackage com.pojo;\npublic class MapUser {\n    private Integer m_uid;\n    private String m_uname;\n    private String m_usex;\n    // 此处省略setter和getter方法\n    @Override\n    public String toString() {\n        return "User[uid=" + m_uid + ",uname=" + m_uname + ",usex=" + m_usex\n                + "]";\n    }\n}\n2）配置 <resultMap> 元素\n在 SQL 映射文件 UserMapper.xml 中配置 <resultMap> 元素，其属性 type 引用 POJO 类。具体配置如下：\n\x3c!--使用自定义结果集类型--\x3e\n<resultMap type="com.pojo.MapUser" id="myResult">\n    \x3c!-- property 是 com.pojo.MapUser 类中的属性--\x3e\n    \x3c!-- column是查询结果的列名，可以来自不同的表--\x3e\n    <id property="m_uid" column="uid"/>\n    <result property="m_uname" column="uname"/>\n    <result property="m_usex" column="usex"/>\n</resultMap>\n3）配置<select>元素\n在 SQL 映射文件 UserMapper.xml 中配置 <select> 元素，其属性 resultMap 引用了 <resultMap> 元素的 id。具体配置如下：\n\x3c!-- 使用自定义结果集类型查询所有用户 --\x3e\n<select id="selectResultMap" resultMap="myResult">\n    select * from user\n</select>\n4）添加接口方法\n在 com.dao.UserDao 接口中添加以下接口方法：\npublic List<MapUser> selectResultMap();\n\n5）调用接口方法\n在 com.controller 包的 UserController 类中调用接口方法，具体代码如下：\n纯文本复制\n// 使用resultMap映射结果集\nList<MapUser> listResultMap = userDao.selectResultMap();\nfor (MapUser myUser : listResultMap) {\n    System.out.println(myUser);\n}\n\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);