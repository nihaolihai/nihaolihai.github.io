(window.webpackJsonp=window.webpackJsonp||[]).push([[272],{764:function(n,a,e){"use strict";e.r(a);var t=e(6),s=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"day6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day6"}},[n._v("#")]),n._v(" day6")]),n._v(" "),e("p",[n._v("提纲:面向对象三大特征:\n封装\n---封装策略   1.实体类和业务类合二为一\n2.实体类和业务类分开\n继承:(Inheritance)")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("                  多态:(polymorphic)\n")])])]),e("p",[n._v("回顾一下:\n知识点1:如何对属性进行封装:\n1.把属性的访问修饰符设置成private\n2.提供一个getter/setter方法来进行读取/设置值")]),n._v(" "),e("p",[n._v("知识点2:\n比较set方法赋值和构造方法赋值:\n1.构造方法赋值只能进行一次,并且是在创建对象的时候,构造方法自己不能\n进行参数有效性判断,它要想也能实现参数有效性判断的话,需要在它里面再次\n调用set方法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("   2.set方法可以多次赋值,并且是在它需要的时候进行赋值,并且可以进行参数有效性判断\n     这也是封装的原因之一;\n")])])]),e("h2",{attrs:{id:"封装的原因-第一-保证属性的封装性-第二个可以通过set方法进行参数有效性判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装的原因-第一-保证属性的封装性-第二个可以通过set方法进行参数有效性判断"}},[n._v("#")]),n._v(" 封装的原因:第一:保证属性的封装性;第二个可以通过set方法进行参数有效性判断!")]),n._v(" "),e("p",[n._v("封装策略:\n实体类:专门用来存储数据的,在于数据\n业务类:专门用来操作数据,操作实体类,在于功能")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("      策略一:\n            实体类跟业务类合二为一:\n            \n             public class Account{\n                    private int id;\n                    private String password;\n                    private String name;\n                    private double balance;\n\n                    //构造\n                    //getter/setter\n\n                    //业务方法一:存钱\n                    public void deposit(double money){\n                          this.balance+=money;\n                    }\n\n                    //业务方法二:取钱\n                    public void withdraw(double money){\n                          this.balance-=money;\n                    }\n             }\n\n    策略二:实体类和业务类分开\n\n                实体类:\n                        public class Account{\n                                //成员变量\n                                //空参构造\n                                //有参构造\n                                //getter/setter方法\n                                //toString()方法\n                        }\n                  \n                  业务类:\n                        public class AccountBiz{\n                                //存钱\n                                      \n                               //取钱\n                                      \n                        }\n")])])]),e("hr"),n._v(" "),e("p",[n._v("知识点2:\n继承(Inheritance)---\x3e关键字  extends\n在Java当中都是单继承的,C/C++是多继承的\n单继承可以保证类的层次性,不会产生网状结构")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("   注意:尽量将几个类的共性的东西抽象出来放在一个父类当中,\n")])])]),e("p",[n._v("//定义一个类\nclass sup{\n//共性的成员(属性+方法)\n}\n//再定义一个类继承sup\nclass sub extends sup{\n//个性的成员\n}")]),n._v(" "),e("p",[n._v("sup叫做父类,也叫做超类\nsub叫做子类,也叫做派生类")]),n._v(" "),e("p",[n._v("这里的sup会自动去继承谁?------\x3ejava.lang.Object-----\x3e顶级类\n注意点:在Java当中,当一个类没有去显式地去继承一个父类的时候,\n那么它会自动去继承java.lang.Object这个顶级类")]),n._v(" "),e("p",[n._v("在Java当中,虽然不支持多继承,但是我们可以有其他方法实现!(接口)\n注意:一个子类有且只有一个直接的父类\n但是继承具有传递性\nA extends B   B extends C   也就是  A间接继承C")]),n._v(" "),e("p",[n._v("有了继承之后,子类可以访问父类当中非私有的成员")]),n._v(" "),e("p",[n._v("继承就是为了日后拓展用的\n但是不能为了代码的复用而去乱继承")]),n._v(" "),e("h2",{attrs:{id:"得考虑是否满足-a-is-b-的这种语法例子-cat-is-animalapple-is-fruit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#得考虑是否满足-a-is-b-的这种语法例子-cat-is-animalapple-is-fruit"}},[n._v("#")]),n._v(" 得考虑是否满足   A  IS  B  的这种语法\n例子:                  cat is Animal\napple is fruit")]),n._v(" "),e("p",[n._v("子类创建对象的过程:\n通过以下三个步骤,递归创建父类对象\n1.申请堆空间\n2.初始化\n3.调用构造")]),n._v(" "),e("p",[n._v("super关键字\n作用一:在子类构造中,可以通过super关键字来显示调用父类中存在的有参构造\n如果你想要调用父类中的无参构造,那么super()可以省略,并且super必须放在子类构造中的第一行;")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    作用二:\n")])])]),e("p",[n._v("方法的重写:\n条件是:出现在父子类当中")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("  满足条件:\n          1.方法名要相同\n          2.方法的返回类型要相同\n          3.方法的参数列表要相同\n          4.子类方法的访问修饰符的等级要小于等于父类等级\n                访问修饰符等级从低到高    public protected 默认 private\n          5.子类方法抛出的异常要小于父类\n")])])]),e("p",[n._v("引出:\n面向父类编程:\n1.方法的返回类型写成父类\n2.方法的参数类型写成父类\n3.方法的编译时类型写成父类\n利用面向父类编程的思想:\n方法的编译时类型可以写成父类\nAnimal  animal = new Dog();\nAnimal animal = new Cat();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("这里a的编译时类型是Animal  运行时类型是Dog和Cat\n\n编译时类型:   对象引用的类型\n运行时类型:   对象本身真正的类型\n")])])]),e("p",[n._v("我们的Object可以作为其他类的编译时类型")]),n._v(" "),e("p",[n._v("为什么要有方法的重写呢?\n一个对象,只能使用编译时类型中的非私有的属性和方法,\n如果我们用Object作为编译时类型的时候,我们只能调用Object中的方法和属性")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    为了对象可以使用自己类中的特有的方法和属性,我们就选择了\n    在父类当中提供这个方法,并且在子类当中对方法进行重写\n    并且在调用方法的时候,它是选择的是对象本身真正的类型中\n    重写的那个方法 这也是多态的特征!\n")])])]),e("hr"),n._v(" "),e("p",[n._v("知识点3:多态\n1.存在于继承关系\n2.一定要有方法的重写(静态方法允许重写,但是没有多态!)")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("             对象  instanceof 类型\n\n             注意  如果类型是对象的父类或者是对象的运行时类型\n                      那么返回true,否则返回false\n                      \n\n                      java.lang.ClassCastException:\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);