(window.webpackJsonp=window.webpackJsonp||[]).push([[634],{1127:function(n,r,t){"use strict";t.r(r);var s=t(6),i=Object(s.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"springioc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springioc"}},[n._v("#")]),n._v(" springioc")]),n._v(" "),t("h3",{attrs:{id:"示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[n._v("#")]),n._v(" 示例")]),n._v(" "),t("p",[n._v("(1). IoC（Inversion of Control）是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；IoC还有另外一个名字——“依赖注入（Dependency Injection）”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。")]),n._v(" "),t("p",[n._v("(2). 在Spring的工作方式中，所有的类都会在spring容器中登记，告诉spring这是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。")]),n._v(" "),t("p",[n._v("(3). 在系统运行中，动态的向某个对象提供它所需要的其他对象。")]),n._v(" "),t("p",[n._v("(4). 依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。 注入方式有两种：依赖注入和设置注入；")]),n._v(" "),t("p",[n._v("IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。\nSpring中，IOC思想的体现就是依赖注入，在xml文件中或者使用注解创建对象交由IOC容器管理，之后获取对象就不再通过new 对象，而是通过配置文件从IOC容器中获取对象，之后修改就不需要改动程序，而只需要在xml配置文件中进行修改 ，将对象交由Spring去创建、管理、装配。")])])}),[],!1,null,null,null);r.default=i.exports}}]);