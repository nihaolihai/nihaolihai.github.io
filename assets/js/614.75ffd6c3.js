(window.webpackJsonp=window.webpackJsonp||[]).push([[614],{1106:function(n,o,e){"use strict";e.r(o);var t=e(6),a=Object(t.a)({},(function(){var n=this.$createElement,o=this._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[o("h2",{attrs:{id:"spring-cgllb动态代理-附带实例"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#spring-cgllb动态代理-附带实例"}},[this._v("#")]),this._v(" Spring CGLlB动态代理（附带实例）")]),this._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[this._v('通过《Spring JDK动态代理》教程的学习可以知道，JDK 动态代理使用起来非常简单，但是它也有一定的局限性，这是因为 JDK 动态代理必须要实现一个或多个接口，如果不希望实现接口，则可以使用 CGLIB 代理。\n\nCGLIB（Code Generation Library）是一个高性能开源的代码生成包，它被许多 AOP 框架所使用，其底层是通过使用一个小而快的字节码处理框架 ASM（Java 字节码操控框架）转换字节码并生成新的类。因此 CGLIB 要依赖于 ASM 的包，解压 Spring 的核心包 spring-core-3.2.2.RELEASE.jar\n\n解压的核心包中包含 cglib 和 asm，也就是说 Spring3.2.13 版本的核心包已经集成了 CGLIB 所需要的包，所以在开发中不需要另外导入 ASM 的 JAR 包了。下面通过案例演示实现 CGLIB 的代理过程。\n1. 创建目标类 GoodsDao\n在 com.mengma.dao 包下创建目标类 GoodsDao，在类中定义增、删、改、查方法，并在每个方法编写输出语句，如下所示。\npackage com.mengma.dao;\npublic class GoodsDao {\n    public void add() {\n        System.out.println("添加商品...");\n    }\n    public void update() {\n        System.out.println("修改商品...");\n    }\n    public void delete() {\n        System.out.println("删除商品...");\n    }\n    public void find() {\n        System.out.println("修改商品...");\n    }\n}\n2. 创建代理类 MyBeanFactory\n在 src 目录下创建一个名为 com.mengma.cglib 的包，该包下创建类 MyBeanFactory，如下所示。\npackage com.mengma.cglib;\nimport java.lang.reflect.Method;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\nimport com.mengma.dao.GoodsDao;\nimport com.mengma.jdk.MyAspect;\npublic class MyBeanFactory {\n    public static GoodsDao getBean() {\n        // 准备目标类\n        final GoodsDao goodsDao = new GoodsDao();\n        // 创建切面类实例\n        final MyAspect myAspect = new MyAspect();\n        // 生成代理类，CGLIB在运行时，生成指定对象的子类，增强\n        Enhancer enhancer = new Enhancer();\n        // 确定需要增强的类\n        enhancer.setSuperclass(goodsDao.getClass());\n        // 添加回调函数\n        enhancer.setCallback(new MethodInterceptor() {\n            // intercept 相当于 jdk invoke，前三个参数与 jdk invoke—致\n            @Override\n            public Object intercept(Object proxy, Method method, Object[] args,\n                    MethodProxy methodProxy) throws Throwable {\n                myAspect.myBefore(); // 前增强\n                Object obj = method.invoke(goodsDao, args); // 目标方法执行\n                myAspect.myAfter(); // 后增强\n                return obj;\n            }\n        });\n        // 创建代理类\n        GoodsDao goodsDaoProxy = (GoodsDao) enhancer.create();\n        return goodsDaoProxy;\n    }\n}\n上述代码中，应用了 CGLIB 的核心类 Enhancer。在第 19 行代码调用了 Enhancer 类的 setSuperclass() 方法，确定目标对象。\n\n第 21 行代码调用 setCallback() 方法添加回调函数；第 24 行代码的 intercept() 方法相当于 JDK 动态代理方式中的 invoke() 方法，该方法会在目标方法执行的前后，对切面类中的方法进行增强；第 33～34 行代码调用 Enhancer 类的 create() 方法创建代理类，最后将代理类返回。\n3. 创建测试类\n在 com.mengma.cglib 包下创建测试类 CGLIBProxyTest，编辑后如下所示。\npackage com.mengma.cglib;\nimport org.junit.Test;\nimport com.mengma.dao.GoodsDao;\npublic class CGLIBProxyTest {\n    @Test\n    public void test() {\n        // 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象）\n        GoodsDao goodsDao = MyBeanFactory.getBean();\n        // 执行方法\n        goodsDao.add();\n        goodsDao.update();\n        goodsDao.delete();\n        goodsDao.find();\n    }\n}\n上述代码中，调用 getBean() 方法时，依然获取的是 goodsDao 的代理对象，然后调用该对象的方法。使用 JUnit 测试运行 test() 方法，运行成功\n\n')])])])])}),[],!1,null,null,null);o.default=a.exports}}]);