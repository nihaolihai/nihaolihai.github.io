(window.webpackJsonp=window.webpackJsonp||[]).push([[371],{860:function(e,n,t){"use strict";t.r(n);var o=t(6),s=Object(o.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"服务消费方申请token"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#服务消费方申请token"}},[this._v("#")]),this._v(" 服务消费方申请Token")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('目前服务提供方已经开启了调用认证，这意味着如果现在直接调用接口会被拦截，所以在调用之前需要进行认证，即获取 Token 并将其放到请求头中与请求头一起传输才可以调用接口。\n1. 调用前获取 Token\n获取 Token 前我们先定义一个 Feign 的客户端，代码如下所示。\n/**\n* 认证服务 API 调用客户端\n**/\n@FeignClient(value = "auth-service", path = "/oauth")\npublic interface AuthRemoteClient {\n    /**\n     * 调用认证, 获取 token\n     *\n     * @param query\n     * @return\n     */\n    @PostMapping("/token")\n    ResponseData auth(@RequestBody AuthQuery query);\n}\n通过 AuthRemoteClient 就可以获取 Token。\n2. 缓存 Token 信息\n如果每次调用接口之前都去认证一次，肯定是不行的，因为这样会导致性能降低，而且 Token 是可以设置过期时间的，完全没必要每次都去重新申请。\n\n大家可以将 Token 缓存在本地或者 Redis 中。需要注意的是缓存时间必须小于 Token 的过期时间。\n3. 采用定时器刷新 Token\n就算获取的 Token 采用缓存来降低申请次数，这种方式也不是最优的方案。如果我们用的是 Feign 来消费接口，那么以下两种方式更好一些：一种方式就是在所有业务代码中调用接口前获取 Token，然后再进行相关设置。另一种是利用 Feign 提供的请求拦截器直接获取 Token，然后再进行相关设置。\n\n采用定时器刷新 Token 是笔者认为最优的方案，其耦合程度很低，只需要添加一个定时任务即可。需要注意的是，定时的时间间隔必须小于 Token 的失效时间，如果 Token 是 24 小时过期，那么你可以 20 个小时定时刷新一次来保证调用的正确性。\n\n定时刷新 Token 的代码如下所示。\n纯文本复制\n/**\n* 定时刷新 token\n**/\n@Component\npublic class TokenScheduledTask {\n    private static Logger logger = LoggerFactory.getLogger(TokenScheduledTask.class);\n    public final static long ONE_Minute = 60 * 1000 * 60 * 20;\n    @Autowired\n    private AuthRemoteClient authRemoteClient;\n    /**\n     * 刷新 Token\n     */\n    @Scheduled(fixedDelay = ONE_Minute)\n    public void reloadApiToken() {\n        String token = this.getToken();\n        while (StringUtils.isBlank(token)) {\n            try {\n                Thread.sleep(1000);\n                token = this.getToken();\n            } catch (InterruptedException e) {\n                logger.error("", e);\n            }\n        }\n        System.setProperty("fangjia.auth.token", token);\n    }\n    public String getToken() {\n        AuthQuery query = new AuthQuery();\n        query.setAccessKey("1");\n        query.setSecretKey("1");\n        ResponseData response = authRemoteClient.auth(query);\n        return response.getData() == null ? "" : response.getData().toString();\n    }\n}\n\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);