(window.webpackJsonp=window.webpackJsonp||[]).push([[419],{910:function(e,t,n){"use strict";n.r(t);var r=n(6),p=Object(r.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-mvc拦截器-interceptor-的配置及使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc拦截器-interceptor-的配置及使用"}},[this._v("#")]),this._v(" Spring MVC拦截器（Interceptor）的配置及使用")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('在开发一个网站时可能有这样的需求：某些页面只希望几个特定的用户浏览。对于这样的访问权限控制，应该如何实现呢？拦截器就可以实现上述需求。在 Struts 2 框架中，拦截器是其重要的组成部分，Spring MVC 框架也提供了拦截器功能。\n\nSpring MVC 的拦截器（Interceptor）与 Java Servlet 的过滤器（Filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。\n拦截器的定义\n在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置，定义一个拦截器可以通过两种方式：一种是通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类来定义；另一种是通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义。\n\n本节以实现 HandlerInterceptor 接口的定义方式为例讲解自定义拦截器的使用方法。示例代码如下：\npackage interceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\npublic class TestInterceptor implements HandlerInterceptor {\n    @Override\n    public void afterCompletion(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.out.println("afterCompletion方法在控制器的处理请求方法执行完成后执行，即视图渲染结束之后执行");\n    }\n    @Override\n    public void postHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.out.println("postHandle方法在控制器的处理请求方法调用之后，解析视图之前执行");\n    }\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n            HttpServletResponse response, Object handler) throws Exception {\n        System.out.println("preHandle方法在控制器的处理请求方法调用之后，解析视图之前执行");\n        return false;\n    }\n}\n在上述拦截器的定义中实现了 HandlerInterceptor 接口，并实现了接口中的 3 个方法。有关这 3 个方法的描述如下。\npreHandle 方法：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。\npostHandle 方法：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。\nafterCompletion 方法：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。\n拦截器的配置\n让自定义的拦截器生效需要在 Spring MVC 的配置文件中进行配置，配置示例代码如下：\n\x3c!-- 配置拦截器 --\x3e\n<mvc:interceptors>\n    \x3c!-- 配置一个全局拦截器，拦截所有请求 --\x3e\n    <bean class="interceptor.TestInterceptor" /> \n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/**" />\n        \x3c!-- 配置不需要拦截作用的路径 --\x3e\n        <mvc:exclude-mapping path="" />\n        \x3c!-- 定义<mvc:interceptor>元素中，表示匹配指定路径的请求才进行拦截 --\x3e\n        <bean class="interceptor.Interceptor1" />\n    </mvc:interceptor>\n    <mvc:interceptor>\n        \x3c!-- 配置拦截器作用的路径 --\x3e\n        <mvc:mapping path="/gotoTest" />\n        \x3c!-- 定义在<mvc: interceptor>元素中，表示匹配指定路径的请求才进行拦截 --\x3e\n        <bean class="interceptor.Interceptor2" />\n    </mvc:interceptor>\n</mvc:interceptors>\n在上述示例代码中，<mvc：interceptors> 元素用于配置一组拦截器，其子元素 <bean> 定义的是全局拦截器，即拦截所有的请求。\n\n<mvc：interceptor> 元素中定义的是指定路径的拦截器，其子元素 <mvc：mapping> 用于配置拦截器作用的路径，该路径在其属性 path 中定义。\n\n如上述示例代码中，path 的属性值“/**”表示拦截所有路径，“/gotoTest”表示拦截所有以“/gotoTest”结尾的路径。如果在请求路径中包含不需要拦截的内容，可以通过 <mvc：exclude-mapping> 子元素进行配置。\n\n需要注意的是，<mvc：interceptor> 元素的子元素必须按照 <mvc：mapping.../>、<mvc：exclude-mapping.../>、<bean.../> 的顺序配置\n\n')])])])])}),[],!1,null,null,null);t.default=p.exports}}]);