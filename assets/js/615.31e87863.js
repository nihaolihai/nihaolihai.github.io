(window.webpackJsonp=window.webpackJsonp||[]).push([[615],{1105:function(n,e,t){"use strict";t.r(e);var r=t(6),o=Object(r.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring通知类型及使用proxyfactorybean创建aop代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring通知类型及使用proxyfactorybean创建aop代理"}},[this._v("#")]),this._v(" Spring通知类型及使用ProxyFactoryBean创建AOP代理")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('在《Spring JDK动态代理》和《Spring CGLlB动态代理》中，讲解了 AOP 手动代理的两种方式，下面通过讲解 Spring 的通知介绍 Spring 是如何创建 AOP 代理的。\nSpring 通知类型\n通过前面的学习可以知道，通知（Advice）其实就是对目标切入点进行增强的内容，Spring AOP 为通知（Advice）提供了 org.aopalliance.aop.Advice 接口。\n\nSpring 通知按照在目标类方法的连接点位置，可以分为以下五种类型，如表 1 所示。\n\n表 1 Spring 通知的 5 种类型\n名称\t说明\norg.springframework.aop.MethodBeforeAdvice（前置通知）\t在方法之前自动执行的通知称为前置通知，可以应用于权限管理等功能。\norg.springframework.aop.AfterReturningAdvice（后置通知）\t在方法之后自动执行的通知称为后置通知，可以应用于关闭流、上传文件、删除临时文件等功能。\norg.aopalliance.intercept.MethodInterceptor（环绕通知）\t在方法前后自动执行的通知称为环绕通知，可以应用于日志、事务管理等功能。\norg.springframework.aop.ThrowsAdvice（异常通知）\t在方法抛出异常时自动执行的通知称为异常通知，可以应用于处理异常记录日志等功能。\norg.springframework.aop.IntroductionInterceptor（引介通知）\t在目标类中添加一些新的方法和属性，可以应用于修改旧版本程序（增强类）。\n声明式 Spring AOP\nSpring 创建一个 AOP 代理的基本方法是使用 org.springframework.aop.framework.ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，并可以生成指定的内容。\n\nProxyFactoryBean 类中的常用可配置属性如表 2 所示。\n\n表 2 ProxyFactoryBean 的常用属性\n属性名称\t描  述\ntarget\t代理的目标对象\nproxyInterfaces\t代理要实现的接口，如果有多个接口，则可以使用以下格式赋值：\n<list>\n    <value ></value>\n    ...\n</list>\nproxyTargetClass\t是否对类代理而不是接口，设置为 true 时，使用 CGLIB 代理\ninterceptorNames\t需要植入目标的 Advice\nsingleton\t返回的代理是否为单例，默认为 true（返回单实例）\noptimize\t当设置为 true 时，强制使用 CGLIB\n在 Spring 通知中，环绕通知是一个非常典型的应用。下面通过环绕通知的案例演示 Spring 创建 AOP 代理的过程。\n1. 导入 JAR 包\n在核心 JAR 包的基础上，再向 springDemo03 项目的 lib 目录中导入 AOP 的 JAR 包，具体如下。\nspring-aop-3.2.13.RELEASE.jar：是 Spring 为 AOP 提供的实现，在 Spring 的包中已经提供。\ncom.springsource.org.aopalliance-1.0.0.jar：是 AOP 提供的规范，可以在 Spring 的官网网址 https://repo.spring.io/webapp/#/search/quick/ 中进行搜索并下载。\n2. 创建切面类 MyAspect\n在 src 目录下创建一个名为 com.mengma.factorybean 的包，在该包下创建切面类 MyAspect，如下所示。\npackage com.mengma.factorybean;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\n//需要实现接口，确定哪个通知，及告诉Spring应该执行哪个方法\npublic class MyAspect implements MethodInterceptor {\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        System.out.println("方法执行之前");\n        // 执行目标方法\n        Object obj = mi.proceed();\n        System.out.println("方法执行之后");\n        return obj;\n    }\n}\n上述代码中，MyAspect 类实现了 MethodInterceptor 接口，并实现了接口的 invoke() 方法。MethodInterceptor 接口是 Spring AOP 的 JAR 包提供的，而 invoke() 方法用于确定目标方法 mi，并告诉 Spring 要在目标方法前后执行哪些方法，这里为了演示效果在目标方法前后分别向控制台输出了相应语句。\n3. 创建 Spring 配置文件\n在 com.mengma.factorybean 包下创建配置文件 applicationContext.xml，如下所示。\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http:/www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!--目标类 --\x3e\n    <bean id="customerDao" class="com.mengma.dao.CustomerDaoImpl" />\n    \x3c!-- 通知 advice --\x3e\n    <bean id="myAspect" class="com.mengma.factorybean.MyAspect" />\n    \x3c!--生成代理对象 --\x3e\n    <bean id="customerDaoProxy"\n     class="org.springframework.aop.framework.ProxyFactoryBean">\n     \x3c!--代理实现的接口 --\x3e\n        <property name="proxyInterfaces" value="com.mengma.dao.CustomerDao" />\n        \x3c!--代理的目标对象 --\x3e\n        <property name="target" ref="customerDao" />\n        \x3c!--用通知增强目标 --\x3e\n        <property name="interceptorNames" value="myAspect" />\n        \x3c!-- 如何生成代理，true:使用cglib; false :使用jdk动态代理 --\x3e\n        <property name="proxyTargetClass" value="true" />\n    </bean>\n</beans>\n上述代码中，首先配置目标类和通知，然后使用 ProxyFactoryBean 类生成代理对象；第 14 行代码配置了代理实现的接口；第 16 行代码配置了代理的目标对象；第 18 行代码配置了需要植入目标的通知；当第 20 行代码中的 value 属性值为 true 时，表示使用 CGLIB 代理，属性值为 false 时，表示使用 JDK 动态代理。\n4. 创建测试类\n在 com.mengma.factorybean 包下创建一个名为 FactoryBeanTest 的测试类，编辑后如下所示。\npackage com.mengma.factorybean;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.mengma.dao.CustomerDao;\npublic class FactoryBeanTest {\n    @Test\n    public void test() {\n        String xmlPath = "com/mengma/factorybean/applicationContext.xml";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n                xmlPath);\n        CustomerDao customerDao = (CustomerDao) applicationContext\n                .getBean("customerDaoProxy");\n        customerDao.add();\n        customerDao.update();\n        customerDao.delete();\n        customerDao.find();\n    }\n}\n5. 运行项目并查看结果\n使用 JUnit 测试运行 test() 方法，运行成功\n\n')])])])])}),[],!1,null,null,null);e.default=o.exports}}]);