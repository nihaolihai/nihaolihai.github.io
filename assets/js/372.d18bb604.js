(window.webpackJsonp=window.webpackJsonp||[]).push([[372],{865:function(e,n,t){"use strict";t.r(n);var r=t(6),s=Object(r.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"feign调用前统一申请token传递到调用的服务中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#feign调用前统一申请token传递到调用的服务中"}},[this._v("#")]),this._v(" Feign调用前统一申请Token传递到调用的服务中")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('1. 定义请求拦截器\n对于 Token 的传递操作，最好在框架层面进行封装，对使用者透明，这样不影响业务代码，但要求通用性一定要强。我们可以定义一个 Feign 的请求拦截器来统一添加请求头信息，代码如下所示。\n/**\n* Feign 请求拦截器\n**/\npublic class FeignBasicAuthRequestInterceptor implements RequestInterceptor {\n    public FeignBasicAuthRequestInterceptor() {\n    }\n    @Override\n    public void apply(RequestTemplate template) {\n        template.header("Authorization", System.getProperty("fangjia.auth.token"));\n    }\n}\n2. 配置拦截器\n拦截器需要在 Feign 的配置中定义，代码如下所示。\n@Configuration\npublic class FeignConfiguration {\n    /**\n     * 日志级别\n     *\n     * @return\n     */\n    @Bean\n    Logger.Level feignLoggerLevel() {\n        return Logger.Level.FULL;\n    }\n    /**\n     * 创建 Feign 请求拦截器, 在发送请求前设置认证的 Token, 各个微服务将 Token 设置 到环境变量中来达到通用的目的\n     *\n     * @return\n     */\n    @Bean\n    public FeignBasicAuthRequestInterceptor basicAuthRequestInterceptor() {\n        return new FeignBasicAuthRequestInterceptor();\n    }\n}\n上面的准备好之后，我们只需要在调用业务接口之前先调用认证接口，然后将获取到的 Token 设置到环境变量中，通过 System.setProperty("fangjia.auth.token",token) 设置值，或者通过定时任务刷新设置。\n\n这样我们就可以通过 System.setProperty("fangjia.auth.token",token) 获取到需要传递的 Token。\n\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);