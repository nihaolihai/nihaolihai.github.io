(window.webpackJsonp=window.webpackJsonp||[]).push([[329],{818:function(n,e,t){"use strict";t.r(e);var i=t(6),l=Object(i.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-cloud使用feign调用服务接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud使用feign调用服务接口"}},[this._v("#")]),this._v(" Spring Cloud使用Feign调用服务接口")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('JAVA 项目中接口调用怎么做？\n1）Httpclient\nHttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 Http 协议的客户端编程工具包，并且它支持 HTTP 协议最新版本和建议。\n\nHttpClient 相比传统 JDK 自带的 URLConnection，提升了易用性和灵活性，使客户端发送 HTTP 请求变得容易，提高了开发的效率。\n2）Okhttp\n一个处理网络请求的开源项目，是安卓端最火的轻量级框架，由 Square 公司贡献，用于替代 HttpUrlConnection 和 Apache HttpClient。OkHttp 拥有简洁的 API、高效的性能，并支持多种协议（HTTP/2 和 SPDY）。\n3）HttpURLConnection\nHttpURLConnection 是 Java 的标准类，它继承自 URLConnection，可用于向指定网站发送 GET 请求、POST 请求。HttpURLConnection 使用比较复杂，不像 HttpClient 那样容易使用。\n4）RestTemplate\nRestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 HTTP 服务的方法，能够大大提高客户端的编写效率。\n\n上面介绍的是最常见的几种调用接口的方法，我们下面要介绍的方法比上面的更简单、方便，它就是 Feign。\n\nFeign 是一个声明式的 REST 客户端，它能让 REST 调用更加简单。Feign 供了 HTTP 请求的模板，通过编写简单的接口和插入注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。\n\n而 Feign 则会完全代理 HTTP 请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。\n\nSpring Cloud 对 Feign 进行了封装，使其支持 SpringMVC 标准注解和 HttpMessageConverters。Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。\n在Spring Cloud中集成Feign\n在 Spring Cloud 中集成 Feign 的步骤相当简单，首先还是加入 Feign 的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n\n在启动类上加 @EnableFeignClients 注解，如果你的 Feign 接口定义跟你的启动类不在同一个包名下，还需要制定扫描的包名 @EnableFeignClients（basePackages=“com.fangjia.api.client”），代码如下所示。\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients(basePackages = "com.fangjia.api.client")\npublic class FshSubstitutionServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(FshSubstitutionServiceApplication.class, args);\n    }\n}\n使用Feign调用接口\n定义一个 Feign 的客户端，以接口形式存在，代码如下所示。\n@FeignClient(value = "eureka-client-user-service")\npublic interface UserRemoteClient {\n    @GetMapping("/user/hello")\n    String hello();\n}\n首先我们来看接口上加的 @FeignClient 注解。这个注解标识当前是一个 Feign 的客户端，value 属性是对应的服务名称，也就是你需要调用哪个服务中的接口。\n\n定义方法时直接复制接口的定义即可，当然还有另一种做法，就是将接口单独抽出来定义，然后在 Controller 中实现接口。\n\n在调用的客户端中也实现了接口，从而达到接口共用的目的。我这里的做法是不共用的，即单独创建一个 API Client 的公共项目，基于约定的模式，每写一个接口就要对应写一个调用的 Client，后面打成公共的 jar，这样无论是哪个项目需要调用接口，只要引入公共的接口 SDK jar 即可，不用重新定义一遍了。\n\n定义之后可以直接通过注入 UserRemoteClient 来调用，这对于开发人员来说就像调用本地方法一样。\n\n接下来采用 Feign 来调用 /user/hello 接口，代码如下所示。\n@Autowired\nprivate UserRemoteClient userRemoteClient;\n@GetMapping("/callHello")\npublic String callHello() {\n    //return restTemplate.getForObject("http://localhost:8083/house/hello",String.class);\n    //String result = restTemplate.getForObject("http://eureka-client-user-service/user/hello",String.class);\n    String result = userRemoteClient.hello();\n    System.out.println("调用结果：" + result);\n    return result;\n}\n通过跟注释掉的代码相比可以发现，我们的调用方式变得越来越简单了，从最开始的指定地址，到后面通过 Eureka 中的服务名称来调用，再到现在直接通过定义接口来调用。\n\n\n')])])])])}),[],!1,null,null,null);e.default=l.exports}}]);