(window.webpackJsonp=window.webpackJsonp||[]).push([[445],{934:function(n,e,r){"use strict";r.r(e);var t=r(6),o=Object(t.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"spring-mvc中-controller和-requestmapping注解详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc中-controller和-requestmapping注解详解"}},[this._v("#")]),this._v(" Spring MVC中@Controller和@RequestMapping注解详解")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('在《第一个Spring MVC应用》教程中创建了两个传统风格的控制器，它们是实现 Controller 接口的类。传统风格的控制器不仅需要在配置文件中部署映射，而且只能编写一个处理方法，不够灵活。使用基于注解的控制器具有以下两个优点：\n在基于注解的控制器类中可以编写多个处理方法，进而可以处理多个请求（动作），这就允许将相关的操作编写在同一个控制器类中，从而减少控制器类的数量，方便以后的维护。\n基于注解的控制器不需要在配置文件中部署映射，仅需要使用 RequestMapping 注释类型注解一个方法进行请求处理。\n\n在 Spring MVC 中最重要的两个注解类型是 Controller 和 RequestMapping，本节将重点介绍它们。在本节将创建一个 Spring MVC 应用 springMVCDemo02 来演示相关知识，springMVCDemo01 的 JAR 包、web.xml 与 springMVCDemo02 应用的 JAR 包、web.xml 完全一样。\nController 注解类型\n在 Spring MVC 中使用 org.springframework.stereotype.Controller 注解类型声明某类的实例是一个控制器。例如，在 springMVCDemo02 应用的 src 目录下创建 controller 包，并在该包中创建 Controller 注解的控制器类 IndexController，示例代码如下：\npackage controller;\nimport org.springframework.stereotype.Controller;\n/**\n* “@Controller”表示 IndexController 的实例是一个控制器\n*\n* @Controller相当于@Controller(@Controller) 或@Controller(value="@Controller")\n*/\n@Controller\npublic class IndexController {\n    // 处理请求的方法\n}\n在 Spring MVC 中使用扫描机制找到应用中所有基于注解的控制器类，所以，为了让控制器类被 Spring MVC 框架扫描到，需要在配置文件中声明 spring-context，并使用 <context：component-scan/> 元素指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）。\n\n例如，在 springMVCDemo02 应用的 /WEB-INF/ 目录下创建配置文件 springmvc-servlet.xml，示例代码如下：\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n    xmlns:mvc="http://www.springframework.org/schema/mvc"\n    xmlns:p="http://www.springframework.org/schema/p" \n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd">\n    \x3c!-- 使用扫描机制扫描控制器类，控制器类都在controller包及其子包下 --\x3e\n    <context:component-scan base-package="controller" />\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        <property name="prefix" value="/WEB-INF/jsp/" />\n        <property name="suffix" value=".jsp" />\n    </bean>\n</beans>\nRequestMapping 注解类型\n在基于注解的控制器类中可以为每个请求编写对应的处理方法。那么如何将请求与处理方法一一对应呢？\n\n需要使用 org.springframework.web.bind.annotation.RequestMapping 注解类型将请求与处理方法一一对应。\n1）方法级别注解\n方法级别注解的示例代码如下：\npackage controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n/**\n* “@Controller”表示 IndexController 的实例是一个控制器\n*\n* @Controller相当于@Controller(@Controller) 或@Controller(value="@Controller")\n*/\n@Controller\npublic class IndexController {\n    @RequestMapping(value = "/index/login")\n    public String login() {\n        /**\n         * login代表逻辑视图名称，需要根据Spring MVC配置\n         * 文件中internalResourceViewResolver的前缀和后缀找到对应的物理视图\n         */\n        return "login";\n    }\n    @RequestMapping(value = "/index/register")\n    public String register() {\n        return "register";\n    }\n}\n上述示例中有两个 RequestMapping 注解语句，它们都作用在处理方法上。注解的 value 属性将请求 URI 映射到方法，value 属性是 RequestMapping 注解的默认属性，如果只有一个 value 属性，则可以省略该属性。\n\n用户可以使用如下 URL 访问 login 方法（请求处理方法），在访问 login 方法之前需要事先在 /WEB-INF/jsp/ 目录下创建 login.jsp。\nhttp://localhost:8080/springMVCDemo02/index/login\n\n2）类级别注解\n类级别注解的示例代码如下：\npackage controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\n@RequestMapping("/index")\npublic class IndexController {\n    @RequestMapping("/login")\n    public String login() {\n        return "login";\n    }\n    @RequestMapping("/register")\n    public String register() {\n        return "register";\n    }\n}\n在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。用户可以使用如下 URL 访问 login 方法。\nhttp://localhost:8080/springMVCDemo02/index/login\n\n为了方便维护程序，建议开发者采用类级别注解，将相关处理放在同一个控制器类中。例如，对商品的增、删、改、查处理方法都可以放在 GoodsOperate 控制类中。\n编写请求处理方法\n在控制类中每个请求处理方法可以有多个不同类型的参数，以及一个多种类型的返回结果。\n1）请求处理方法中常出现的参数类型\n如果需要在请求处理方法中使用 Servlet API 类型，那么可以将这些类型作为请求处理方法的参数类型。Servlet API 参数类型的示例代码如下：\npackage controller;\nimport javax.servlet.http.HttpSession;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\n@RequestMapping("/index")\npublic class IndexController {\n    @RequestMapping("/login")\n    public String login(HttpSession session,HttpServletRequest request) {\n        session.setAttribute("skey", "session范围的值");\n        session.setAttribute("rkey", "request范围的值");\n        return "login";\n    }\n}\n除了 Servlet API 参数类型以外，还有输入输出流、表单实体类、注解类型、与 Spring 框架相关的类型等，这些类型在后续章节中使用时再详细介绍。\n\n其中特别重要的类型是 org.springframework.ui.Model 类型，该类型是一个包含 Map 的 Spring 框架类型。在每次调用请求处理方法时 Spring MVC 都将创建 org.springframework.ui.Model 对象。Model 参数类型的示例代码如下：\npackage controller;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n@Controller\n@RequestMapping("/index")\npublic class IndexController {\n    @RequestMapping("/register")\n    public String register(Model model) {\n        /*在视图中可以使用EL表达式${success}取出model中的值*/\n        model.addAttribute("success", "注册成功");\n        return "register";\n    }\n}\n2）请求处理方法常见的返回类型\n最常见的返回类型就是代表逻辑视图名称的 String 类型，例如前面教程中的请求处理方法。除了 String 类型以外，还有 ModelAndView、Model、View 以及其他任意的 Java 类型。\n\n')])])])])}),[],!1,null,null,null);e.default=o.exports}}]);