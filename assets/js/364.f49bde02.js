(window.webpackJsonp=window.webpackJsonp||[]).push([[364],{853:function(e,r,t){"use strict";t.r(r);var l=t(6),n=Object(l.a)({},(function(){var e=this.$createElement,r=this._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[r("h2",{attrs:{id:"spring-cloud使用sleuth在应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud使用sleuth在应用"}},[this._v("#")]),this._v(" Spring Cloud使用Sleuth在应用")]),this._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v('Sleuth Maven 配置代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n\n集成完成之后，我们就可以看效果了，前提是需要有两个以上的服务，比如 A 服务、B 服务，然后 A 服务中调用 B 服务提供的接口，分别在 A 和 B 服务的接口中输出日志。\n\n首先建两个简单的服务，分别为 sleuth-article-service 和 sleuth-user-service。\n\nsleuth-article-service 中的 ArticleController 调用 sleuth-user-service 提供的接口，具体代码如下。\n@RestController\npublic class ArticleController {\n    private Logger logger = LoggerFactory.getLogger(ArticleController.class);\n    @Autowired\n    private RestTemplate restTemplate;\n    @Autowired\n    private ArticleService articleService;\n    @Autowired\n    Tracer tracer;\n    @GetMapping("/article/callHello")\n    public String callHello() {\n        logger.info("我是/article/callHello");\n        tracer.currentSpan().tag("用户", "zhangsan");\n        return restTemplate.getForObject("http://sleuth-user-service/user/hello", String.class);\n    }\n}\nsleuth-user-service 中的 UserController 调用 sleuth-article-service 提供的接口，具体代码如下所示。\n@RestController\npublic class UserController {\n    private Logger logger = LoggerFactory.getLogger(UserController.class);\n    @GetMapping("/user/hello")\n    public String hello() {\n        logger.info("我是/user/hello");\n        try {\n            Thread.sleep(4000);\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return "hello";\n    }\n}\n然后我们访问 sleuth-article-service 服务的接口，查看输出的日志信息，具体如下：\n2019-08-28 16:16:10.187  INFO [sleuth-article-service,81bc3db3c143f1fb,81bc3db3c143f1fb,false] 6355 --- [nio-8082-exec-1] c.c.e.controller.ArticleController: 我是/article/callHello\n\n查看 sleuth-user-service 输出的日志信息，具体如下：\n2019-08-28 16:16:10.570  INFO [sleuth-user-service,81bc3db3c143f1fb,c0cf0d53ce2a8047,false] 6356 --- [nio-8083-exec-1]c.c.e.controller.UserController: 我是/user/hello\n\n在方法中记录日志，我们会发现在日志的最前面加了一部分内容，这部分内容就是 Sleuth 为服务直接提供的链路信息。\n\n可以看到内容是由 [appname，traceId，spanId，exportable] 组成的，具体含义如下：\nappname：服务的名称，也就是 spring.application.name 的值。\ntraceId：整个请求的唯一 ID，它标识整个请求的链路。\nspanId：基本的工作单元，发起一次远程调用就是一个 span。\nexportable：决定是否导入数据到 Zipkin 中。\n\n')])])])])}),[],!1,null,null,null);r.default=n.exports}}]);