(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{623:function(e,n,t){"use strict";t.r(n);var i=t(6),r=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"java-流-stream-、文件-file-和io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-流-stream-、文件-file-和io"}},[e._v("#")]),e._v(" Java 流(Stream)、文件(File)和IO")]),e._v(" "),t("p",[e._v("Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。")]),e._v(" "),t("p",[e._v("Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。")]),e._v(" "),t("p",[e._v("一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。")]),e._v(" "),t("p",[e._v("Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。")]),e._v(" "),t("p",[e._v("但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。")]),e._v(" "),t("p",[e._v("读取控制台输入\nJava 的控制台输入由 System.in 完成。")]),e._v(" "),t("p",[e._v("为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。")]),e._v(" "),t("p",[e._v("下面是创建 BufferedReader 的基本语法：")]),e._v(" "),t("p",[e._v("BufferedReader br = new BufferedReader(new\nInputStreamReader(System.in));\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。")]),e._v(" "),t("p",[e._v("从控制台读取多字符输入\n从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：")]),e._v(" "),t("p",[e._v("int read( ) throws IOException\n每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。")]),e._v(" "),t("p",[e._v('下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 "q"。')]),e._v(" "),t("p",[e._v("BRRead.java 文件代码：\n//使用 BufferedReader 在控制台读取字符")]),e._v(" "),t("p",[e._v("import java.io.*;")]),e._v(" "),t("p",[e._v("public class BRRead {\npublic static void main(String args[]) throws IOException {\nchar c;\n// 使用 System.in 创建 BufferedReader\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nSystem.out.println(\"输入字符, 按下 'q' 键退出。\");\n// 读取字符\ndo {\nc = (char) br.read();\nSystem.out.println(c);\n} while (c != 'q');\n}\n}\n以上实例编译运行结果如下:")]),e._v(" "),t("p",[e._v("输入字符, 按下 'q' 键退出。\nrunoob\nr\nu\nn\no\no\nb")]),e._v(" "),t("p",[e._v("q\nq\n从控制台读取字符串\n从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。")]),e._v(" "),t("p",[e._v("它的一般格式是：")]),e._v(" "),t("p",[e._v('String readLine( ) throws IOException\n下面的程序读取和显示字符行直到你输入了单词"end"。')]),e._v(" "),t("p",[e._v("BRReadLines.java 文件代码：\n//使用 BufferedReader 在控制台读取字符\nimport java.io.*;")]),e._v(" "),t("p",[e._v('public class BRReadLines {\npublic static void main(String args[]) throws IOException {\n// 使用 System.in 创建 BufferedReader\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nString str;\nSystem.out.println("Enter lines of text.");\nSystem.out.println("Enter \'end\' to quit.");\ndo {\nstr = br.readLine();\nSystem.out.println(str);\n} while (!str.equals("end"));\n}\n}\n以上实例编译运行结果如下:')]),e._v(" "),t("p",[e._v("Enter lines of text.\nEnter 'end' to quit.\nThis is line one\nThis is line one\nThis is line two\nThis is line two\nend\nend\nJDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。")]),e._v(" "),t("p",[e._v("控制台输出\n在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。")]),e._v(" "),t("p",[e._v("PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。")]),e._v(" "),t("p",[e._v("PrintStream 定义 write() 的最简单格式如下所示：")]),e._v(" "),t("p",[e._v("void write(int byteval)\n该方法将 byteval 的低八位字节写到流中。")]),e._v(" "),t("p",[e._v('实例\n下面的例子用 write() 把字符 "A" 和紧跟着的换行符输出到屏幕：')]),e._v(" "),t("p",[e._v("WriteDemo.java 文件代码：\nimport java.io.*;")]),e._v(" "),t("p",[e._v("//演示 System.out.write().\npublic class WriteDemo {\npublic static void main(String args[]) {\nint b;\nb = 'A';\nSystem.out.write(b);\nSystem.out.write('\\n');\n}\n}\n运行以上实例在输出窗口输出 \"A\" 字符")]),e._v(" "),t("p",[e._v("A\n注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。")]),e._v(" "),t("p",[e._v("读写文件\n如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。")]),e._v(" "),t("p",[e._v("下图是一个描述输入流和输出流的类层次图。")]),e._v(" "),t("p",[e._v("下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream：")]),e._v(" "),t("p",[e._v("FileInputStream\n该流用于从文件读取数据，它的对象可以用关键字 new 来创建。")]),e._v(" "),t("p",[e._v("有多种构造方法可用来创建对象。")]),e._v(" "),t("p",[e._v("可以使用字符串类型的文件名来创建一个输入流对象来读取文件：")]),e._v(" "),t("p",[e._v('InputStream f = new FileInputStream("C:/java/hello");\n也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：')]),e._v(" "),t("p",[e._v('File f = new File("C:/java/hello");\nInputStream out = new FileInputStream(f);\n创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。')]),e._v(" "),t("p",[e._v("序号\t方法及描述\n1\tpublic void close() throws IOException{}\n关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。\n2\tprotected void finalize()throws IOException {}\n这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。\n3\tpublic int read(int r)throws IOException{}\n这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。\n4\tpublic int read(byte[] r) throws IOException{}\n这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。\n5\tpublic int available() throws IOException{}\n返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。\n除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接：")]),e._v(" "),t("p",[e._v("ByteArrayInputStream\nDataInputStream\nFileOutputStream\n该类用来创建一个文件并向文件中写数据。")]),e._v(" "),t("p",[e._v("如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。")]),e._v(" "),t("p",[e._v("有两个构造方法可以用来创建 FileOutputStream 对象。")]),e._v(" "),t("p",[e._v("使用字符串类型的文件名来创建一个输出流对象：")]),e._v(" "),t("p",[e._v('OutputStream f = new FileOutputStream("C:/java/hello")\n也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：')]),e._v(" "),t("p",[e._v('File f = new File("C:/java/hello");\nOutputStream f = new FileOutputStream(f);\n创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。')]),e._v(" "),t("p",[e._v("序号\t方法及描述\n1\tpublic void close() throws IOException{}\n关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。\n2\tprotected void finalize()throws IOException {}\n这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。\n3\tpublic void write(int w)throws IOException{}\n这个方法把指定的字节写到输出流中。\n4\tpublic void write(byte[] w)\n把指定数组中w.length长度的字节写到OutputStream中。\n除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接：")]),e._v(" "),t("p",[e._v("ByteArrayOutputStream\nDataOutputStream\n实例\n下面是一个演示 InputStream 和 OutputStream 用法的例子：")]),e._v(" "),t("p",[e._v("fileStreamTest.java 文件代码：\nimport java.io.*;")]),e._v(" "),t("p",[e._v('public class fileStreamTest {\npublic static void main(String args[]) {\ntry {\nbyte bWrite[] = { 11, 21, 3, 40, 5 };\nOutputStream os = new FileOutputStream("test.txt");\nfor (int x = 0; x < bWrite.length; x++) {\nos.write(bWrite[x]); // writes the bytes\n}\nos.close();')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('        InputStream is = new FileInputStream("test.txt");\n        int size = is.available();\n\n        for (int i = 0; i < size; i++) {\n            System.out.print((char) is.read() + "  ");\n        }\n        is.close();\n    } catch (IOException e) {\n        System.out.print("Exception");\n    }\n}\n')])])]),t("p",[e._v("}\n上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。")]),e._v(" "),t("p",[e._v("以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：")]),e._v(" "),t("p",[e._v("fileStreamTest2.java 文件代码：\n//文件名 :fileStreamTest2.java\nimport java.io.*;")]),e._v(" "),t("p",[e._v("public class fileStreamTest2 {\npublic static void main(String[] args) throws IOException {")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('    File f = new File("a.txt");\n    FileOutputStream fop = new FileOutputStream(f);\n    // 构建FileOutputStream对象,文件不存在会自动新建\n\n    OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8");\n    // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk\n\n    writer.append("中文输入");\n    // 写入到缓冲区\n\n    writer.append("\\r\\n");\n    // 换行\n\n    writer.append("English");\n    // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入\n\n    writer.close();\n    // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉\n\n    fop.close();\n    // 关闭输出流,释放系统资源\n\n    FileInputStream fip = new FileInputStream(f);\n    // 构建FileInputStream对象\n\n    InputStreamReader reader = new InputStreamReader(fip, "UTF-8");\n    // 构建InputStreamReader对象,编码与写入相同\n\n    StringBuffer sb = new StringBuffer();\n    while (reader.ready()) {\n        sb.append((char) reader.read());\n        // 转成char加到StringBuffer对象中\n    }\n    System.out.println(sb.toString());\n    reader.close();\n    // 关闭读取流\n\n    fip.close();\n    // 关闭输入流,释放系统资源\n\n}\n')])])]),t("p",[e._v("}\n文件和I/O\n还有一些关于文件和I/O的类，我们也需要知道：")]),e._v(" "),t("p",[e._v("File Class(类)\nFileReader Class(类)\nFileWriter Class(类)\nJava中的目录\n创建目录：\nFile类中有两个方法可以用来创建文件夹：")]),e._v(" "),t("p",[e._v('mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\nmkdirs()方法创建一个文件夹和它的所有父文件夹。\n下面的例子创建 "/tmp/user/java/bin"文件夹：')]),e._v(" "),t("p",[e._v("CreateDir.java 文件代码：\nimport java.io.File;")]),e._v(" "),t("p",[e._v('public class CreateDir {\npublic static void main(String args[]) {\nString dirname = "/tmp/user/java/bin";\nFile d = new File(dirname);\n// 现在创建目录\nd.mkdirs();\n}\n}\n编译并执行上面代码来创建目录 "/tmp/user/java/bin"。')]),e._v(" "),t("p",[e._v("注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。")]),e._v(" "),t("p",[e._v("读取目录\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。")]),e._v(" "),t("p",[e._v("如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。")]),e._v(" "),t("p",[e._v("可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。")]),e._v(" "),t("p",[e._v("下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：")]),e._v(" "),t("p",[e._v("DirList.java 文件代码：\nimport java.io.File;")]),e._v(" "),t("p",[e._v('public class DirList {\npublic static void main(String args[]) {\nString dirname = "/tmp";\nFile f1 = new File(dirname);\nif (f1.isDirectory()) {\nSystem.out.println("目录 " + dirname);\nString s[] = f1.list();\nfor (int i = 0; i < s.length; i++) {\nFile f = new File(dirname + "/" + s[i]);\nif (f.isDirectory()) {\nSystem.out.println(s[i] + " 是一个目录");\n} else {\nSystem.out.println(s[i] + " 是一个文件");\n}\n}\n} else {\nSystem.out.println(dirname + " 不是一个目录");\n}\n}\n}\n以上实例编译运行结果如下：')]),e._v(" "),t("p",[e._v("目录 /tmp\nbin 是一个目录\nlib 是一个目录\ndemo 是一个目录\ntest.txt 是一个文件\nREADME 是一个文件\nindex.html 是一个文件\ninclude 是一个目录\n删除目录或文件\n删除文件可以使用 java.io.File.delete() 方法。")]),e._v(" "),t("p",[e._v("以下代码会删除目录 /tmp/java/，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。")]),e._v(" "),t("p",[e._v("测试目录结构：")]),e._v(" "),t("p",[e._v("/tmp/java/\n|-- 1.log\n|-- test\nDeleteFileDemo.java 文件代码：\nimport java.io.File;")]),e._v(" "),t("p",[e._v('public class DeleteFileDemo {\npublic static void main(String args[]) {\n// 这里修改为自己的测试目录\nFile folder = new File("/tmp/java/");\ndeleteFolder(folder);\n}')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 删除文件及目录\npublic static void deleteFolder(File folder) {\n    File[] files = folder.listFiles();\n    if (files != null) {\n        for (File f : files) {\n            if (f.isDirectory()) {\n                deleteFolder(f);\n            } else {\n                f.delete();\n            }\n        }\n    }\n    folder.delete();\n}\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v('public static void main(String[] args) {\nString paramsCodes = "{"Url":"127.0.0.1","UrlName":"test"}";\nJSONObject jsonObj = JSONObject.parseObject(paramsCodes);\nSystem.out.println("解析对象："+jsonObj+",解析字符串："+jsonObj.get("Url").toString());\nString pathfile = "D:\\整理账册错误日志\\ems-api_log_error.log";\n//gbk   utf-8\n//scanRead(pathfile,"utf-8");\nFile file = new File("D:\\整理账册错误日志");\nFile[] files = file.listFiles();\nfor (int i = 0; i < files.length; i++) {\nFile file1 = files[i];\nif(file1.isFile()){\nif(file1.getName().contains("api")){\nreadDataToFileApi(file1.getPath(),"utf-8");\n}else if(file1.getName().contains("import")){\nreadDataToFileExecutor(file1.getPath(),"utf-8");\n}else if(file1.getName().contains("msg-rc")){\nreadDataToFileMsgRc(file1.getPath(),"utf-8");\n}else if(file1.getName().contains("msg-res")){\nreadDataToFileMsgRes(file1.getPath(),"utf-8");\n}else if(file1.getName().contains("public-service")){\nreadDataToFilePublicSer(file1.getPath(),"utf-8");\n}else{\nSystem.out.println(file1.getName());\n}\n}\n}\n}')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('/**\n * 读取文件中的数据\n * @throws IOException\n */\nprotected static void scanRead(String pathfile,String charsetName){\n    try(Scanner scanner = new Scanner(new File(pathfile),charsetName)) {\n        while (scanner.hasNextLine()) {\n            String currentLine = scanner.nextLine();\n            if(!currentLine.contains("未携带登录信息")) {\n                System.out.println(currentLine);\n            }\n        }\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n\n/**\n * 读取文件中的数据\n * @throws IOException\n */\npublic static void readDataToFileApi(String filePath,String charsetName){\n    try {\n        File file=new File(filePath);\n        if(file.isFile() && file.exists()){ //判断文件是否存在\n            InputStreamReader read = new InputStreamReader(\n                    new FileInputStream(file),charsetName);//考虑到编码格式\n            BufferedReader bufferedReader = new BufferedReader(read);\n            String lineTxt = null;\n            StringBuilder sb = new StringBuilder();\n            while((lineTxt = bufferedReader.readLine()) != null){\n                if(lineTxt.contains("2021-01-18")){\n                    lineTxt = lineTxt.replace(lineTxt,"sppace");\n                }\n                sb.append(lineTxt+"\\n");\n            }\n            read.close();\n            String string = sb.toString();\n            String[] split = string.split("sppace");\n            for (int i = 0; i < split.length; i++) {\n                if(!split[i].contains("未携带登录信息")){\n                    System.out.println(split[i]);\n                }\n            }\n        }else{\n            System.out.println("找不到指定的文件");\n        }\n    } catch (Exception e) {\n        System.out.println("读取文件内容出错");\n        e.printStackTrace();\n    }\n}\n\n/**\n * 读取文件中的数据\n * @throws IOException\n */\npublic static void readDataToFileExecutor(String filePath,String charsetName){\n    try {\n        File file=new File(filePath);\n        if(file.isFile() && file.exists()){ //判断文件是否存在\n            InputStreamReader read = new InputStreamReader(\n                    new FileInputStream(file),charsetName);//考虑到编码格式\n            BufferedReader bufferedReader = new BufferedReader(read);\n            String lineTxt = null;\n            StringBuilder sb = new StringBuilder();\n            while((lineTxt = bufferedReader.readLine()) != null){\n                if(lineTxt.contains("2021-01-18")){\n                    lineTxt = lineTxt.replace(lineTxt,"sppace");\n                }\n               sb.append(lineTxt+"\\n");\n            }\n            read.close();\n            String string = sb.toString();\n            String[] split = string.split("sppace");\n            for (int i = 0; i < split.length; i++) {\n                if(!(split[i].contains("java.net.SocketTimeoutException: Read timed out")\n                 || split[i].contains("io.sentry.connection.ConnectionException"))){\n                    System.out.println(split[i]);\n                }\n            }\n        }else{\n            System.out.println("找不到指定的文件");\n        }\n    } catch (Exception e) {\n        System.out.println("读取文件内容出错");\n        e.printStackTrace();\n    }\n}\n\n/**\n * 读取文件中的数据\n * @throws IOException\n */\npublic static void readDataToFileMsgRc(String filePath,String charsetName){\n    try {\n        File file=new File(filePath);\n        if(file.isFile() && file.exists()){ //判断文件是否存在\n            InputStreamReader read = new InputStreamReader(\n                    new FileInputStream(file),charsetName);//考虑到编码格式\n            BufferedReader bufferedReader = new BufferedReader(read);\n            String lineTxt = null;\n            StringBuilder sb = new StringBuilder();\n            while((lineTxt = bufferedReader.readLine()) != null){\n                if(lineTxt.contains("2021-01-18")){\n                    lineTxt = lineTxt.replace(lineTxt,"sppace");\n                }\n                sb.append(lineTxt+"\\n");\n            }\n            read.close();\n            String string = sb.toString();\n            String[] split = string.split("sppace");\n            for (int i = 0; i < split.length; i++) {\n                if(!split[i].contains("java.net.SocketTimeoutException: Read timed out")){\n                    System.out.println(split[i]);\n                }\n            }\n        }else{\n            System.out.println("找不到指定的文件");\n        }\n    } catch (Exception e) {\n        System.out.println("读取文件内容出错");\n        e.printStackTrace();\n    }\n}\n\n/**\n * 读取文件中的数据\n * @throws IOException\n */\npublic static void readDataToFileMsgRes(String filePath,String charsetName){\n    try {\n        File file=new File(filePath);\n        if(file.isFile() && file.exists()){ //判断文件是否存在\n            InputStreamReader read = new InputStreamReader(\n                    new FileInputStream(file),charsetName);//考虑到编码格式\n            BufferedReader bufferedReader = new BufferedReader(read);\n            String lineTxt = null;\n            StringBuilder sb = new StringBuilder();\n            while((lineTxt = bufferedReader.readLine()) != null){\n                if(lineTxt.contains("2021-01-18")){\n                    lineTxt = lineTxt.replace(lineTxt,"sppace");\n                }\n                sb.append(lineTxt+"\\n");\n            }\n            read.close();\n            String string = sb.toString();\n            String[] split = string.split("sppace");\n            for (int i = 0; i < split.length; i++) {\n')])])]),t("p",[e._v('//                    if(!split[i].contains("java.net.SocketTimeoutException: Read timed out")){\n//                        System.out.println(split[i]);\n//                    }\nSystem.out.println(split[i]);\n}\n}else{\nSystem.out.println("找不到指定的文件");\n}\n} catch (Exception e) {\nSystem.out.println("读取文件内容出错");\ne.printStackTrace();\n}\n}')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('/**\n * 读取文件中的数据\n * @throws IOException\n */\npublic static void readDataToFilePublicSer(String filePath,String charsetName){\n    try {\n        File file=new File(filePath);\n        if(file.isFile() && file.exists()){ //判断文件是否存在\n            InputStreamReader read = new InputStreamReader(\n                    new FileInputStream(file),charsetName);//考虑到编码格式\n            BufferedReader bufferedReader = new BufferedReader(read);\n            String lineTxt = null;\n            StringBuilder sb = new StringBuilder();\n            while((lineTxt = bufferedReader.readLine()) != null){\n                if(lineTxt.contains("2021-01-05")){\n                    lineTxt = lineTxt.replace(lineTxt,"sppace");\n                }\n                sb.append(lineTxt+"\\n");\n            }\n            read.close();\n            String string = sb.toString();\n            String[] split = string.split("sppace");\n            for (int i = 0; i < split.length; i++) {\n                if(!split[i].contains("org.apache.kafka.clients.consumer.CommitFailedException")){\n                    System.out.println(split[i]);\n                }\n            }\n        }else{\n            System.out.println("找不到指定的文件");\n        }\n    } catch (Exception e) {\n        System.out.println("读取文件内容出错");\n        e.printStackTrace();\n    }\n}\n\n/**\n * 将格式化的数据写入文件中\n * @throws IOException\n */\npublic static void writeDataToFile(String filePath,String charsetName) throws IOException {\n    BufferedWriter bw = null;\n    try {\n        File file = new File(filePath);\n        bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charsetName));\n        for (int i=1; i<12; ++i) {\n            bw.write(i);  // 将数据写入文件中\n            bw.newLine();        // 新建一个换行符\n            bw.flush();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (null != bw) {\n            bw.close();\n        }\n    }\n}\n\n/**\n * 功能描述:获取用户ip\n *@param request http请求\n *\n */\npublic String getIpAddr(HttpServletRequest request) {\n    String host = request.getHeader("host") + request.getRequestURI();\n    System.out.println(host);\n    String ip = request.getHeader("X-Forwarded-For");\n    if (ip != null && ip.length() != 0 && !"unknown".equalsIgnoreCase(ip)) {\n        // 多次反向代理后会有多个ip值，第一个ip才是真实ip\n        if( ip.indexOf(",")!=-1 ){\n            ip = ip.split(",")[0];\n        }\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getHeader("Proxy-Client-IP");\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getHeader("WL-Proxy-Client-IP");\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getHeader("HTTP_CLIENT_IP");\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getHeader("HTTP_X_FORWARDED_FOR");\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getHeader("X-Real-IP");\n    }\n    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {\n        ip = request.getRemoteAddr();\n    }\n    System.out.println("获取客户端ip: " + ip);\n    return ip;\n}')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);