(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{553:function(n,e,i){"use strict";i.r(e);var s=i(6),l=Object(s.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h1",{attrs:{id:"条例3-使用私有构造函数或枚举类型强制单例属性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#条例3-使用私有构造函数或枚举类型强制单例属性。"}},[this._v("#")]),this._v(" 条例3： 使用私有构造函数或枚举类型强制单例属性。")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("单例简单来说就是只会被实例化一次的类。单例通常表示无状态的对象比如函数或者本质上是唯一的系统组件。将类变成单例\n会导致很难测试调用它的代码，因为不可能用模拟的实现来代替单例，除非它实现了作为其类型的接口。\n\n有两种常用方式来实现单例。两者都基于私有构造函数，导出一个公共的静态成员以提供对单实例的访问。一种方式中，成员是\nfinal字段：\n\n//带有公共不可修改字段的单例\npublic class Elvis {\n    public static final Elvis INSTANCE = new Elvis();\n    private Elvis() {}\n    public void leaveTheBuilding(){}\n}\n私有构造函数只会调用一次，用来实例化公共静态不可修改字段`Elvis.INSTANCE`。不提供public或protected构造函数确保了\n全局唯一：一旦Elvis类实例化后仅有一个Elvis实例存在——不多也不少。调用方无论如何不能改变这一点。需要注意的是：一个\n特权客户可以通过`AccessibleObject.setAccessible`方法以反射的形式调用私有构造函数。如果你需要防御这种反射攻击，\n修改构造函数在被请求创建第二个实例时扔出异常。\n\n第二种实现单例的方式，公共成员是一个静态工厂方法。\n//静态工厂单实例\npublic class Elvis {\n    private static final Elvis INSTANCE = new Elvis();\n    private Elvis() {}\n    public static Elvis getInstance() {\n        return INSTANCE;\n    }\n    public void leaveTheBuilding() {}\n}\n所有对`Elvis.getInstance`的调用返回相同的对象引用，没有其他的Elvis实例会再被创建（除了上面提到的反射攻击注意点）\n\n公共字段方式的主要优点是API清楚表示了类是单实例的：公共静态字段是final的，所以它总是包含相同的对象引用。第二个优点是\n它更加简单。\n\n工厂方法的这种方式的一个优点是它赋予了你改变类是否要做成单实例的的想法的弹性，因为不需要更改API即可切换。工厂方法返回\n单个实例，但是它可以被改成返回（比如说）每个调用它的线程一个单独的实例。第二个优点是，如果你的应用有需要，你可以编写泛型的单实例工厂\n使用静态工厂的最后一个优点是方法引用可以作为Supplier。比如`Elvis::instance`是一个Supplier<Elvis>。除非涉及到这些优点中的\n一个，否则优先使用公共字段方式。\n\n要使采用了上面任何一种方式实现的单实例类变为可序列化的，仅仅在类声明上添加`implements Serializable`是不够的。要维持单实例的保证，\n需要声明所有的实例字段`transient`且提供一个`readResolve`方法。否则每次序列化的实例反序列化后，一个新的实例将会被创建。在我们\n的例子中，将会出现假猫王。为防止这类事情发生，在Elvis类中添加readResolve方法。\n\n//readResolve方法用来保留单实例属性\nprivate Object readResolve() {\n  //返回真的那个猫王，让gc负责猫王模范者\n  return INSTANCE;\n}\n\n第三种实现单例的模式是声明一个单个元素的枚举\npublic enum Elvis {\n    INSTANCE;\n\n    public void leaveTheBuilding() {}\n}\n这个方式类似于公共字段方式，但是更简洁。自带序列化机制，提供了绝不会多次实例化的保证，甚至是在面对复杂的序列化\n或反射攻击。这种方式可能感觉起来有点不自然，但单元素的枚举类型通常是实现单实例最佳的方式。注意，如果单例必须继承一个\n超类而不是Enum，那么不能使用这种方式（虽然你可以声明枚举来实现接口）\n\n")])])])])}),[],!1,null,null,null);e.default=l.exports}}]);