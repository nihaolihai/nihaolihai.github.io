(window.webpackJsonp=window.webpackJsonp||[]).push([[353],{841:function(e,r,t){"use strict";t.r(r);var n=t(6),s=Object(n.a)({},(function(){var e=this.$createElement,r=this._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[r("h2",{attrs:{id:"spring-cloud-gateway实战案例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-gateway实战案例"}},[this._v("#")]),this._v(" Spring Cloud Gateway实战案例")]),this._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v('限流实战\n开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。API 网关作为所有请求的入口，请求量大，我们可以通过对并发访问的请求进行限速来保护系统的可用性。\n\n目前限流提供了基于 Redis 的实现，我们需要增加对应的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>\n</dependency>\n\n我们可以通过 KeyResolver 来指定限流的 Key，比如我们需要根据用户来做限流，或是根据 IP 来做限流等。\n1. IP 限流\nIP 限流的 Key 指定具体代码如下所示。\n@Bean\npublic KeyResolver ipKeyResolver() {\n    return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName());\n}\npublic static String getIpAddr(ServerHttpRequest request) {\n    HttpHeaders headers = request.getHeaders();\n    List<String> ips = headers.get("X-Forwarded-For");\n    String ip = "192.168.1.1";\n    if (ips != null && ips.size() > 0) {\n        ip = ips.get(0);\n    }\n    return ip;\n}\n2. 用户限流\n根据用户来做限流只需要获取当前请求的用户 ID 或者用户名，代码如下所示。\n@Bean\nKeyResolver userKeyResolver() {\n    return exchange ->\n        Mono.just(exchange.getRequest().getQueryParams().getFirst("userId"));\n}\n3. 接口限流\n获取请求地址的 uri 作为限流 Key，代码如下所示。\n@Bean\nKeyResolver apiKeyResolver() {\n    return exchange ->\n        Mono.just(exchange.getRequest().getPath().value());\n}\n然后配置限流的过滤器信息：\nserver:\n  port: 8084\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n  cloud:\n    gateway:\n  routes:\n    - id: fsh-house\n  uri: lb://fsh-house\n  predicates:\n    - Path=/house/**\n  filters:\n    - name: RequestRateLimiter\n  args:\n    redis-rate-limiter.replenishRate: 10\n    redis-rate-limiter.burstCapacity: 20\n    key-resolver: "#{@ipKeyResolver}"\n\nfilter 名称必须是 RequestRateLimiter。\nredis-rate-limiter.replenishRate：允许用户每秒处理多少个请求。\nredis-rate-limiter.burstCapacity：令牌桶的容量，允许在 1s 内完成的最大请求数。\nkey-resolver：使用 SpEL 按名称引用 bean。\n\n可以访问接口进行测试，这时候 Redis 中会有对应的数据：\n127.0.0.1:6379> keys *\n1) "request_rate_limiter.{localhost}.timestamp"\n2) "request_rate_limiter.{localhost}.tokens"\n\n大括号中就是我们的限流 Key，这里是 IP，本地的就是 localhost。\ntimestamp：存储的是当前时间的秒数，也就是 System.currentTimeMillis()/1000 或者 Instant.now().getEpochSecond()。\ntokens：存储的是当前这秒钟对应的可用令牌数量。\n熔断回退实战\n在 Spring Cloud Gateway 中使用 Hystrix 进行回退需要增加 Hystrix 的依赖，代码如下所示。\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n\n内置了 HystrixGatewayFilterFactory 来实现路由级别的熔断，只需要配置即可实现熔断回退功能。配置方式如下所示。\n- id: user-service\nuri: lb://user-service\npredicates:\n  - Path=/user-service/**\nfilters:\n  - name: Hystrix\nargs:\n  name: fallbackcmd\nfallbackUri: forward:/fallback\n\n上面配置了一个 Hystrix 过滤器，该过滤器会使用 Hystrix 熔断与回退，原理是将请求包装成 RouteHystrixCommand 执行，RouteHystrixCommand 继承于 com.netflix.hystrix.HystrixObservableCommand。\n\nfallbackUri 是发生熔断时回退的 URI 地址，目前只支持 forward 模式的 URI。如果服务被降级，该请求会被转发到该 URI 中。\n\n在网关中创建一个回退的接口，用于熔断时处理返回给调用方的信息，代码如下所示。\n@RestController\npublic class FallbackController {\n    @GetMapping("/fallback")\n    public String fallback() {\n        return "fallback";\n    }\n}\n跨域实战\n在 Spring Cloud Gateway 中配置跨域有两种方式，分别是代码配置方式和配置文件方式。\n\n代码配置方式配置跨域，具体代码如下所示。\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public WebFilter corsFilter() {\n        return (ServerWebExchange ctx, WebFilterChain chain) -> {\n            ServerHttpRequest request = ctx.getRequest();\n            if (CorsUtils.isCorsRequest(request)) {\n                HttpHeaders requestHeaders = request.getHeaders();\n                ServerHttpResponse response = ctx.getResponse();\n                HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();\n                HttpHeaders headers = response.getHeaders();\n                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());\n                headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,\n                        requestHeaders.getAccessControlRequestHeaders());\n                if (requestMethod != null) {\n                    headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());\n                }\n                headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");\n                headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "*");\n                if (request.getMethod() == HttpMethod.OPTIONS) {\n                    response.setStatusCode(HttpStatus.OK);\n                    return Mono.empty();\n                }\n            }\n            return chain.filter(ctx);\n        };\n    }\n}\n配置文件方式配置跨域：\nspring:\n  cloud:\n    gateway:\n      globalcors:\n        corsConfigurations:\n          \'[/**]\':\n            allowedOrigins: "*"\n            exposedHeaders:\n              - content-type\n            allowedHeaders:\n              - content-type\n            allowCredentials: true\n              allowedMethods:\n              - GET\n              - OPTIONS\n              - PUT\n              - DELETE\n              - POST\n\n统一异常处理\nSpring Cloud Gateway 中的全局异常处理不能直接使用 @ControllerAdvice，可以通过跟踪异常信息的抛出，找到对应的源码，自定义一些处理逻辑来匹配业务的需求。\n\n网关是给接口做代理转发的，后端对应的是 REST API，返回数据格式是 JSON。如果不做处理，当发生异常时，Gateway 默认给出的错误信息是页面，不方便前端进行异常处理。\n\n所以我们需要对异常信息进行处理，并返回 JSON 格式的数据给客户端。下面先看实现的代码，后面再跟大家讲一下需要注意的地方。\n\n自定义异常处理逻辑，代码如下所示。\npublic class JsonExceptionHandler extends DefaultErrorWebExceptionHandler {\n    public JsonExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,\n            ErrorProperties errorProperties, ApplicationContext applicationContext) {\n        super(errorAttributes, resourceProperties, errorProperties, applicationContext);\n    }\n    /**\n     * 获取异常属性\n     */\n    @Override\n    protected Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) {\n        int code = 500;\n        Throwable error = super.getError(request);\n        if (error instanceof org.springframework.cloud.gateway.support.NotFoundException) {\n            code = 404;\n        }\n        return response(code, this.buildMessage(request, error));\n    }\n    /**\n     * 指定响应处理方法为JSON处理的方法\n     *\n     * @param errorAttributes\n     */\n    @Override\n    protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {\n        return RouterFunctions.route(RequestPredicates.all(), this::renderErrorResponse);\n    }\n    /**\n     * 根据code获取对应的HttpStatus\n     *\n     * @param errorAttributes\n     */\n    @Override\n    protected HttpStatus getHttpStatus(Map<String, Object> errorAttributes) {\n        int statusCode = (int) errorAttributes.get("code");\n        return HttpStatus.valueOf(statusCode);\n    }\n    /**\n     * 构建异常信息\n     *\n     * @param request\n     * @param ex\n     * @return\n     */\n    private String buildMessage(ServerRequest request, Throwable ex) {\n        StringBuilder message = new StringBuilder("Failed to handle request [");\n        message.append(request.methodName());\n        message.append(" ");\n        message.append(request.uri());\n        message.append("]");\n        if (ex != null) {\n            message.append(": ");\n            message.append(ex.getMessage());\n        }\n        return message.toString();\n    }\n    /**\n     * 构建返回的JSON数据格式\n     *\n     * @param status       状态码\n     * @param errorMessage 异常信息\n     * @return\n     */\n    public static Map<String, Object> response(int status, String errorMessage) {\n        Map<String, Object> map = new HashMap<>();\n        map.put("code", status);\n        map.put("message", errorMessage);\n        map.put("data", null);\n        return map;\n    }\n}\n覆盖默认的配置，代码如下所示。\n@Configuration\n@EnableConfigurationProperties({ ServerProperties.class, ResourceProperties.class })\npublic class ErrorHandlerConfiguration {\n    private final ServerProperties serverProperties;\n    private final ApplicationContext applicationContext;\n    private final ResourceProperties resourceProperties;\n    private final List<ViewResolver> viewResolvers;\n    private final ServerCodecConfigurer serverCodecConfigurer;\n    public ErrorHandlerConfiguration(ServerProperties serverProperties, ResourceProperties resourceProperties,\n            ObjectProvider<List<ViewResolver>> viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer,\n            ApplicationContext applicationContext) {\n        this.serverProperties = serverProperties;\n        this.applicationContext = applicationContext;\n        this.resourceProperties = resourceProperties;\n        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);\n        this.serverCodecConfigurer = serverCodecConfigurer;\n    }\n    @Bean\n    @Order(Ordered.HIGHEST_PRECEDENCE)\n    public ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes) {\n        JsonExceptionHandler exceptionHandler = new JsonExceptionHandler(errorAttributes, \n            this.resourceProperties,this.serverProperties.getError(), this.applicationContext);\n        exceptionHandler.setViewResolvers(this.viewResolvers);\n        exceptionHandler.setMessageWriters(this.serverCodecConfigurer.getWriters());\n        exceptionHandler.setMessageReaders(this.serverCodecConfigurer.getReaders());\n        return exceptionHandler;\n    }\n}\n1. 异常时如何返回 JSON 而不是 HTML？\n在 org.springframework.boot.autoconfigure.web.reactive.error.DefaultErrorWeb-Exception-Handler 中的 getRoutingFunction() 方法就是控制返回格式的，源代码如下所示。\n@Override\nprotected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {\n    return RouterFunctions.route(acceptsTextHtml(), this::renderErrorView).andRoute(RequestPredicates.all(), this::renderErrorResponse);\n}\n\n这里优先是用 HTML 来显示的，如果想用 JSON 显示改动就可以了，具体代码如下所示。\nprotected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {\n    return RouterFunctions.route(RequestPredicates.all(),this::renderErrorResponse);\n}\n\n2. getHttpStatus 需要重写\n原始的方法是通过 status 来获取对应的 HttpStatus 的，具体代码如下所示。\nprotected HttpStatus getHttpStatus(Map<String, Object> errorAttributes) {\n    int statusCode = (int) errorAttributes.get("status");\n    return HttpStatus.valueOf(statusCode);\n}\n\n如果我们定义的格式中没有 status 字段的话，就会报错，因为找不到对应的响应码。要么返回数据格式中增加 status 子段，要么重写，在笔者的操作中返回的是 code，所以要重写，代码如下所示。\n@Override\nprotected HttpStatus getHttpStatus(Map<String, Object> errorAttributes) {\n    int statusCode = (int) errorAttributes.get("code");\n    return HttpStatus.valueOf(statusCode);\n}\n\n重试机制\nRetryGatewayFilter 是 Spring Cloud Gateway 对请求重试提供的一个 GatewayFilter Factory。配置方式如下所示。\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: zuul-encrypt-service\n  uri: lb://zuul-encrypt-service\n  predicates:\n    - Path=/data/**\n  filters:\n    - name: Retry\n  args:\n    retries: 3\n    series: SERVER_ERROR\n\n上述代码中具体参数含义如下所示。\nretries：重试次数，默认值是 3 次。\nseries：状态码配置（分段），符合某段状态码才会进行重试逻辑，默认值是 SERVER_ERROR，值是 5，也就是 5XX（5 开头的状态码），共有 5 个值，代码如下所示。\npublic enum Series {\n    INFORMATIONAL(1), SUCCESSFUL(2), REDIRECTION(3), CLIENT_ERROR(4), SERVER_ERROR(5);\n}\n\n上述代码中具体参数含义如下所示。\nstatuses：状态码配置，和 series 不同的是这里是具体状态码的配置，取值请参考 org.springframework.http.HttpStatus。\nmethods：指定哪些方法的请求需要进行重试逻辑，默认值是 GET 方法，取值代码如下所示。\npublic enum HttpMethod {\n    GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE;\n}\n\n上述代码中具体参数含义如下所示。 exceptions：指定哪些异常需要进行重试逻辑。默认值是 java.io.IOException 和 org.springframework.cloud.gateway.support.TimeoutException。\n\n')])])])])}),[],!1,null,null,null);r.default=s.exports}}]);