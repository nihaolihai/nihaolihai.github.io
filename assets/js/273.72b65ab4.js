(window.webpackJsonp=window.webpackJsonp||[]).push([[273],{765:function(n,a,t){"use strict";t.r(a);var e=t(6),i=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"day7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day7"}},[n._v("#")]),n._v(" day7")]),n._v(" "),t("h2",{attrs:{id:"提纲-1-回顾多态2-面向父类编程应用3-简单工厂模式4-static关键字极其应用5-类加载进jvm活动过程6-单例模式7-final关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提纲-1-回顾多态2-面向父类编程应用3-简单工厂模式4-static关键字极其应用5-类加载进jvm活动过程6-单例模式7-final关键字"}},[n._v("#")]),n._v(" 提纲:1.回顾多态\n2.面向父类编程应用\n3.简单工厂模式\n4.static关键字极其应用\n5.类加载进JVM活动过程\n6.单例模式\n7.Final关键字")]),n._v(" "),t("p",[n._v("多态:\n编译时类型:可以看成是声明对象时的数据类型,在编译时有效\n运行时类型:可以看成是new运算符后的类型")]),n._v(" "),t("p",[n._v("多态的理解:\n编译时类型决定了对象可以访问到的非私有成员\n运行时类型决定了该对象真正的行为能力")]),n._v(" "),t("h2",{attrs:{id:"多态的应用-面向父类编程1-编译时类型要写成父类2-方法的参数类型要写成父类3-方法的返回类型要写成父类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态的应用-面向父类编程1-编译时类型要写成父类2-方法的参数类型要写成父类3-方法的返回类型要写成父类"}},[n._v("#")]),n._v(" 多态的应用-----\x3e面向父类编程\n1.编译时类型要写成父类\n2.方法的参数类型要写成父类\n3.方法的返回类型要写成父类")]),n._v(" "),t("p",[n._v("案例:ShapeBiz   给方法中传入指定参数,输出它的周长和面积\npublic void area(Circle circle){\nSystem.out.println(circle.area());\n}")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("                   public void area(Rect rect){\n                            System.out.println(rect.area());\n                    }          \n                  .............\n")])])]),t("p",[n._v("改成写:只要传入一个参数,就可以打印出所有图形的面积和周长\npublic void area(Shape s){\nSystem.out.println(s.area());\n}")]),n._v(" "),t("h2",{attrs:{id:"测试shape-s-new-circle-4-0-shapebiz-biz-new-shapebiz-biz-area-s"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试shape-s-new-circle-4-0-shapebiz-biz-new-shapebiz-biz-area-s"}},[n._v("#")]),n._v(" //测试\nShape s = new Circle(4.0);\nShapeBiz biz = new ShapeBiz();\nbiz.area(s);")]),n._v(" "),t("p",[n._v("面向父类编程之   方法的返回类型要写成父类\n简单工厂模式\n设计一个案例:传入一个指定参数,返回某一个类的具体的实例")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("                  public static Circle getInstance(int type){\n                          return new Cicle();\n                  }\n                  \n                  Circle circle = new Circle();\n                  Circle circle = Circle.getInstance(1);\n\n                  之前学过的Calendar cal = Calendar.getInstance();\n                  就是运用了简单工厂模式\n\n\n                  private static  final int CIRCLE = 0;\n                  private static  final int RECT = 1;\n                  private static  final int SQUARE= 2;\n\n                  //方法的返回类型写成父类\n                public static Shape getInstance(int type){\n                        Shape s = null;\n                        if(type==CIRCLE){\n                                s = new Circle();\n                        }else if(type==RECT){\n                              s = new Rect();\n                        }\n                            .....\n                           return s;\n                }\n")])])]),t("hr"),n._v(" "),t("p",[n._v("static 关键字\n属性:静态属性,也叫作类变量,是所有对象所共享的,\n它是类所拥有的!")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("          语法:public static int id;\n     \n     静态属性初始化的时机:\n            当类加载的时候,就会给静态属性分配空间,并且进行初始化;\n            而普通属性,是创建对象的时候,才会给它分配空间并且进行初始化.\n     \n     方法:静态方法\n\n     特点:a.静态方法中可以直接调用静态成员,如果要调用非静态成员,需要先创建对象\n             b.静态方法可以直接通过类名.方法名来调用,非静态成员需通过对象.方法名\n             c.非静态方法可以调用任何成员(包括静态和非静态成员)\n")])])]),t("p",[n._v("问题1:为什么静态方法中不能够直接调用非静态方法?\n答:因为静态方法是在类加载的时候就出现了,而此时对象还不存在,\n但是非静态成员是对象所拥有的,对象都不存在,自然就不能调用!")]),n._v(" "),t("p",[n._v("问题2:为什么main是静态的呢?\n答:main是程序的主入口,它是由JVM来调用的,但是此时还没有对象\n根据JVM规范,我们将它定义成静态的.")]),n._v(" "),t("p",[n._v("问题3:为什么不是所有的方法都定义成静态的?\n答:因为静态成员是类加载的时候就出现了.如果说静态成员比较多的话\n会消耗资源,效率低下,并且有很多东西用的次数并不多!")]),n._v(" "),t("p",[n._v("通常情况下:工具类当中的方法一般都是静态的,方便使用!")]),n._v(" "),t("h2",{attrs:{id:"static应用之-产生自增唯一的id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#static应用之-产生自增唯一的id"}},[n._v("#")]),n._v(" static应用之  产生自增唯一的id")]),n._v(" "),t("p",[n._v("代码块:\n普通代码块\n{")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    }\n    静态代码块\n    static{\n        \n    }\n")])])]),t("p",[n._v("注意:\n1.静态代码块是类加载的时候就执行,并且只执行1次\n2.普通代码块是每次创建对象的时候优先执行,一般我们选择\n不写普通代码块,它被移植到构造方法中.\n类加载进JVM的活动过程\n1.JVM将类加载到内存\n2.给这个类中的所有静态成员分配空间\n3.给这些静态成员初始化\n4.调用静态代码块\n5.如果创建了对象,则\n5-1 给所有的非静态成员分配空间\n5-2 初始化非静态成员\n5-3 调用普通代码块(一般都是移植到构造方法中)\n5-4 调用构造方法")]),n._v(" "),t("h2",{attrs:{id:"静态代码块应用-用来处理一些费时费力-并且只需要执行一次的程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态代码块应用-用来处理一些费时费力-并且只需要执行一次的程序"}},[n._v("#")]),n._v(" 静态代码块应用:用来处理一些费时费力,并且只需要执行一次的程序")]),n._v(" "),t("p",[n._v("static应用之二  单例模式的设计\n要求:在应用程序当中,某个类的实例有且只有1个\n解决方案:\n1.提供一个类的唯一实例作为这个类的静态属性\nprivate static Singleton singleton = new Singleton();\n2.私有化构造方法    目的是为了让外界不能new\nprivate Singleton(){")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("       }\n    3.提供一个静态的公开的方法来返回这个类的实例\n      public static Singleton getInstance(){\n              return singleton;\n      }\n")])])]),t("hr"),n._v(" "),t("p",[n._v("Final 关键字\n1.局部变量\n特点:1.在使用之前,必须要初始化\n2.一旦赋值,不能改变\n3.比字面量携带更多的信息\n2.属性\n特点:1.在声明的时候必须进行赋值\n2.可以通过静态代码块进行赋值\n3.方法\n特点:final修饰的方法不能够被重写\n4.类\n特点:final修饰的类不能够被继承")])])}),[],!1,null,null,null);a.default=i.exports}}]);