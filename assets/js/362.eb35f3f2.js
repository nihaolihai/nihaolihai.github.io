(window.webpackJsonp=window.webpackJsonp||[]).push([[362],{852:function(n,e,r){"use strict";r.r(e);var t=r(6),o=Object(t.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h2",{attrs:{id:"apollo客户端设计原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#apollo客户端设计原理"}},[this._v("#")]),this._v(" Apollo客户端设计原理")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('本节主要对 Apollo 客户端设计原理进行解析。\n1. 设计原理\n图 1 简要描述了 Apollo 客户端的实现原理。\n\n客户端和服务端保持了一个长连接，编译配置的实时更新推送。\n定时拉取配置是客户端本地的一个定时任务，默认为每 5 分钟拉取一次，也可以通过在运行时指定 System Property：apollo.refreshInterval 来覆盖，单位是分钟，推送+定时拉取=双保险。\n客户端从 Apollo 配置中心服务端获取到应用的最新配置后，会保存在内存中。\n客户端会把从服务端获取到的配置在本地文件系统缓存一份，当服务或者网络不可用时，可以使用本地的配置，也就是我们的本地开发模式 env=Local。\n2. 和 Spring 集成的原理\nApollo 除了支持 API 方式获取配置，也支持和 Spring/Spring Boot 集成，集成后可以直接通过 @Value 获取配置，我们来分析下集成的原理。\n\nSpring 从 3.1 版本开始增加了 ConfigurableEnvironment 和 PropertySource：\nConfigurableEnvironment 实现了 Environment 接口，并且包含了多个 Property-Source。\nPropertySource 可以理解为很多个 Key-Value 的属性配置，在运行时的结构形如图 2 所示。\n\n需要注意的是，PropertySource 之间是有优先级顺序的，如果有一个 Key 在多个 property source 中都存在，那么位于前面的 property source 优先。\n\n集成的原理就是在应用启动阶段，Apollo 从远端获取配置，然后组装成 PropertySource 并插入到第一个即可，如图 3 所示。\n\nSpring配置动态插入\n图 3  Spring配置动态插入\n3. 启动时初始化配置到 Spring\n客户端集成 Spring 的代码分析，我们也采取简化的方式进行讲解。\n\n首先我们来分析，在项目启动的时候从 Apollo 拉取配置，是怎么集成到 Spring 中的。创建一个 PropertySourcesProcessor 类，用于初始化配置到 Spring PropertySource 中。具体代码如下所示。\n@Component\npublic class PropertySourcesProcessor implements BeanFactoryPostProcessor, EnvironmentAware {\n    String APOLLO_PROPERTY_SOURCE_NAME = "ApolloPropertySources";\n    private ConfigurableEnvironment environment;\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        // 启动时初始化配置到Spring PropertySource\n        Config config = new Config();\n        ConfigPropertySource configPropertySource = new ConfigPropertySource("ap-plication", config);\n        CompositePropertySource composite = new CompositePropertySource(APOLLO_PROPERTY_SOURCE_NAME);\n        composite.addPropertySource(configPropertySource);\n        environment.getPropertySources().addFirst(composite);\n    }\n    @Override\n    public void setEnvironment(Environment environment) {\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n}\n实现 EnvironmentAware 接口是为了获取 Environment 对象。实现 BeanFactory-Post-Processor 接口，我们可以在容器实例化 bean 之前读取 bean 的信息并修改它。\n\nConfig 在 Apollo 中是一个接口，定义了很多读取配置的方法，比如 getProperty：getIntProperty 等。通过子类去实现这些方法，在这里我们就简化下，直接定义成一个类，提供两个必要的方法，具体代码如下所示。\npublic class Config {\n    public String getProperty(String key, String defaultValue) {\n        if (key.equals("bianchengName")) {\n            return "C语言中文网";\n        }\n        return null;\n    }\n    public Set<String> getPropertyNames() {\n        Set<String> names = new HashSet<>();\n        names.add("bianchengName");\n        return names;\n    }\n}\nConfig 就是配置类，配置拉取之后会存储在类中，所有配置的读取都必须经过它，我们在这里就平格定义需要读取的 key 为 bianchengName。\n\n然后需要将 Config 封装成 PropertySource 才能插入到 Spring Environment 中。\n\n定义一个 ConfigPropertySource 用于将 Config 封装成 PropertySource，ConfigProperty-Source 继承了 EnumerablePropertySource，EnumerablePropertySource 继承了 PropertySource。具体代码如下所示。\npublic class ConfigPropertySource extends EnumerablePropertySource<Config> {\n    private static final String[] EMPTY_ARRAY = new String[0];\n    ConfigPropertySource(String name, Config source) {\n        super(name, source);\n    }\n    @Override\n    public String[] getPropertyNames() {\n        Set<String> propertyNames = this.source.getPropertyNames();\n        if (propertyNames.isEmpty()) {\n            return EMPTY_ARRAY;\n        }\n        return propertyNames.toArray(new String[propertyNames.size()]);\n    }\n    @Override\n    public Object getProperty(String name) {\n        return this.source.getProperty(name, null);\n    }\n}\n需要做的操作还是重写 getPropertyNames 和 getProperty 这两个方法。当调用这两个方法时，返回的就是 Config 中的内容。\n\n最后将 ConfigPropertySource 添加到 CompositePropertySource 中，并且加入到 Confi-gu-rable-Environment 即可。\n\n定义一个接口用来测试有没有效果，具体代码如下所示。\n@RestController\npublic class ConfigController {\n    @Value("${bianchengName:zhangsan}")\n    private String name;\n    @GetMapping("/get")\n    private String bianchengUrl;\n    @GetMapping("/get")\n    public String get() {\n        return name + bianchengUrl;\n    }\n}\n在配置文件中增加对应的配置：\nbianchengName=xxx\nbianchengUrl=http://c.biancheng.net\n\n在没有增加上面讲的代码之前，访问 /get 接口返回的是 xxxhttp://c.biancheng.net。加上上面讲解的代码之后，返回的内容就变成了猿天地 http://c.biancheng.net。\n\n这是因为我们在 Config 中对应 bianchengName 这个 key 的返回值是猿天地，也间接证明了在启动的时候可以通过这种方式来覆盖本地的值。这就是 Apollo 与 Spring 集成的原理。\n4. 运行中修改配置如何刷新\n在这一节中，我们来讲解下在项目运行过程中，配置发生修改之后推送给了客户端，那么这个值如何去更新 Spring 当中的值呢？\n\n原理就是把这些配置都存储起来，当配置发生变化的时候进行修改就可以。Apollo 中定义了一个 SpringValueProcessor 类，用来处理 Spring 中值的修改。下面只贴出一部分代码，如下所示。\n@Component\npublic class SpringValueProcessor implements BeanPostProcessor, BeanFactoryAware {\n    private PlaceholderHelper placeholderHelper = new PlaceholderHelper();\n    private BeanFactory beanFactory;\n    public SpringValueRegistry springValueRegistry = new SpringValueRegistry();\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        Class clazz = bean.getClass();\n        for (Field field : findAllField(clazz)) {\n            processField(bean, beanName, field);\n        }\n        return bean;\n    }\n    private void processField(Object bean, String beanName, Field field) {\n        // register @Value on field\n        Value value = field.getAnnotation(Value.class);\n        if (value == null) {\n            return;\n        }\n        Set<String> keys = placeholderHelper.extractPlaceholderKeys(value.value());\n        if (keys.isEmpty()) {\n            return;\n        }\n        for (String key : keys) {\n            SpringValue springValue = new SpringValue(key, value.value(), bean, beanName, field, false);\n            springValueRegistry.register(beanFactory, key, springValue);\n        }\n    }\n}\n通过实现 BeanPostProcessor 来处理每个 bean 中的值，然后将这个配置信息封装成一个 SpringValue 存储到 springValueRegistry 中。\n\nSpringValue 代码如下所示。\npublic class SpringValue {\n    private MethodParameter methodParameter;\n    private Field field;\n    private Object bean;\n    private String beanName;\n    private String key;\n    private String placeholder;\n    private Class<?> targetType;\n    private Type genericType;\n    private boolean isJson;\n}\nSpringValueRegistry 就是利用 Map 来存储，代码如下所示。\npublic class SpringValueRegistry {\n    private final Map<BeanFactory, Multimap<String, SpringValue>> registry = Maps.newConcurrentMap();\n    private final Object LOCK = new Object();\n    public void register(BeanFactory beanFactory, String key, SpringValue springValue) {\n        if (!registry.containsKey(beanFactory)) {\n            synchronized (LOCK) {\n                if (!registry.containsKey(beanFactory)) {\n                    registry.put(beanFactory, LinkedListMultimap.<String, SpringValue>create());\n                }\n            }\n        }\n        registry.get(beanFactory).put(key, springValue);\n    }\n    public Collection<SpringValue> get(BeanFactory beanFactory, String key) {\n        Multimap<String, SpringValue> beanFactorySpringValues = registry.get(beanFactory);\n        if (beanFactorySpringValues == null) {\n            return null;\n        }\n        return beanFactorySpringValues.get(key);\n    }\n}\n写个接口用于模拟配置修改，具体代码如下所示。\n@RestController\npublic class ConfigController {\n    @Autowired\n    private SpringValueProcessor springValueProcessor;\n    @Autowired\n    private ConfigurableBeanFactory beanFactory;\n    @GetMapping("/update")\n    public String update(String value) {\n        Collection<SpringValue> targetValues = springValueProcessor.springValueRegistry.get(beanFactory,\n                "bianchengName");\n        for (SpringValue val : targetValues) {\n            try {\n                val.update(value);\n            } catch (IllegalAccessException | InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n        return name;\n    }\n}\n当我们调用 /update接口后，在前面的 /get 接口可以看到猿天地的值改成了你传入的那个值，这就是动态修改。\n5. 原理分析总结\n至此关于 Apollo 核心原理的分析就结束了，通过阅读 Apollo 的源码，可以学到很多的东西。\n \nApollo 用的是 Mysql。Apollo 是多个库，通过库来区分不同环境下的配置。\nApollo 基于 Http 长连接实现推送，还有容灾的定时拉取逻辑。\nApollo 也有自己的原生获取值的对象，同时还集成到了 Spring 中，可以兼容老项目的使用方式。\nApollo 中可以直接使用注解来进行监听，非常方便。\n\n\n')])])]),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190828/5-1ZRQ05921c7.png",alt:"RUNOOB 图标"}})]),this._v(" "),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190828/5-1ZRQ1015O18.gif",alt:"RUNOOB 图标"}})]),this._v(" "),e("p",[e("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190828/5-1ZRQ10343a4.png",alt:"RUNOOB 图标"}})])])}),[],!1,null,null,null);e.default=o.exports}}]);