(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{633:function(n,a,e){"use strict";e.r(a);var t=e(6),l=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"java-抽象类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-抽象类"}},[n._v("#")]),n._v(" Java 抽象类")]),n._v(" "),e("p",[n._v("在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。")]),n._v(" "),e("p",[n._v("抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。")]),n._v(" "),e("p",[n._v("由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。")]),n._v(" "),e("p",[n._v("父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。")]),n._v(" "),e("p",[n._v("在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。")]),n._v(" "),e("p",[n._v("抽象类\n在Java语言中使用abstract class来定义抽象类。如下实例：")]),n._v(" "),e("p",[n._v('Employee.java 文件代码：\n/* 文件名 : Employee.java */\npublic abstract class Employee\n{\nprivate String name;\nprivate String address;\nprivate int number;\npublic Employee(String name, String address, int number)\n{\nSystem.out.println("Constructing an Employee");\nthis.name = name;\nthis.address = address;\nthis.number = number;\n}\npublic double computePay()\n{\nSystem.out.println("Inside Employee computePay");\nreturn 0.0;\n}\npublic void mailCheck()\n{\nSystem.out.println("Mailing a check to " + this.name\n+ " " + this.address);\n}\npublic String toString()\n{\nreturn name + " " + address + " " + number;\n}\npublic String getName()\n{\nreturn name;\n}\npublic String getAddress()\n{\nreturn address;\n}\npublic void setAddress(String newAddress)\n{\naddress = newAddress;\n}\npublic int getNumber()\n{\nreturn number;\n}\n}\n注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：')]),n._v(" "),e("p",[n._v("AbstractDemo.java 文件代码：\n/* 文件名 : AbstractDemo.java "),e("em",[n._v("/\npublic class AbstractDemo\n{\npublic static void main(String [] args)\n{\n/")]),n._v(' 以下是不允许的，会引发错误 */\nEmployee e = new Employee("George W.", "Houston, TX", 43);')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('  System.out.println("\\n Call mailCheck using Employee reference--");\n  e.mailCheck();\n}\n')])])]),e("p",[n._v("}\n当你尝试编译AbstractDemo类时，会产生如下错误：")]),n._v(" "),e("p",[n._v('Employee.java:46: Employee is abstract; cannot be instantiated\nEmployee e = new Employee("George W.", "Houston, TX", 43);\n^\n1 error\n继承抽象类\n我们能通过一般的方法继承Employee类：')]),n._v(" "),e("p",[n._v('Salary.java 文件代码：\n/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\nprivate double salary; //Annual salary\npublic Salary(String name, String address, int number, double\nsalary)\n{\nsuper(name, address, number);\nsetSalary(salary);\n}\npublic void mailCheck()\n{\nSystem.out.println("Within mailCheck of Salary class ");\nSystem.out.println("Mailing check to " + getName()\n+ " with salary " + salary);\n}\npublic double getSalary()\n{\nreturn salary;\n}\npublic void setSalary(double newSalary)\n{\nif(newSalary >= 0.0)\n{\nsalary = newSalary;\n}\n}\npublic double computePay()\n{\nSystem.out.println("Computing salary pay for " + getName());\nreturn salary/52;\n}\n}\n尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。')]),n._v(" "),e("p",[n._v('AbstractDemo.java 文件代码：\n/* 文件名 : AbstractDemo.java */\npublic class AbstractDemo\n{\npublic static void main(String [] args)\n{\nSalary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00);\nEmployee e = new Salary("John Adams", "Boston, MA", 2, 2400.00);')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('  System.out.println("Call mailCheck using Salary reference --");\n  s.mailCheck();\n\n  System.out.println("\\n Call mailCheck using Employee reference--");\n  e.mailCheck();\n}\n')])])]),e("p",[n._v("}\n以上程序编译运行结果如下：")]),n._v(" "),e("p",[n._v("Constructing an Employee\nConstructing an Employee\nCall mailCheck using  Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0")]),n._v(" "),e("p",[n._v("Call mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.\n抽象方法\n如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。")]),n._v(" "),e("p",[n._v("Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。")]),n._v(" "),e("p",[n._v("抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。")]),n._v(" "),e("p",[n._v("public abstract class Employee\n{\nprivate String name;\nprivate String address;\nprivate int number;")]),n._v(" "),e("p",[n._v("public abstract double computePay();")]),n._v(" "),e("p",[n._v("//其余代码\n}\n声明抽象方法会造成以下两个结果：")]),n._v(" "),e("p",[n._v("如果一个类包含抽象方法，那么该类必须是抽象类。\n任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。")]),n._v(" "),e("p",[n._v("如果Salary类继承了Employee类，那么它必须实现computePay()方法：")]),n._v(" "),e("p",[n._v("Salary.java 文件代码：\n/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\nprivate double salary; // Annual salary")]),n._v(" "),e("p",[n._v('public double computePay()\n{\nSystem.out.println("Computing salary pay for " + getName());\nreturn salary/52;\n}')]),n._v(" "),e("p",[n._v("//其余代码\n}")]),n._v(" "),e("p",[n._v("抽象类总结规定")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。")])]),n._v(" "),e("li",[e("p",[n._v("抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。")])]),n._v(" "),e("li",[e("p",[n._v("抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。")])]),n._v(" "),e("li",[e("p",[n._v("构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。")])]),n._v(" "),e("li",[e("p",[n._v("抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。")])])])])}),[],!1,null,null,null);a.default=l.exports}}]);