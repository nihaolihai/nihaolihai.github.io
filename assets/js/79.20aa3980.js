(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{575:function(v,_,t){"use strict";t.r(_);var e=t(6),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"hbase数据模型解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hbase数据模型解析"}},[v._v("#")]),v._v(" HBase数据模型解析")]),v._v(" "),t("p",[v._v("HBase 的基本概念\nHBase 不支持关系模型，它可以根据用户的需求提供更灵活和可扩展的表设计。与传统的关系型数据库类似，HBase 也是以表的方式组织数据，应用程序将数据存于 HBase 的表中，HBase 的表也由行和列组成。")]),v._v(" "),t("p",[v._v("但有一点不同的是，HBase 有列族的概念，它将一列或多列组织在一起，HBase 的每个列必须属于某一个列族。")]),v._v(" "),t("p",[v._v("下面具体介绍 HBase 数据模型中一些名词的概念。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("表（Table）\nHBase 中的数据以表的形式存储。同一个表中的数据通常是相关的，使用表主要是可以把某些列组织起来一起访问。表名作为 HDFS 存储路径的一部分来使用，在 HDFS 中可以看到每个表名都作为独立的目录结构。")])]),v._v(" "),t("li",[t("p",[v._v("行（Row）\n在 HBase 表里，每一行代表一个数据对象，每一行都以行键（Row Key）来进行唯一标识，行键可以是任意字符串。在 HBase 内部，行键是不可分割的字节数组，并且行键是按照字典排序由低到高存储在表中的。在 HBase 中可以针对行键建立索引，提高检索数据的速度。")])]),v._v(" "),t("li",[t("p",[v._v("列族（Colunm Family）\nHBase 中的列族是一些列的集合，列族中所有列成员有着相同的前缀，列族的名字必须是可显示的字符串。列族支持动态扩展，用户可以很轻松地添加一个列族或列，无须预定义列的数量以及类型。所有列均以字符串形式存储，用户在使用时需要自行进行数据类型转换。")])]),v._v(" "),t("li",[t("p",[v._v("列标识（Column Qualifier）\n列族中的数据通过列标识来进行定位，列标识也没有特定的数据类型，以二进制字节来存储。通常以 Column Family：Colunm Qualifier 来确定列族中的某列。")])]),v._v(" "),t("li",[t("p",[v._v("单元格（Cell）\n每一个行键、列族、列标识共同确定一个单元格，单元格的内容没有特定的数据类型，以二进制字节来存储。每个单元格保存着同一份数据的多个版本，不同时间版本的数据按照时间先后顺序排序，最新的数据排在最前面。单元格可以用<RowKey,Column Family: Column Qualifier,Timestamp>\n元组来进行访问。")])]),v._v(" "),t("li",[t("p",[v._v("时间戳（Timestamp）\n在默认情况下，每一个单元格插入数据时都会用时间戳来进行版本标识。读取单元格数据时，如果时间戳没有被指定，则默认返回最新的数据；写入新的单元格数据时，如果没有设置时间戳，默认使用当前时间。每一个列族的单元数据的版本数量都被 HBase 单独维护，默认情况下 HBase 保留 3 个版本数据。\n数据模型\n表是 HBase 中数据的逻辑组织方式，从用户视角来看，HBase 表的逻辑模型如表 1 所示。HBase 中的一个表有若干行，每行有多个列族，每个列族中包含多个列，而列中的值有多个版本。")])])]),v._v(" "),t("p",[v._v("表 1 ：HBase 逻辑数据模型")]),v._v(" "),t("p",[v._v("行键\t列族 StuInfo\t列族 Grades\t时间戳")]),v._v(" "),t("p",[v._v("Name\tAge\tSex\tClass\tBigData\tComputer\tMath")]),v._v(" "),t("p",[v._v("0001\tTom Green\t18\tMale\t \t80\t90\t85\tT2")]),v._v(" "),t("p",[v._v("0002\tAmy\t19\t \t01\t95\t \t89\tT1")]),v._v(" "),t("p",[v._v("0003\tAllen\t19\tMale\t02\t90\t \t88\tT1")]),v._v(" "),t("p",[v._v("表 1 展示的是 HBase 中的学生信息表 Student，有三行记录和两个列族，行键分别为 0001、0002 和 0003，两个列族分别为 Stulnfo 和 Grades，每个列族中含有若干列，如列族 Stulnfo 包括 Name、Age、Sex 和 Class 四列，列族 Grades 包括 BigData、Computer 和 Math 三列。")]),v._v(" "),t("p",[v._v("在 HBase 中，列不是固定的表结构，在创建表时，不需要预先定义列名，可以在插入数据时临时创建。")]),v._v(" "),t("p",[v._v("从表 1 的逻辑模型来看，HBase 表与关系型数据库中的表结构之间似乎没有太大差异，只不过多了列族的概念。但实际上是有很大差别的，关系型数据库中表的结构需要预先定义，如列名及其数据类型和值域等内容。")]),v._v(" "),t("p",[v._v("如果需要添加新列，则需要修改表结构，这会对已有的数据产生很大影响。同时，关系型数据库中的表为每个列预留了存储空间，即表 1 中的空白 Cell 数据在关系型数据库中以“NULL”值占用存储空间。因此，对稀疏数据来说，关系型数据库表中就会产生很多“NULL”值，消耗大量的存储空间。")]),v._v(" "),t("p",[v._v("在 HBase 中，如表 1 中的空白 Cell 在物理上是不占用存储空间的，即不会存储空白的键值对。因此，若一个请求为获取 RowKey 为 0001 在 T2 时间的 Stulnfo:class 值时，其结果为空。类似地，若一个请求为获取 RowKey 为 0002 在 T1 时间的 Grades Computer 值时，其结果也为空。")]),v._v(" "),t("p",[v._v("与面向行存储的关系型数据库不同，HBase 是面向列存储的，且在实际的物理存储中，列族是分开存储的，即表 1 中的学生信息表将被存储为 Stulnfo 和 Grades 两个部分。")]),v._v(" "),t("p",[v._v("表 2 展示了 Stulnfo 这个列族的实际物理存储方式，列族 Grades 的存储与之类似。在表 2 中可以看到空白 Cell 是没有被存储下来的。")]),v._v(" "),t("p",[v._v("表 2：StuInfo 列族的物理存储方式\n| 单元格  | 单元格 |")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("行键")]),v._v(" "),t("th",[v._v("列标识")]),v._v(" "),t("th",[v._v("值")]),v._v(" "),t("th",[v._v("时间戳")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("0001")]),v._v(" "),t("td",[v._v("Name")]),v._v(" "),t("td",[v._v("TomGreen")]),v._v(" "),t("td",[v._v("T2")])]),v._v(" "),t("tr",[t("td",[v._v("0001")]),v._v(" "),t("td",[v._v("Age")]),v._v(" "),t("td",[v._v("18")]),v._v(" "),t("td",[v._v("T2")])]),v._v(" "),t("tr",[t("td",[v._v("0001")]),v._v(" "),t("td",[v._v("Sex")]),v._v(" "),t("td",[v._v("Male")]),v._v(" "),t("td",[v._v("T2")])]),v._v(" "),t("tr",[t("td",[v._v("0002")]),v._v(" "),t("td",[v._v("Name")]),v._v(" "),t("td",[v._v("Amy")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0002")]),v._v(" "),t("td",[v._v("Age")]),v._v(" "),t("td",[v._v("19")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0002")]),v._v(" "),t("td",[v._v("Class")]),v._v(" "),t("td",[v._v("01")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0003")]),v._v(" "),t("td",[v._v("Name")]),v._v(" "),t("td",[v._v("Allen")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0003")]),v._v(" "),t("td",[v._v("Age")]),v._v(" "),t("td",[v._v("19")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0003")]),v._v(" "),t("td",[v._v("Sex")]),v._v(" "),t("td",[v._v("Male")]),v._v(" "),t("td",[v._v("T1")])]),v._v(" "),t("tr",[t("td",[v._v("0003")]),v._v(" "),t("td",[v._v("Class")]),v._v(" "),t("td",[v._v("02")]),v._v(" "),t("td",[v._v("T1")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);