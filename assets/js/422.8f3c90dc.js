(window.webpackJsonp=window.webpackJsonp||[]).push([[422],{912:function(n,t,r){"use strict";r.r(t);var a=r(6),s=Object(a.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-mvc数据验证简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc数据验证简介"}},[this._v("#")]),this._v(" Spring MVC数据验证简介")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("在 Spring MVC 框架中有以下两种方法可以验证输入数据：\n利用 Spring 自带的验证框架。\n利用 JSR 303 实现。\n\n数据验证分为客户端验证和服务器端验证，客户端验证主要是过滤正常用户的误操作，通过 JavaScript 代码完成。服务器端验证是整个应用阻止非法数据的最后防线，通过在应用中编程实现。\n客户端验证\n在大多数情况下，使用 JavaScript 进行客户端验证的步骤如下：\n编写验证函数。\n在提交表单的事件中调用验证函数。\n根据验证函数来判断是否进行表单提交。\n\n客户端验证可以过滤用户的误操作，是第一道防线，一般使用 JavaScript 代码实现。但仅有客户端验证是不够的，攻击者还可以绕过客户端验证直接进行非法输入，这样可能会引起系统异常，为了确保数据的合法性，防止用户通过非正常手段提交错误信息，必须加上服务器端验证。\n服务器端验证\nSpring MVC 的 Converter 和 Formatter 在进行类型转换时是将输入数据转换成领域对象的属性值（一种 Java 类型），一旦成功，服务器端验证器就会介入。也就是说，在 Spring MVC 框架中先进行数据类型转换，再进行服务器端验证。\n\n服务器端验证对于系统的安全性、完整性、健壮性起到了至关重要的作用。在 Spring MVC 框架中可以利用 Spring 自带的验证框架验证数据，也可以利用 JSR 303 实现数据验证。\n\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);