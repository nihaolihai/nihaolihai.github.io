(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{661:function(t,s,e){"use strict";e.r(s);var n=e(6),i=Object(n.a)({},(function(){var t=this.$createElement,s=this._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[s("h2",{attrs:{id:"java-8-新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-8-新特性"}},[this._v("#")]),this._v(" Java 8 新特性")]),this._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[this._v('\nJava 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。\n\n新特性\nJava8 新增了非常多的特性，我们主要讨论以下几个：\n\nLambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。\n\n方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n\n默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。\n\n新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。\n\nStream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。\n\nDate Time API − 加强对日期与时间的处理。\n\nOptional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。\n\nNashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。\n\n更多的新特性可以参阅官网：What\'s New in JDK 8\n\n在关于 Java 8 文章的实例，我们均使用 jdk 1.8 环境，你可以使用以下命令查看当前 jdk 的版本：\n\n$ java -version\njava version "1.8.0_31"\nJava(TM) SE Runtime Environment (build 1.8.0_31-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)\n编程风格\nJava 8 希望有自己的编程风格，并与 Java 7 区别开，以下实例展示了 Java 7 和 Java 8 的编程格式：\n\nJava8Tester.java 文件代码：\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n \npublic class Java8Tester {\n   public static void main(String args[]){\n   \n      List<String> names1 = new ArrayList<String>();\n      names1.add("Google ");\n      names1.add("Runoob ");\n      names1.add("Taobao ");\n      names1.add("Baidu ");\n      names1.add("Sina ");\n        \n      List<String> names2 = new ArrayList<String>();\n      names2.add("Google ");\n      names2.add("Runoob ");\n      names2.add("Taobao ");\n      names2.add("Baidu ");\n      names2.add("Sina ");\n        \n      Java8Tester tester = new Java8Tester();\n      System.out.println("使用 Java 7 语法: ");\n        \n      tester.sortUsingJava7(names1);\n      System.out.println(names1);\n      System.out.println("使用 Java 8 语法: ");\n        \n      tester.sortUsingJava8(names2);\n      System.out.println(names2);\n   }\n   \n   // 使用 java 7 排序\n   private void sortUsingJava7(List<String> names){   \n      Collections.sort(names, new Comparator<String>() {\n         @Override\n         public int compare(String s1, String s2) {\n            return s1.compareTo(s2);\n         }\n      });\n   }\n   \n   // 使用 java 8 排序\n   private void sortUsingJava8(List<String> names){\n      Collections.sort(names, (s1, s2) -> s1.compareTo(s2));\n   }\n}\n执行以上脚本，输出结果为：\n\n$ javac Java8Tester.java\n$ java Java8Tester\n使用 Java 7 语法: \n[Baidu , Google , Runoob , Sina , Taobao ]\n使用 Java 8 语法: \n[Baidu , Google , Runoob , Sina , Taobao ]\n接下来我们将详细为大家简介 Java 8 的新特性：\n\n序号\t特性\n1\tLambda 表达式\n2\t方法引用\n3\t函数式接口\n4\t默认方法\n5\tStream\n6\tOptional 类\n7\tNashorn, JavaScript 引擎\n8\t新的日期时间 API\n9\tBase64\n\n\npublic static void main(String[] args){\n        if("23".contains("2")){\n            System.out.println(true);\n        }else{\n            System.out.println(false);\n        }\n        List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);\n        System.out.println("转list"+numbers);\n        String str = "112,221";\n        String[] split = str.split(",");\n        StringBuilder sb= new StringBuilder();\n        Map<String,String> map = new HashMap<>(16);\n        map.put("112","你好");\n        map.put("221","我来了");\n        for (String vaues:split) {\n            String trval = map.get(vaues);\n            sb.append(trval+",");\n        }\n        String substring = sb.toString().substring(0, sb.toString().length() - 1);\n        System.out.println(substring);\n        Map<String,String> maps = new HashMap<>(16);\n        maps.put("key","你a好");\n        List<Map<String,String>> lists = new ArrayList<>();\n        lists.add(map);\n        lists.add(maps);\n        System.out.println(lists.stream().filter(items-> StringUtils.isNotEmpty(items.get("key"))).map(item->item.get("key")).collect(Collectors.joining(",")));\n        for (Map<String,String> sas:lists) {\n            sas.put("key","哈哈哈");\n        }\n        System.out.println(lists);\n        List<String> listss = new ArrayList();\n        listss.add("1111");\n        listss.add("2222");\n        listss.add("3333");\n        List<String> listsss = new ArrayList();\n        listsss.add("3333");\n        listsss.add("4444");\n        listsss.add("5555");\n        // 交集\n        List<String> intersection = listss.stream().filter(item -> listsss.contains(item)).collect(Collectors.toList());\n        System.out.println("2个交集："+intersection);\n        long count = intersection.parallelStream().filter(item -> item.equals("3333")).count();\n        System.out.println("个数："+count);\n        // 差集 (list1 - list2)\n        List<String> reduce1 = listss.stream().filter(item -> !listsss.contains(item)).collect(Collectors.toList());\n        System.out.println("2个差集1："+reduce1);\n        // 差集 (list2 - list1)\n        List<String> reduce2 = listsss.stream().filter(item -> !listss.contains(item)).collect(Collectors.toList());\n        System.out.println("2个差集2："+reduce2);\n        // 并集\n        List<String> listAll = listss.parallelStream().collect(Collectors.toList());\n        List<String> listAll2 = listsss.parallelStream().collect(Collectors.toList());\n        listAll.addAll(listAll2);\n        System.out.println("2个并集："+listAll);\n        // 去重并集\n        List<String> listAllDistinct = listAll.stream().distinct().collect(Collectors.toList());\n        System.out.println("集合去重："+listAllDistinct);\n        User user = new User();\n        User users = new User();\n        User userss = new User();\n        User usersss = new User();\n        List<User> list = new ArrayList<>();//3\n        Set<String> list1 = new HashSet<>();//2\n        Set<String> list2 = new HashSet<>();//2\n        Set<String> list3 = new HashSet<>();//2\n        Set<String> list4 = new HashSet<>();//1\n        user.setName("test");\n        user.setAge("10");\n        user.setPass("10");\n        user.setTotal(12);\n        users.setName("demo");\n        users.setAge("88");\n        users.setPass("88");\n        users.setTotal(12);\n        userss.setName("demo");\n        userss.setAge("66");\n        userss.setPass("66");\n        userss.setTotal(12);\n        usersss.setName("demo");\n        usersss.setAge("88");\n        usersss.setPass("88");\n        usersss.setTotal(12);\n        list.add(user);\n        list.add(users);\n        list.add(userss);\n        list.add(usersss);\n        //从list到User集合\n        List<User> dayDataList = list.stream().map(item -> {\n            User dayDataDto = new User();\n            dayDataDto.setAmount(new BigDecimal("12.21"));\n            return dayDataDto;\n        }).collect(Collectors.toList());\n        System.out.println("设置值："+dayDataList);\n        //满足noiseStatus=0的regionId前3个的集合\n        List<User> regionId = dayDataList.stream().filter(originalDto -> originalDto.getAmount()!=null).collect(Collectors.toList());\n        System.out.println("过滤amount不为null："+regionId);\n        List<String> stringList = list.parallelStream().map(User::getName).limit(3).collect(Collectors.toList());\n        System.out.println("只取前三个："+stringList);\n        List<User> name= list.stream().map(item -> item.getList().get(0)).collect(Collectors.toList());\n        System.out.println("只取第一个对象1："+name);\n        Optional<User> first = list.stream().findFirst();\n        System.out.println("只取第一个对象2："+first.get());\n        Set<String> stringSet = list.stream().map(userd -> userd.getAge()).collect(Collectors.toSet());\n        System.out.println("list转set一个字段："+stringSet);\n        Set<String> stringSets = list.stream().map(userd -> userd.getAge() + userd.getPass()).collect(Collectors.toSet());\n        System.out.println("list转set字段拼接："+stringSets);\n        List<String> listNos = Arrays.asList("3232");\n        for(int i = 0; i < listNos.size() / 2f; i++) {\n            int fromIndex = 2 * i;\n            int toIndex = 2 * (i + 1);\n            if (toIndex > listNos.size()) {\n                toIndex = listNos.size();\n            }\n            List<String> listNoUpdates = listNos.subList(fromIndex, toIndex);\n            System.out.println("每2条更想"+listNoUpdates);\n        }\n        Integer times = (3 + 100 - 1) / 100;\n        for (int i = 0;i < times;i ++) {\n            System.out.println(times);\n        }\n//        System.out.println(list);\n//        Map<String,String> userMap1 = list.stream().collect(Collectors.toMap(User::getAge,User::getName));\n//        System.out.println("list转map字段："+userMap1);\n        //        Set<String> collect1 = list.parallelStream().map(User::getAge).collect(Collectors.toSet());\n//        Set<String> collect2 = list.parallelStream().map(User::getPass).collect(Collectors.toSet());\n//        Set<String> collect3 = list.parallelStream().map(us -> (us.getPass() + "," + us.getAge())).collect(Collectors.toSet());\n//       list.forEach(item->{\n//           if(listMap.get(item.getDescriptions()).size()>1){\n//               item.setDescription("导入文件中成品料号+料件料号+单耗版本号不能重复!");\n//           }\n//       });\n//        if(list!=null || list.size()>0){\n//            if(list.size()==1){\n//                User hxDcrConsume = (User) list.get(0);\n//                list1.add(hxDcrConsume.getName());\n//                list2.add(hxDcrConsume.getAge());\n//                String primaryKey = hxDcrConsume.getName() + hxDcrConsume.getAge() + hxDcrConsume.getPass();\n//                list3.add(primaryKey);\n//                list4.add(primaryKey);\n//            }else{\n//                for (int i = 0; i < list.size(); i++) {\n//                    User hxDcrConsume = (User) list.get(i);\n//                    String primaryKey = hxDcrConsume.getName() + hxDcrConsume.getAge() + hxDcrConsume.getPass();\n//                    list1.add(hxDcrConsume.getName());\n//                    list2.add(hxDcrConsume.getAge());\n//                    list3.add(primaryKey);\n//                    for (int j = i + 1; j < list.size(); j++) {\n//                        User hxDcrConsumeNet = (User) list.get(j);\n//                        String primaryKeyNet = hxDcrConsumeNet.getName() + hxDcrConsumeNet.getAge() + hxDcrConsumeNet.getPass();\n//                        if(primaryKey.equals(primaryKeyNet)){\n//                            hxDcrConsume.setDescription("|导入文件中成品料号+料件料号+单耗版本号不能重复!");\n//                            hxDcrConsumeNet.setDescription("|导入文件中成品料号+料件料号+单耗版本号不能重复!");\n//                            list4.add(primaryKeyNet);\n//                        }\n//                    }\n//                }\n//            }\n//        }\n//        System.out.println(list);\n        String strS = "asfaisfasasiaisdl$$flsflsalkfslkfslkfkaslk";\n        strS = strS.replace("$$","&&");\n        String[] splitS = strS.split("&&");\n        System.out.println("包含几个字段"+splitS.length);\n        lists.stream().filter(clcb -> !clcb.isEmpty()).count();\n        lists.stream().filter(clcb -> !clcb.isEmpty()).collect(Collectors.toSet());\n        System.out.print(lists.size());\n       Map<Integer, String> mapssss = list.stream().collect(Collectors.toMap(User::getTotal, User::getName, (key1, key2) -> key2));\n        System.out.println("list转map字段1："+mapssss);\n        Map<Integer, String> userMap1 = new HashMap<>();\n        for (User userList : list) {\n            userMap1.put(userList.getTotal(), userList.getName());\n        }\n        System.out.println("list转map字段2："+userMap1);\n        Map<Integer, String> mapsssss = list.stream().collect(Collectors.toMap(User :: getTotal, p -> p.getName()));\n        System.out.println("list转map字段3："+userMap1);\n        Map<Integer,User> userMap4 = list.stream().collect(Collectors.toMap(User::getTotal, Function.identity(),(key1, key2)->key2));\n        System.out.println("list转map对象："+userMap4);\n        list.forEach(usersssss -> {System.out.println(usersssss);});\n        Map<Integer, Long> appTradeNum = list.stream().collect(Collectors.groupingBy(User::getTotal, Collectors.counting()));\n        System.out.println("统计分组个数"+appTradeNum);\n        Map<Integer, Long> appTradeNums = list.stream().collect(Collectors.groupingBy(User::getTotal, Collectors.summingLong(User::getTotal)));\n        System.out.println("统计分组求和"+appTradeNums);\n        list.stream().sorted(Comparator.comparing(User::getName)) .collect(Collectors.toList());\n        System.out.println("排序集合"+list);\n        // 用于收集统计数据的状态对象，例如count，min，max，sum和平均。\n        IntSummaryStatistics stats = list.stream().mapToInt((user1) -> user1.getTotal()).summaryStatistics();\n        System.out.println("最大Max : " + stats.getMax());\n        System.out.println("最小Min: " + stats.getMin());\n        System.out.println("求和Sun: " + stats.getSum());\n        System.out.println("平均数Average : " + stats.getAverage());\n        System.out.println("个数Count : " + stats.getCount());\n        System.out.println("转字符串toString : " + stats.toString());\n        int intObjectListSize = list.size();\n        Set<String> sets = new HashSet<>(intObjectListSize);\n        Map<String, List<User>> listMap = list.stream().map(item -> {\n            item.setDescriptions(item.getAge() + item.getPass());\n            if(sets.contains(item.getDescriptions())){\n                item.setDescription("导入文件中成品料号+料件料号+单耗版本号不能重复!");\n            }\n            sets.add(item.getDescriptions());\n            return item;\n        }).collect(Collectors.groupingBy(User::getDescriptions));\n        System.out.println("list转map分组："+listMap);\n        list.parallelStream().filter(ss->{\n            if(listMap.containsKey(ss.getDescriptions())){\n                if(listMap.get(ss.getDescriptions()).size()>1){\n                    ss.setDescription("导入文件中成品料号+料件料号+单耗版本号不能重复!");\n                }\n                return true;\n            }else{\n                return false;\n            }\n        }).collect(Collectors.toList());\n        System.out.println("list校验集合："+list);\n        List<User> listBySids = list;\n        List<User> collectNot = listBySids.parallelStream().filter(item -> StringUtils.isNotEmpty(item.getDescriptions())).collect(Collectors.toList());\n        List<User> collect = listBySids.parallelStream().filter(item -> StringUtils.isEmpty(item.getDescriptions())).collect(Collectors.toList());\n        List<String> dctimesStr = collectNot.parallelStream().map(item->item.getDescription()!=null?item.getDescription().toString():"").collect(Collectors.toList());\n        List<String> sidStrs = collect.parallelStream().map(User::getAge).collect(Collectors.toList());\n        String mergeString = dctimesStr.parallelStream().filter(string -> !string.isEmpty()).collect(Collectors.joining("、"));\n        User user1 = new User();\n        List<String> sids = new ArrayList<>();\n        if(StringUtils.isNotEmpty(mergeString)) {\n            user1.setDescription("报核次数" + mergeString + "已开始报核无需启用提醒");\n            sids = sidStrs;\n            if (sidStrs.size() > 0) {\n                System.out.println("启动集合1："+ JSON.toJSONString(sids, SerializerFeature.WriteNullStringAsEmpty));\n            }else{\n                System.out.println("启动集合2："+ JSON.toJSONString(sids, SerializerFeature.WriteNullStringAsEmpty));\n            }\n        }\n    }\n\n')])])])])}),[],!1,null,null,null);s.default=i.exports}}]);