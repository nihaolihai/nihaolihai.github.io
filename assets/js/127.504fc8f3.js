(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{616:function(n,t,e){"use strict";e.r(t);var a=e(6),r=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"java-日期时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-日期时间"}},[n._v("#")]),n._v(" Java 日期时间")]),n._v(" "),e("p",[n._v("java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。")]),n._v(" "),e("p",[n._v("第一个构造函数使用当前日期和时间来初始化对象。")]),n._v(" "),e("p",[n._v("Date( )\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。")]),n._v(" "),e("p",[n._v("Date(long millisec)\nDate对象创建以后，可以调用下面的方法。")]),n._v(" "),e("p",[n._v("序号\t方法和描述\n1\tboolean after(Date date)\n若当调用此方法的Date对象在指定日期之后返回true,否则返回false。\n2\tboolean before(Date date)\n若当调用此方法的Date对象在指定日期之前返回true,否则返回false。\n3\tObject clone( )\n返回此对象的副本。\n4\tint compareTo(Date date)\n比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。\n5\tint compareTo(Object obj)\n若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。\n6\tboolean equals(Object date)\n当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。\n7\tlong getTime( )\n返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。\n8\tint hashCode( )\n返回此对象的哈希码值。\n9\tvoid setTime(long time)")]),n._v(" "),e("p",[n._v("用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。\n10\tString toString( )\n把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。\n获取当前日期时间\nJava中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.Date;")]),n._v(" "),e("p",[n._v("public class DateDemo {\npublic static void main(String args[]) {\n// 初始化 Date 对象\nDate date = new Date();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("   // 使用 toString() 函数显示日期时间\n   System.out.println(date.toString());\n")])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("Mon May 04 09:51:52 CDT 2013\n日期比较\nJava使用以下三种方法来比较两个日期：")]),n._v(" "),e("p",[n._v("使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。\n使用 SimpleDateFormat 格式化日期\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：")]),n._v(" "),e("p",[n._v("实例\nimport  java.util."),e("em",[n._v(";\nimport java.text.")]),n._v(";")]),n._v(" "),e("p",[n._v("public class DateDemo {\npublic static void main(String args[]) {")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('  Date dNow = new Date( );\n  SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");\n\n  System.out.println("当前时间为: " + ft.format(dNow));\n')])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v('运行实例 »\nSimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");\n这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。')]),n._v(" "),e("p",[n._v("注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。")]),n._v(" "),e("p",[n._v("以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("当前时间为: 2018-09-06 10:16:34\n日期和时间的格式化编码\n时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：")]),n._v(" "),e("p",[n._v("字母\t描述\t示例\nG\t纪元标记\tAD\ny\t四位年份\t2001\nM\t月份\tJuly or 07\nd\t一个月的日期\t10\nh\t A.M./P.M. (1~12)格式小时\t12\nH\t一天中的小时 (0~23)\t22\nm\t分钟数\t30\ns\t秒数\t55\nS\t毫秒数\t234\nE\t星期几\tTuesday\nD\t一年中的日子\t360\nF\t一个月中第几周的周几\t2 (second Wed. in July)\nw\t一年中第几周\t40\nW\t一个月中第几周\t1\na\tA.M./P.M. 标记\tPM\nk\t一天中的小时(1~24)\t24\nK\t A.M./P.M. (0~11)格式小时\t10\nz\t时区\tEastern Standard Time\n'\t文字定界符\tDelimiter\n\"\t单引号\t`\n使用printf格式化日期\nprintf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。")]),n._v(" "),e("p",[n._v("转  换  符")]),n._v(" "),e("p",[n._v("说    明")]),n._v(" "),e("p",[n._v("示    例")]),n._v(" "),e("p",[n._v("c")]),n._v(" "),e("p",[n._v("包括全部日期和时间信息")]),n._v(" "),e("p",[n._v("星期六 十月 27 14:21:20 CST 2007")]),n._v(" "),e("p",[n._v("F")]),n._v(" "),e("p",[n._v('"年-月-日"格式')]),n._v(" "),e("p",[n._v("2007-10-27")]),n._v(" "),e("p",[n._v("D")]),n._v(" "),e("p",[n._v('"月/日/年"格式')]),n._v(" "),e("p",[n._v("10/27/07")]),n._v(" "),e("p",[n._v("r")]),n._v(" "),e("p",[n._v('"HH:MM:SS PM"格式（12时制）')]),n._v(" "),e("p",[n._v("02:25:51 下午")]),n._v(" "),e("p",[n._v("T")]),n._v(" "),e("p",[n._v('"HH:MM:SS"格式（24时制）')]),n._v(" "),e("p",[n._v("14:28:16")]),n._v(" "),e("p",[n._v("R")]),n._v(" "),e("p",[n._v('"HH:MM"格式（24时制）')]),n._v(" "),e("p",[n._v("14:28")]),n._v(" "),e("p",[n._v("更多 printf 解析可以参见：Java 格式化输出 printf 例子")]),n._v(" "),e("p",[n._v("实例\n实例\nimport java.util.Date;")]),n._v(" "),e("p",[n._v("public class DateDemo {")]),n._v(" "),e("p",[n._v("public static void main(String args[]) {\n// 初始化 Date 对象\nDate date = new Date();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v(' //c的使用  \nSystem.out.printf("全部日期和时间信息：%tc%n",date);          \n//f的使用  \nSystem.out.printf("年-月-日格式：%tF%n",date);  \n//d的使用  \nSystem.out.printf("月/日/年格式：%tD%n",date);  \n//r的使用  \nSystem.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);  \n//t的使用  \nSystem.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);  \n//R的使用  \nSystem.out.printf("HH:MM格式（24时制）：%tR",date);  \n')])])]),e("p",[n._v("}\n}\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012"),e("br"),n._v("\n年-月-日格式：2012-09-10"),e("br"),n._v("\n月/日/年格式：09/10/12"),e("br"),n._v("\nHH:MM:SS PM格式（12时制）：10:43:36 上午"),e("br"),n._v("\nHH:MM:SS格式（24时制）：10:43:36"),e("br"),n._v("\nHH:MM格式（24时制）：10:43"),e("br"),n._v("\n如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。")]),n._v(" "),e("p",[n._v("索引必须紧跟在%后面，而且必须以$结束。例如：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.Date;")]),n._v(" "),e("p",[n._v("public class DateDemo {")]),n._v(" "),e("p",[n._v("public static void main(String args[]) {\n// 初始化 Date 对象\nDate date = new Date();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('   // 使用toString()显示日期和时间\n   System.out.printf("%1$s %2$tB %2$td, %2$tY", \n                     "Due date:", date);\n')])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("Due date: February 09, 2014\n或者，你可以使用 < 标志。它表明先前被格式化的参数要被再次使用。例如：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.Date;")]),n._v(" "),e("p",[n._v("public class DateDemo {")]),n._v(" "),e("p",[n._v("public static void main(String args[]) {\n// 初始化 Date 对象\nDate date = new Date();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('   // 显示格式化时间\n   System.out.printf("%s %tB %<te, %<tY", \n                     "Due date:", date);\n')])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("Due date: February 09, 2014\n定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如下所示：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.*;")]),n._v(" "),e("p",[n._v("public class DateDemo {\npublic static void main(String args[]) {\nDate date=new Date();"),e("br"),n._v("\n//b的使用，月份简称"),e("br"),n._v('\nString str=String.format(Locale.US,"英文月份简称：%tb",date);'),e("br"),n._v("\nSystem.out.println(str);"),e("br"),n._v('\nSystem.out.printf("本地月份简称：%tb%n",date);'),e("br"),n._v("\n//B的使用，月份全称"),e("br"),n._v('\nstr=String.format(Locale.US,"英文月份全称：%tB",date);'),e("br"),n._v("\nSystem.out.println(str);"),e("br"),n._v('\nSystem.out.printf("本地月份全称：%tB%n",date);'),e("br"),n._v("\n//a的使用，星期简称"),e("br"),n._v('\nstr=String.format(Locale.US,"英文星期的简称：%ta",date);'),e("br"),n._v("\nSystem.out.println(str);"),e("br"),n._v("\n//A的使用，星期全称"),e("br"),n._v('\nSystem.out.printf("本地星期的简称：%tA%n",date);'),e("br"),n._v("\n//C的使用，年前两位"),e("br"),n._v('\nSystem.out.printf("年的前两位数字（不足两位前面补0）：%tC%n",date);'),e("br"),n._v("\n//y的使用，年后两位"),e("br"),n._v('\nSystem.out.printf("年的后两位数字（不足两位前面补0）：%ty%n",date);'),e("br"),n._v("\n//j的使用，一年的天数"),e("br"),n._v('\nSystem.out.printf("一年中的天数（即年的第几天）：%tj%n",date);'),e("br"),n._v("\n//m的使用，月份"),e("br"),n._v('\nSystem.out.printf("两位数字的月份（不足两位前面补0）：%tm%n",date);'),e("br"),n._v("\n//d的使用，日（二位，不够补零）"),e("br"),n._v('\nSystem.out.printf("两位数字的日（不足两位前面补0）：%td%n",date);'),e("br"),n._v("\n//e的使用，日（一位不补零）"),e("br"),n._v('\nSystem.out.printf("月份的日（前面不补0）：%te",date);'),e("br"),n._v("\n}\n}\n输出结果为：")]),n._v(" "),e("p",[n._v("英文月份简称：May\n本地月份简称：五月\n英文月份全称：May\n本地月份全称：五月\n英文星期的简称：Thu\n本地星期的简称：星期四\n年的前两位数字（不足两位前面补0）：20\n年的后两位数字（不足两位前面补0）：17\n一年中的天数（即年的第几天）：124\n两位数字的月份（不足两位前面补0）：05\n两位数字的日（不足两位前面补0）：04\n月份的日（前面不补0）：4\n解析字符串为时间\nSimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：")]),n._v(" "),e("p",[n._v("实例\nimport java.util."),e("em",[n._v(";\nimport java.text.")]),n._v(";")]),n._v(" "),e("p",[n._v("public class DateDemo {")]),n._v(" "),e("p",[n._v('public static void main(String args[]) {\nSimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd");')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('  String input = args.length == 0 ? "1818-11-11" : args[0]; \n\n  System.out.print(input + " Parses as "); \n\n  Date t; \n\n  try { \n      t = ft.parse(input); \n      System.out.println(t); \n  } catch (ParseException e) { \n      System.out.println("Unparseable using " + ft); \n  }\n')])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("$ java DateDemo\n1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818\n$ java DateDemo 2007-12-01\n2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007\nJava 休眠(sleep)\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。")]),n._v(" "),e("p",[n._v("你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.*;")]),n._v(" "),e("p",[n._v('public class SleepDemo {\npublic static void main(String args[]) {\ntry {\nSystem.out.println(new Date( ) + "\\n");\nThread.sleep(1000*3);   // 休眠3秒\nSystem.out.println(new Date( ) + "\\n");\n} catch (Exception e) {\nSystem.out.println("Got an exception!");\n}\n}\n}')]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("Thu Sep 17 10:20:30 CST 2015")]),n._v(" "),e("p",[n._v("Thu Sep 17 10:20:33 CST 2015\n测量时间\n下面的一个例子表明如何测量时间间隔（以毫秒为单位）：")]),n._v(" "),e("p",[n._v("实例\nimport java.util.*;")]),n._v(" "),e("p",[n._v("public class DiffDemo {")]),n._v(" "),e("p",[n._v('public static void main(String args[]) {\ntry {\nlong start = System.currentTimeMillis( );\nSystem.out.println(new Date( ) + "\\n");\nThread.sleep(5'),e("em",[n._v("60")]),n._v('10);\nSystem.out.println(new Date( ) + "\\n");\nlong end = System.currentTimeMillis( );\nlong diff = end - start;\nSystem.out.println("Difference is : " + diff);\n} catch (Exception e) {\nSystem.out.println("Got an exception!");\n}\n}\n}')]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下:")]),n._v(" "),e("p",[n._v("Fri Jan 08 09:48:47 CST 2016")]),n._v(" "),e("p",[n._v("Fri Jan 08 09:48:50 CST 2016")]),n._v(" "),e("p",[n._v("Difference is : 3019\nCalendar类\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。")]),n._v(" "),e("p",[n._v("Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。")]),n._v(" "),e("p",[n._v("Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。")]),n._v(" "),e("p",[n._v("创建一个代表系统当前日期的Calendar对象\nCalendar c = Calendar.getInstance();//默认是当前日期\n创建一个指定日期的Calendar对象\n使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。")]),n._v(" "),e("p",[n._v("//创建一个代表2009年6月12日的Calendar对象\nCalendar c1 = Calendar.getInstance();\nc1.set(2009, 6 - 1, 12);\nCalendar类对象字段类型\nCalendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想")]),n._v(" "),e("p",[n._v("常量\t描述\nCalendar.YEAR\t年份\nCalendar.MONTH\t月份\nCalendar.DATE\t日期\nCalendar.DAY_OF_MONTH\t日期，和上面的字段意义完全相同\nCalendar.HOUR\t12小时制的小时\nCalendar.HOUR_OF_DAY\t24小时制的小时\nCalendar.MINUTE\t分钟\nCalendar.SECOND\t秒\nCalendar.DAY_OF_WEEK\t星期几\nCalendar类对象信息的设置\nSet设置")]),n._v(" "),e("p",[n._v("如：")]),n._v(" "),e("p",[n._v("Calendar c1 = Calendar.getInstance();\n调用：")]),n._v(" "),e("p",[n._v("public final void set(int year,int month,int date)\nc1.set(2009, 6, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12\n利用字段类型设置")]),n._v(" "),e("p",[n._v("如果只设定某个字段，例如日期的值，则可以使用如下set方法：")]),n._v(" "),e("p",[n._v("public void set(int field,int value)\n把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算")]),n._v(" "),e("p",[n._v("c1.set(Calendar.DATE,10);\n把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算")]),n._v(" "),e("p",[n._v("c1.set(Calendar.YEAR,2008);\n其他字段属性set的意义以此类推")]),n._v(" "),e("p",[n._v("Add设置")]),n._v(" "),e("p",[n._v("Calendar c1 = Calendar.getInstance();\n把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算")]),n._v(" "),e("p",[n._v("c1.add(Calendar.DATE, 10);\n把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算")]),n._v(" "),e("p",[n._v("c1.add(Calendar.DATE, -10);\n其他字段属性的add的意义以此类推")]),n._v(" "),e("p",[n._v("Calendar类对象信息的获得\nCalendar c1 = Calendar.getInstance();\n// 获得年份\nint year = c1.get(Calendar.YEAR);\n// 获得月份\nint month = c1.get(Calendar.MONTH) + 1;\n// 获得日期\nint date = c1.get(Calendar.DATE);\n// 获得小时\nint hour = c1.get(Calendar.HOUR_OF_DAY);\n// 获得分钟\nint minute = c1.get(Calendar.MINUTE);\n// 获得秒\nint second = c1.get(Calendar.SECOND);\n// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）\nint day = c1.get(Calendar.DAY_OF_WEEK);\nGregorianCalendar类\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。")]),n._v(" "),e("p",[n._v("Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。")]),n._v(" "),e("p",[n._v("下面列出GregorianCalendar对象的几个构造方法：")]),n._v(" "),e("p",[n._v("序号\t构造函数和说明\n1\tGregorianCalendar()\n在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。\n2\tGregorianCalendar(int year, int month, int date)\n在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar\n3\tGregorianCalendar(int year, int month, int date, int hour, int minute)\n为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。\n4\tGregorianCalendar(int year, int month, int date, int hour, int minute, int second)\n为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。\n5\tGregorianCalendar(Locale aLocale)\n在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。\n6\tGregorianCalendar(TimeZone zone)\n在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。\n7\tGregorianCalendar(TimeZone zone, Locale aLocale)\n在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。\n这里是GregorianCalendar 类提供的一些有用的方法列表：")]),n._v(" "),e("p",[n._v("序号\t方法和说明\n1\tvoid add(int field, int amount)\n根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。\n2\tprotected void computeFields()\n转换UTC毫秒值为时间域值\n3\tprotected void computeTime()\n覆盖Calendar ，转换时间域值为UTC毫秒值\n4\tboolean equals(Object obj)\n比较此 GregorianCalendar 与指定的 Object。\n5\tint get(int field)\n获取指定字段的时间值\n6\tint getActualMaximum(int field)\n返回当前日期，给定字段的最大值\n7\tint getActualMinimum(int field)\n返回当前日期，给定字段的最小值\n8\tint getGreatestMinimum(int field)\n返回此 GregorianCalendar 实例给定日历字段的最高的最小值。\n9\tDate getGregorianChange()\n获得格里高利历的更改日期。\n10\tint getLeastMaximum(int field)\n返回此 GregorianCalendar 实例给定日历字段的最低的最大值\n11\tint getMaximum(int field)\n返回此 GregorianCalendar 实例的给定日历字段的最大值。\n12\tDate getTime()\n获取日历当前时间。\n13\tlong getTimeInMillis()\n获取用长整型表示的日历的当前时间\n14\tTimeZone getTimeZone()\n获取时区。\n15\tint getMinimum(int field)\n返回给定字段的最小值。\n16\tint hashCode()\n重写hashCode.\n17\tboolean isLeapYear(int year)\n确定给定的年份是否为闰年。\n18\tvoid roll(int field, boolean up)\n在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。\n19\tvoid set(int field, int value)\n用给定的值设置时间字段。\n20\tvoid set(int year, int month, int date)\n设置年、月、日的值。\n21\tvoid set(int year, int month, int date, int hour, int minute)\n设置年、月、日、小时、分钟的值。\n22\tvoid set(int year, int month, int date, int hour, int minute, int second)\n设置年、月、日、小时、分钟、秒的值。\n23\tvoid setGregorianChange(Date date)\n设置 GregorianCalendar 的更改日期。\n24\tvoid setTime(Date date)\n用给定的日期设置Calendar的当前时间。\n25\tvoid setTimeInMillis(long millis)\n用给定的long型毫秒数设置Calendar的当前时间。\n26\tvoid setTimeZone(TimeZone value)\n用给定时区值设置当前时区。\n27\tString toString()\n返回代表日历的字符串。\n实例\n实例\nimport java.util.*;")]),n._v(" "),e("p",[n._v("public class GregorianCalendarDemo {")]),n._v(" "),e("p",[n._v('public static void main(String args[]) {\nString months[] = {\n"Jan", "Feb", "Mar", "Apr",\n"May", "Jun", "Jul", "Aug",\n"Sep", "Oct", "Nov", "Dec"};')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('  int year;\n  // 初始化 Gregorian 日历\n  // 使用当前时间和日期\n  // 默认为本地时间和时区\n  GregorianCalendar gcalendar = new GregorianCalendar();\n  // 显示当前时间和日期的信息\n  System.out.print("Date: ");\n  System.out.print(months[gcalendar.get(Calendar.MONTH)]);\n  System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");\n  System.out.println(year = gcalendar.get(Calendar.YEAR));\n  System.out.print("Time: ");\n  System.out.print(gcalendar.get(Calendar.HOUR) + ":");\n  System.out.print(gcalendar.get(Calendar.MINUTE) + ":");\n  System.out.println(gcalendar.get(Calendar.SECOND));\n  \n  // 测试当前年份是否为闰年\n  if(gcalendar.isLeapYear(year)) {\n     System.out.println("当前年份是闰年");\n  }\n  else {\n     System.out.println("当前年份不是闰年");\n  }\n')])])]),e("p",[n._v("}\n}")]),n._v(" "),e("p",[n._v("运行实例 »\n以上实例编译运行结果如下：")]),n._v(" "),e("p",[n._v("Date: Apr 22 2009\nTime: 11:25:27\n当前年份不是闰年\n关于 Calender 类的完整列表，你可以参考标准的 Java文档。")]),n._v(" "),e("p",[n._v("Java 数组Java 正则表达式\n2 篇笔记 写笔记\n妇芳单身骗")]),n._v(" "),e("p",[n._v("lhm***@126.com")]),n._v(" "),e("p",[n._v("136\nCalender的月份是从0开始的，但日期和年份是从1开始的")]),n._v(" "),e("p",[n._v("示例代码：")]),n._v(" "),e("p",[n._v("import java.util.Calendar;")]),n._v(" "),e("p",[n._v('public class Test {\npublic static void main(String[] args) {\nCalendar c1 = Calendar.getInstance();\nc1.set(2017, 1, 1);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\nc1.set(2017, 1, 0);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\n}\n}\n运行结果：')]),n._v(" "),e("p",[n._v("2017-1-1\n2017-0-31\n可见，将日期设为0以后，月份变成了上个月，但月份可以为0")]),n._v(" "),e("p",[n._v("把月份改为2试试：")]),n._v(" "),e("p",[n._v("import java.util.Calendar;")]),n._v(" "),e("p",[n._v('public class Test {\npublic static void main(String[] args) {\nCalendar c1 = Calendar.getInstance();\nc1.set(2017, 2, 1);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\nc1.set(2017, 2, 0);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\n}\n}\n运行结果：')]),n._v(" "),e("p",[n._v("2017-2-1\n2017-1-28\n可以看到上个月的最后一天是28号，所以Calendar.MONTH为1的时候是2月")]),n._v(" "),e("p",[n._v("既然日期设为0表示上个月的最后一天，那是不是可以设为负数呢？")]),n._v(" "),e("p",[n._v("import java.util.Calendar;")]),n._v(" "),e("p",[n._v('public class Test {\npublic static void main(String[] args) {\nCalendar c1 = Calendar.getInstance();\nc1.set(2017, 2, 1);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\nc1.set(2017, 2, -10);\nSystem.out.println(c1.get(Calendar.YEAR)\n+"-"+c1.get(Calendar.MONTH)\n+"-"+c1.get(Calendar.DATE));\n}\n}\n运行结果：')]),n._v(" "),e("p",[n._v("2017-2-1\n2017-1-18\n果然可以，所以日期才可以自由加减。")]),n._v(" "),e("p",[n._v("月份也可以是负数，规则与日期一样，就不上代码了。")]),n._v(" "),e("p",[n._v("实测将年份设为非正数时，会自动变为绝对值+1，不知其意义。")]),n._v(" "),e("p",[n._v("妇芳单身骗\n妇芳单身骗")]),n._v(" "),e("p",[n._v("lhm***@126.com")]),n._v(" "),e("p",[n._v("3年前 (2017-11-22)\n冲冲冲")]),n._v(" "),e("p",[n._v("173***2867@qq.com")]),n._v(" "),e("p",[n._v("4\nimport java.util.Date;")]),n._v(" "),e("p",[n._v("public class DateDemo {")]),n._v(" "),e("p",[n._v("public static void main(String args[]) {\n// 初始化 Date 对象\nDate date = new Date();")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v(' //c的使用  \nSystem.out.printf("全部日期和时间信息：%tc%n",date);          \n//f的使用  \nSystem.out.printf("年-月-日格式：%tF%n",date);  \n//d的使用  \nSystem.out.printf("月/日/年格式：%tD%n",date);  \n//r的使用  \nSystem.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);  \n//t的使用  \nSystem.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);  \n//R的使用  \nSystem.out.printf("HH:MM格式（24时制）：%tR",date);  \n')])])]),e("p",[n._v("}\n}\n输出结果为：")]),n._v(" "),e("p",[n._v("全部日期和时间信息：周六 8月 22 11:53:36 CST 2020\n年-月-日格式：2020-08-22\n月/日/年格式：08/22/20\nHH:MM:SS PM格式（12时制）：11:53:36 上午\nHH:MM:SS格式（24时制）：11:53:36\nHH:MM格式（24时制）：11:53")])])}),[],!1,null,null,null);t.default=r.exports}}]);