(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{862:function(e,t,n){"use strict";n.r(t);var s=n(6),r=Object(s.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"resttemplate调用前统一申请token传递到调用的服务中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#resttemplate调用前统一申请token传递到调用的服务中"}},[this._v("#")]),this._v(" RestTemplate调用前统一申请Token传递到调用的服务中")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('如果项目中用的 RestTemplate 来调用服务提供的接口，可以利用 RestTemplate 的拦截器来传递 Token，代码如下所示。\n@Component\npublic class TokenInterceptor implements ClientHttpRequestInterceptor {\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)\n            throws IOException {\n        System.err.println("进入RestTemplate拦截器");\n        HttpHeaders headers = request.getHeaders();\n        headers.add("Authorization", System.getProperty("fangjia.auth.token"));\n        return execution.execute(request, body);\n    }\n}\n将拦截器注入 RestTemplate，代码如下所示。\n纯文本复制\n@Configuration\npublic class BeanConfiguration {\n    @Autowired\n    private TokenInterceptor tokenInterceptor;\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(Collections.singletonList(tokenInterceptor));\n        return restTemplate;\n    }\n}\n\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);