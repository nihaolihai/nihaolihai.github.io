(window.webpackJsonp=window.webpackJsonp||[]).push([[345],{838:function(e,t,n){"use strict";n.r(t);var r=n(6),s=Object(r.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h2",{attrs:{id:"spring-cloud-zuul请求响应信息输出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-zuul请求响应信息输出"}},[this._v("#")]),this._v(" Spring Cloud Zuul请求响应信息输出")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('系统在生产环境出现问题时，排查问题最好的方式就是查看日志了，日志的记录尽量详细，这样你才能快速定位问题。\n\n下面带大家学习如何在 Zuul 中输出请求响应的信息来辅助我们解决一些问题。\n\n熟悉 Zuul 的朋友都知道，Zuul 中有 4 种类型过滤器，每种都有特定的使用场景，要想记录响应数据，那么必须是在请求路由到了具体的服务之后，返回了才有数据，这种需求就适合用 post 过滤器来实现了。代码如下所示。\nHttpServletRequest req = (HttpServletRequest) RequestContext.getCurrentContext().getRequest();\nSystem.err.println("REQUEST:: " + req.getScheme() + " " + req.getRemoteAddr() + ":" + req.getRemotePort());\nStringBuilder params = new StringBuilder("?");\n// 获取URL参数\nEnumeration<String> names = req.getParameterNames();\nif (req.getMethod().equals("GET")) {\n    while (names.hasMoreElements()) {\n        String name = (String) names.nextElement();\n        params.append(name);\n        params.append("=");\n        params.append(req.getParameter(name));\n        params.append("&");\n    }\n}\nif (params.length() > 0) {\n    params.delete(params.length() - 1, params.length());\n}\nSystem.err.println(\n        "REQUEST:: > " + req.getMethod() + " " + req.getRequestURI() + params + " " + req.getProtocol());\nEnumeration<String> headers = req.getHeaderNames();\nwhile (headers.hasMoreElements()) {\n    String name = (String) headers.nextElement();\n    String value = req.getHeader(name);\n    System.err.println("REQUEST:: > " + name + ":" + value);\n}\nfinal RequestContext ctx = RequestContext.getCurrentContext();\n// 获取请求体参数\nif (!ctx.isChunkedRequestBody()) {\n    ServletInputStream inp = null;\n    try {\n        inp = ctx.getRequest().getInputStream();\n        String body = null;\n        if (inp != null) {\n            body = IOUtils.toString(inp);\n            System.err.println("REQUEST:: > " + body);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n输出效果如图 1 所示。\n\n控制器输出效果\n图 1  控制器输出效果\n获取响应内容的第一种方式，代码如下所示。\ntry {\n    Object zuulResponse = RequestContext.getCurrentContext().get("zuulResponse");\n    if (zuulResponse != null) {\n        RibbonHttpResponse resp = (RibbonHttpResponse) zuulResponse;\n        String body = IOUtils.toString(resp.getBody());\n        System.err.println("RESPONSE:: > " + body);\n        resp.close();\n        RequestContext.getCurrentContext().setResponseBody(body);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n获取响应内容的第二种方式，代码如下所示。\npublic static void main(String[] args) {\n    InputStream stream = RequestContext.getCurrentContext().getResponseDataStream();\n    try {\n        if (stream != null) {\n            String body = IOUtils.toString(stream);\n            System.err.println("RESPONSE:: > " + body);\n            RequestContext.getCurrentContext().setResponseBody(body);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n为什么上面两种方式可以取到响应内容？\n\n在 RibbonRoutingFilter 或者 SimpleHostRoutingFilter 中可以看到下面一段代码，代码如下所示。\npublic Object run() {\n    RequestContext context = RequestContext.getCurrentContext();\n    this.helper.addIgnoredHeaders();\n    try {\n        RibbonCommandContext commandContext = buildCommandContext(context);\n        ClientHttpResponse response = forward(commandContext);\n        setResponse(response);\n        return response;\n    } catch (ZuulException ex) {\n        throw new ZuulRuntimeException(ex);\n    } catch (Exception ex) {\n        throw new ZuulRuntimeException(ex);\n    }\n}\nforward() 方法对服务调用，拿到响应结果，通过 setResponse() 方法进行响应的设置，代码如下所示。\nprotected void setResponse(ClientHttpResponse resp) throws ClientException, IOException {\n    RequestContext.getCurrentContext().set("zuulResponse", resp);\n    this.helper.setResponse(resp.getStatusCode().value(), resp.getBody() == null ? null : resp.getBody(),\n            resp.getHeaders());\n}\n上面第一行代码就可以解释我们的第一种获取的方法，这里直接把响应内容加到了 RequestContext 中。\n\n第二种方式的解释就在 helper.setResponse 的逻辑里面了，代码如下所示。\n纯文本复制\npublic void setResponse(int status, InputStream entity, MultiValueMap<String, String> headers) throws IOException {\n    RequestContext context = RequestContext.getCurrentContext();\n    context.setResponseStatusCode(status);\n    if (entity != null) {\n        context.setResponseDataStream(entity);\n    }\n    // .....\n}\n\n')])])]),t("p",[t("img",{attrs:{src:"http://c.biancheng.net/uploads/allimg/190826/5-1ZR6092R4929.png",alt:"RUNOOB 图标"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);