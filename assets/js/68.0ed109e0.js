(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{555:function(t,s,a){"use strict";a.r(s);var n=a(6),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"条例5-依赖注入优于硬连接资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条例5-依赖注入优于硬连接资源"}},[t._v("#")]),t._v(" 条例5： 依赖注入优于硬连接资源")]),t._v(" "),a("div",{staticStyle:{"text-align":"right"}},[t._v("翻译于2020-12-2")]),t._v("\n许多类依赖于一个或多个底层资源。比如，拼写检查依赖于字典。这样的类时限为静态工具类并不少见\n"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//静态工具类的不适当使用——没有弹性并且不可测试\npublic class SpellChecker {\n    private static final Lexicon dictionary = ..;\n    private SpellChecker() {}//不可实例化\n\n    public static boolean isValid(String word) {..}\n    public static List<String> suggestions(String typo) {..}\n}\n")])])]),a("p",[t._v("类似地，将它们实现为单实例也不少见：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//此处用单实例不合适——缺乏弹性且不可测试\npublic class SpellChecker {\n    private final Lexicon dictionary = ..;\n    private SpellChecker(..) { }\n    public static SpellChecker INSTANCE = new SpellChecker();\n\n    public boolean isValid(String word) {..}\n    public List<String> suggestions(String typo) {..}\n}\n")])])]),a("p",[t._v("这两种方式都不令人满意，因为它们假定只有一本字典值得使用。实际上，每个语言都有自己的字典，专用字典用于专有词汇。同时，可能也需要专用词典来做测试\n希望一本字典可以适用于任何时候只是一厢情愿。")]),t._v(" "),a("p",[t._v("你可尝试将字典字段设置为非final的，在已存在的拼写检查中添加字典变更方法来使SpellChecker支持多本字典，但是这很别扭，容易出错，且在并发场景中不能\n工作。静态工具类和单例不适合那些行为是由底层资源参数化的类。")]),t._v(" "),a("p",[t._v("需要的是支持多个类（本例中的SpellChecker）实例的能力，每个使用客户端期望的资源（本例中的字典）。一个满足此需求的简单模式是在创建新实例时，将资源\n传入到构造函数中。这是依赖注入的一种形式：字典是拼写检查器的一个依赖，当创建拼写检查器的时候注入进来。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//依赖注入提供了弹性和测试性")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SpellChecker")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lexicon")]),t._v(" dictionary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SpellChecker")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lexicon")]),t._v(" dictionary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Objects")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("requireNonNull")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dictionary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" word"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("suggestions")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" typo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("依赖注入模式是如此简单，每个程序员使用多年，只是不知道它有一个正式的叫法。然而我们的拼写检查例子只有一个单一的资源（字典），\n依赖注入使用任意数量的资源和任意的依赖图。它保留了不可变性，所以多个使用者可以分享依赖的对象（假设使用者都需要相同的底层资源）。\n依赖注入同样适用于构造函数，静态工厂方法，和构造器。")]),t._v(" "),a("p",[t._v("该模式的一个有用变体是将资源工厂传递给构造函数。工厂是可以被反复调用创建类型实例的对象。这样的工厂体现了工厂方法模式。\nJava8引入的"),a("code",[t._v("Supplier<T>")]),t._v("接口，完美地表示工厂。接收"),a("code",[t._v("Supplier<T>")]),t._v("为输入参数的方法通常应当约束工厂的类型参数使用有限\n通配符类型来允许使用方将指定类型的任何子类型传入工厂。比如，这里有个方法使用客户端提供的工厂生产的每片瓦来制作镶嵌。\n"),a("code",[t._v("Mosaic create(Supplier<? extends Tile> tileFactory) { ... }")]),t._v("\n尽管依赖注入极大地提升了弹性和可测试性，它可能使大型项目变得杂乱，这些项目通常包含数千个依赖项。通过使用依赖注入框架，几乎可以\n消除这些杂乱，比如Dagger,Guice或者Spring。这些框架的使用超出了本书的范畴，但是注意，为手动依赖注入设计的API都被这些框架调整使用。")]),t._v(" "),a("p",[t._v("总结来说，不要使用单例或静态工具类实现依赖一个或多个底层资源的类，这些资源的行为会影响这个类，不要在类中直接创建这些资源。\n反之，传递资源或者创建这些资源的工厂到构造函数（静态工厂或构造器）中。这种实践称为依赖注入，会极大提升类的弹性，重用性，和可测试性。")])])}),[],!1,null,null,null);s.default=e.exports}}]);